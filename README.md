<h1>
everyday-node <a href="https://npmjs.org/package/everyday-node"><img src="https://img.shields.io/badge/npm-v1.1.0-F00.svg?colorA=000"/></a> <a href="src"><img src="https://img.shields.io/badge/loc-78-FFF.svg?colorA=000"/></a> <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-F0B.svg?colorA=000"/></a>
</h1>

<p></p>

Everyday node utilities.

<h4>
<table><tr><td title="Triple click to select and copy paste">
<code>npm i everyday-node </code>
</td><td title="Triple click to select and copy paste">
<code>pnpm add everyday-node </code>
</td><td title="Triple click to select and copy paste">
<code>yarn add everyday-node</code>
</td></tr></table>
</h4>

## API

<p>  <details id="&quot;node:stream/consumers&quot;$3913" title="Namespace" ><summary><span><a href="#&quot;node:stream/consumers&quot;$3913">#</a></span>  <code><strong>"node:stream/consumers"</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L22">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L22</a>  <ul>        <p>  <details id="arrayBuffer$3920" title="Function" ><summary><span><a href="#arrayBuffer$3920">#</a></span>  <code><strong>arrayBuffer</strong></code><em>(stream)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L18">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L18</a>  <ul>    <p>    <details id="stream$3922" title="Parameter" ><summary><span><a href="#stream$3922">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a> | <span>AsyncIterator</span>&lt;any, any, undefined&gt;</p>        </ul></details>  <p><strong>arrayBuffer</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<span>ArrayBuffer</span>&gt;</ul></p></p>    </ul></details><details id="blob$3923" title="Function" ><summary><span><a href="#blob$3923">#</a></span>  <code><strong>blob</strong></code><em>(stream)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L19">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L19</a>  <ul>    <p>    <details id="stream$3925" title="Parameter" ><summary><span><a href="#stream$3925">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a> | <span>AsyncIterator</span>&lt;any, any, undefined&gt;</p>        </ul></details>  <p><strong>blob</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<span>Blob</span>&gt;</ul></p></p>    </ul></details><details id="buffer$3914" title="Function" ><summary><span><a href="#buffer$3914">#</a></span>  <code><strong>buffer</strong></code><em>(stream)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L16">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L16</a>  <ul>    <p>    <details id="stream$3916" title="Parameter" ><summary><span><a href="#stream$3916">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a> | <span>AsyncIterator</span>&lt;any, any, undefined&gt;</p>        </ul></details>  <p><strong>buffer</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<a href="#Buffer$3932">Buffer</a>&gt;</ul></p></p>    </ul></details><details id="json$3926" title="Function" ><summary><span><a href="#json$3926">#</a></span>  <code><strong>json</strong></code><em>(stream)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L20">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L20</a>  <ul>    <p>    <details id="stream$3928" title="Parameter" ><summary><span><a href="#stream$3928">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a> | <span>AsyncIterator</span>&lt;any, any, undefined&gt;</p>        </ul></details>  <p><strong>json</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;unknown&gt;</ul></p></p>    </ul></details><details id="text$3917" title="Function" ><summary><span><a href="#text$3917">#</a></span>  <code><strong>text</strong></code><em>(stream)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L17">src/.fastpm/-/@types/node@17.0.45/stream/consumers.d.ts#L17</a>  <ul>    <p>    <details id="stream$3919" title="Parameter" ><summary><span><a href="#stream$3919">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a> | <span>AsyncIterator</span>&lt;any, any, undefined&gt;</p>        </ul></details>  <p><strong>text</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;string&gt;</ul></p></p>    </ul></details></p></ul></details>  <details id="&quot;node:stream/promises&quot;$3850" title="Namespace" ><summary><span><a href="#&quot;node:stream/promises&quot;$3850">#</a></span>  <code><strong>"node:stream/promises"</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L40">src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L40</a>  <ul>        <p>  <details id="finished$3851" title="Function" ><summary><span><a href="#finished$3851">#</a></span>  <code><strong>finished</strong></code><em>(stream, options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L3">src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L3</a>  <ul>    <p>    <details id="stream$3853" title="Parameter" ><summary><span><a href="#stream$3853">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="options$3854" title="Parameter" ><summary><span><a href="#options$3854">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#FinishedOptions$3210">FinishedOptions</a></p>        </ul></details>  <p><strong>finished</strong><em>(stream, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p></p>    </ul></details><details id="pipeline$3855" title="Function" ><summary><span><a href="#pipeline$3855">#</a></span>  <code><strong>pipeline</strong></code><em>(source, destination, options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L4">src/.fastpm/-/@types/node@17.0.45/stream/promises.d.ts#L4</a>  <ul>    <p>    <details id="source$3859" title="Parameter" ><summary><span><a href="#source$3859">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$3857">A</a></p>        </ul></details><details id="destination$3860" title="Parameter" ><summary><span><a href="#destination$3860">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$3858">B</a></p>        </ul></details><details id="options$3861" title="Parameter" ><summary><span><a href="#options$3861">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>B</span>&gt;<em>(source, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$3858">B</a>&gt;</ul></p>  <details id="source$3866" title="Parameter" ><summary><span><a href="#source$3866">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$3863">A</a></p>        </ul></details><details id="transform1$3867" title="Parameter" ><summary><span><a href="#transform1$3867">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$3864">T1</a></p>        </ul></details><details id="destination$3868" title="Parameter" ><summary><span><a href="#destination$3868">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$3865">B</a></p>        </ul></details><details id="options$3869" title="Parameter" ><summary><span><a href="#options$3869">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$3863">A</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$3865">B</a>&gt;</ul></p>  <details id="source$3875" title="Parameter" ><summary><span><a href="#source$3875">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$3871">A</a></p>        </ul></details><details id="transform1$3876" title="Parameter" ><summary><span><a href="#transform1$3876">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$3872">T1</a></p>        </ul></details><details id="transform2$3877" title="Parameter" ><summary><span><a href="#transform2$3877">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$3873">T2</a></p>        </ul></details><details id="destination$3878" title="Parameter" ><summary><span><a href="#destination$3878">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$3874">B</a></p>        </ul></details><details id="options$3879" title="Parameter" ><summary><span><a href="#options$3879">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$3871">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$3872">T1</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$3874">B</a>&gt;</ul></p>  <details id="source$3886" title="Parameter" ><summary><span><a href="#source$3886">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$3881">A</a></p>        </ul></details><details id="transform1$3887" title="Parameter" ><summary><span><a href="#transform1$3887">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$3882">T1</a></p>        </ul></details><details id="transform2$3888" title="Parameter" ><summary><span><a href="#transform2$3888">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$3883">T2</a></p>        </ul></details><details id="transform3$3889" title="Parameter" ><summary><span><a href="#transform3$3889">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$3884">T3</a></p>        </ul></details><details id="destination$3890" title="Parameter" ><summary><span><a href="#destination$3890">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$3885">B</a></p>        </ul></details><details id="options$3891" title="Parameter" ><summary><span><a href="#options$3891">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$3881">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$3882">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$3883">T2</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$3885">B</a>&gt;</ul></p>  <details id="source$3899" title="Parameter" ><summary><span><a href="#source$3899">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$3893">A</a></p>        </ul></details><details id="transform1$3900" title="Parameter" ><summary><span><a href="#transform1$3900">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$3894">T1</a></p>        </ul></details><details id="transform2$3901" title="Parameter" ><summary><span><a href="#transform2$3901">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$3895">T2</a></p>        </ul></details><details id="transform3$3902" title="Parameter" ><summary><span><a href="#transform3$3902">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$3896">T3</a></p>        </ul></details><details id="transform4$3903" title="Parameter" ><summary><span><a href="#transform4$3903">#</a></span>  <code><strong>transform4</strong></code>    </summary>    <ul><p><a href="#T4$3897">T4</a></p>        </ul></details><details id="destination$3904" title="Parameter" ><summary><span><a href="#destination$3904">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$3898">B</a></p>        </ul></details><details id="options$3905" title="Parameter" ><summary><span><a href="#options$3905">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$3893">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$3894">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$3895">T2</a>, any&gt;, <span>T4</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T3$3896">T3</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, transform4, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$3898">B</a>&gt;</ul></p>  <details id="streams$3907" title="Parameter" ><summary><span><a href="#streams$3907">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p>readonly     <a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a>  []</p>        </ul></details><details id="options$3908" title="Parameter" ><summary><span><a href="#options$3908">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>pipeline</strong><em>(streams, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p>  <details id="stream1$3910" title="Parameter" ><summary><span><a href="#stream1$3910">#</a></span>  <code><strong>stream1</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details><details id="stream2$3911" title="Parameter" ><summary><span><a href="#stream2$3911">#</a></span>  <code><strong>stream2</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="streams$3912" title="Parameter" ><summary><span><a href="#streams$3912">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a> | <a href="#PipelineOptions$3257">PipelineOptions</a>  []</p>        </ul></details>  <p><strong>pipeline</strong><em>(stream1, stream2, streams)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p></p>    </ul></details></p></ul></details>  <details id="EventEmitter$3604" title="Namespace" ><summary><span><a href="#EventEmitter$3604">#</a></span>  <code><strong>EventEmitter</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L310">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L310</a>  <ul>        <p>  <details id="EventEmitter$3498" title="Class" ><summary><span><a href="#EventEmitter$3498">#</a></span>  <code><strong>EventEmitter</strong></code>     &ndash; The <code>EventEmitter</code> class is defined and exposed by the <code>events</code> module:</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L73">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L73</a>  <ul>  <p>

```js
const EventEmitter = require('events')
```

All `EventEmitter`s emit the event `'newListener'` when new listeners are
added and `'removeListener'` when existing listeners are removed.

It supports the following option:

</p>
      <p>  <details id="constructor$3529" title="Constructor" ><summary><span><a href="#constructor$3529">#</a></span>  <code><strong>constructor</strong></code><em>(options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L74">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L74</a>  <ul>    <p>  <details id="new EventEmitter$3530" title="ConstructorSignature" ><summary><span><a href="#new EventEmitter$3530">#</a></span>  <code><strong>new EventEmitter</strong></code><em>()</em>    </summary>    <ul><p><a href="#EventEmitter$3498">EventEmitter</a></p>      <p>  <details id="options$3531" title="Parameter" ><summary><span><a href="#options$3531">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#EventEmitterOptions$3930">EventEmitterOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="captureRejectionSymbol$3526" title="Property" ><summary><span><a href="#captureRejectionSymbol$3526">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$3527" title="Property" ><summary><span><a href="#captureRejections$3527">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$3528" title="Property" ><summary><span><a href="#defaultMaxListeners$3528">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$3525" title="Property" ><summary><span><a href="#errorMonitor$3525">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="addListener$3532" title="Method" ><summary><span><a href="#addListener$3532">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3534" title="Parameter" ><summary><span><a href="#eventName$3534">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3535" title="Function" ><summary><span><a href="#listener$3535">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3538" title="Parameter" ><summary><span><a href="#args$3538">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="emit$3581" title="Method" ><summary><span><a href="#emit$3581">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3583" title="Parameter" ><summary><span><a href="#eventName$3583">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3584" title="Parameter" ><summary><span><a href="#args$3584">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$3602" title="Method" ><summary><span><a href="#eventNames$3602">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3573" title="Method" ><summary><span><a href="#getMaxListeners$3573">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$3585" title="Method" ><summary><span><a href="#listenerCount$3585">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3587" title="Parameter" ><summary><span><a href="#eventName$3587">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3575" title="Method" ><summary><span><a href="#listeners$3575">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3577" title="Parameter" ><summary><span><a href="#eventName$3577">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3560" title="Method" ><summary><span><a href="#off$3560">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3562" title="Parameter" ><summary><span><a href="#eventName$3562">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3563" title="Function" ><summary><span><a href="#listener$3563">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3566" title="Parameter" ><summary><span><a href="#args$3566">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="on$3539" title="Method" ><summary><span><a href="#on$3539">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3541" title="Parameter" ><summary><span><a href="#eventName$3541">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3542" title="Function" ><summary><span><a href="#listener$3542">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3545" title="Parameter" ><summary><span><a href="#args$3545">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="once$3546" title="Method" ><summary><span><a href="#once$3546">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3548" title="Parameter" ><summary><span><a href="#eventName$3548">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3549" title="Function" ><summary><span><a href="#listener$3549">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3552" title="Parameter" ><summary><span><a href="#args$3552">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="prependListener$3588" title="Method" ><summary><span><a href="#prependListener$3588">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3590" title="Parameter" ><summary><span><a href="#eventName$3590">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3591" title="Function" ><summary><span><a href="#listener$3591">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3594" title="Parameter" ><summary><span><a href="#args$3594">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="prependOnceListener$3595" title="Method" ><summary><span><a href="#prependOnceListener$3595">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3597" title="Parameter" ><summary><span><a href="#eventName$3597">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3598" title="Function" ><summary><span><a href="#listener$3598">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3601" title="Parameter" ><summary><span><a href="#args$3601">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="rawListeners$3578" title="Method" ><summary><span><a href="#rawListeners$3578">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3580" title="Parameter" ><summary><span><a href="#eventName$3580">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$3567" title="Method" ><summary><span><a href="#removeAllListeners$3567">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3569" title="Parameter" ><summary><span><a href="#event$3569">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="removeListener$3553" title="Method" ><summary><span><a href="#removeListener$3553">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3555" title="Parameter" ><summary><span><a href="#eventName$3555">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3556" title="Function" ><summary><span><a href="#listener$3556">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3559" title="Parameter" ><summary><span><a href="#args$3559">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="setMaxListeners$3570" title="Method" ><summary><span><a href="#setMaxListeners$3570">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3572" title="Parameter" ><summary><span><a href="#n$3572">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="getEventListeners$3517" title="Method" ><summary><span><a href="#getEventListeners$3517">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$3519" title="Parameter" ><summary><span><a href="#emitter$3519">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$3520" title="Parameter" ><summary><span><a href="#name$3520">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$3513" title="Method" ><summary><span><a href="#listenerCount$3513">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$3515" title="Parameter" ><summary><span><a href="#emitter$3515">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$3516" title="Parameter" ><summary><span><a href="#eventName$3516">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$3508" title="Method" ><summary><span><a href="#on$3508">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$3510" title="Parameter" ><summary><span><a href="#emitter$3510">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$3511" title="Parameter" ><summary><span><a href="#eventName$3511">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$3512" title="Parameter" ><summary><span><a href="#options$3512">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$3499" title="Method" ><summary><span><a href="#once$3499">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$3501" title="Parameter" ><summary><span><a href="#emitter$3501">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$3502" title="Parameter" ><summary><span><a href="#eventName$3502">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$3503" title="Parameter" ><summary><span><a href="#options$3503">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$3505" title="Parameter" ><summary><span><a href="#emitter$3505">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$3506" title="Parameter" ><summary><span><a href="#eventName$3506">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$3507" title="Parameter" ><summary><span><a href="#options$3507">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$3521" title="Method" ><summary><span><a href="#setMaxListeners$3521">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$3523" title="Parameter" ><summary><span><a href="#n$3523">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$3524" title="Parameter" ><summary><span><a href="#eventTargets$3524">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="Abortable$3606" title="Interface" ><summary><span><a href="#Abortable$3606">#</a></span>  <code><strong>Abortable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L313">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L313</a>  <ul>        <p>  <details id="signal$3607" title="Property" ><summary><span><a href="#signal$3607">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details></p></ul></details></p></ul></details>  <details id="internal$419" title="Namespace" ><summary><span><a href="#internal$419">#</a></span>  <code><strong>internal</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L31">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L31</a>  <ul>        <p>  <details id="finished$443" title="Namespace" ><summary><span><a href="#finished$443">#</a></span>  <code><strong>finished</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1010">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1010</a>  <ul>        <p>  <details id="__promisify__$444" title="Function" ><summary><span><a href="#__promisify__$444">#</a></span>  <code><strong>__promisify__</strong></code><em>(stream, options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1011">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1011</a>  <ul>    <p>    <details id="stream$446" title="Parameter" ><summary><span><a href="#stream$446">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="options$447" title="Parameter" ><summary><span><a href="#options$447">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#FinishedOptions$3210">FinishedOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong><em>(stream, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p></p>    </ul></details></p></ul></details><details id="pipeline$512" title="Namespace" ><summary><span><a href="#pipeline$512">#</a></span>  <code><strong>pipeline</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1198">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1198</a>  <ul>        <p>  <details id="__promisify__$513" title="Function" ><summary><span><a href="#__promisify__$513">#</a></span>  <code><strong>__promisify__</strong></code><em>(source, destination, options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1199">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1199</a>  <ul>    <p>    <details id="source$517" title="Parameter" ><summary><span><a href="#source$517">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$515">A</a></p>        </ul></details><details id="destination$518" title="Parameter" ><summary><span><a href="#destination$518">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$516">B</a></p>        </ul></details><details id="options$519" title="Parameter" ><summary><span><a href="#options$519">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>B</span>&gt;<em>(source, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$516">B</a>&gt;</ul></p>  <details id="source$524" title="Parameter" ><summary><span><a href="#source$524">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$521">A</a></p>        </ul></details><details id="transform1$525" title="Parameter" ><summary><span><a href="#transform1$525">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$522">T1</a></p>        </ul></details><details id="destination$526" title="Parameter" ><summary><span><a href="#destination$526">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$523">B</a></p>        </ul></details><details id="options$527" title="Parameter" ><summary><span><a href="#options$527">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$521">A</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$523">B</a>&gt;</ul></p>  <details id="source$533" title="Parameter" ><summary><span><a href="#source$533">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$529">A</a></p>        </ul></details><details id="transform1$534" title="Parameter" ><summary><span><a href="#transform1$534">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$530">T1</a></p>        </ul></details><details id="transform2$535" title="Parameter" ><summary><span><a href="#transform2$535">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$531">T2</a></p>        </ul></details><details id="destination$536" title="Parameter" ><summary><span><a href="#destination$536">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$532">B</a></p>        </ul></details><details id="options$537" title="Parameter" ><summary><span><a href="#options$537">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$529">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$530">T1</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$532">B</a>&gt;</ul></p>  <details id="source$544" title="Parameter" ><summary><span><a href="#source$544">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$539">A</a></p>        </ul></details><details id="transform1$545" title="Parameter" ><summary><span><a href="#transform1$545">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$540">T1</a></p>        </ul></details><details id="transform2$546" title="Parameter" ><summary><span><a href="#transform2$546">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$541">T2</a></p>        </ul></details><details id="transform3$547" title="Parameter" ><summary><span><a href="#transform3$547">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$542">T3</a></p>        </ul></details><details id="destination$548" title="Parameter" ><summary><span><a href="#destination$548">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$543">B</a></p>        </ul></details><details id="options$549" title="Parameter" ><summary><span><a href="#options$549">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$539">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$540">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$541">T2</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$543">B</a>&gt;</ul></p>  <details id="source$557" title="Parameter" ><summary><span><a href="#source$557">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$551">A</a></p>        </ul></details><details id="transform1$558" title="Parameter" ><summary><span><a href="#transform1$558">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$552">T1</a></p>        </ul></details><details id="transform2$559" title="Parameter" ><summary><span><a href="#transform2$559">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$553">T2</a></p>        </ul></details><details id="transform3$560" title="Parameter" ><summary><span><a href="#transform3$560">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$554">T3</a></p>        </ul></details><details id="transform4$561" title="Parameter" ><summary><span><a href="#transform4$561">#</a></span>  <code><strong>transform4</strong></code>    </summary>    <ul><p><a href="#T4$555">T4</a></p>        </ul></details><details id="destination$562" title="Parameter" ><summary><span><a href="#destination$562">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$556">B</a></p>        </ul></details><details id="options$563" title="Parameter" ><summary><span><a href="#options$563">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$551">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$552">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$553">T2</a>, any&gt;, <span>T4</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T3$554">T3</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, transform4, destination, options)</em>  &nbsp;=&gt;  <ul><a href="#PipelinePromise$3255">PipelinePromise</a>&lt;<a href="#B$556">B</a>&gt;</ul></p>  <details id="streams$565" title="Parameter" ><summary><span><a href="#streams$565">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p>readonly     <a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a>  []</p>        </ul></details><details id="options$566" title="Parameter" ><summary><span><a href="#options$566">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#PipelineOptions$3257">PipelineOptions</a></p>        </ul></details>  <p><strong>__promisify__</strong><em>(streams, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p>  <details id="stream1$568" title="Parameter" ><summary><span><a href="#stream1$568">#</a></span>  <code><strong>stream1</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details><details id="stream2$569" title="Parameter" ><summary><span><a href="#stream2$569">#</a></span>  <code><strong>stream2</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="streams$570" title="Parameter" ><summary><span><a href="#streams$570">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a> | <a href="#PipelineOptions$3257">PipelineOptions</a>  []</p>        </ul></details>  <p><strong>__promisify__</strong><em>(stream1, stream2, streams)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;void&gt;</ul></p></p>    </ul></details></p></ul></details><details id="Duplex$1669" title="Class" ><summary><span><a href="#Duplex$1669">#</a></span>  <code><strong>Duplex</strong></code>     &ndash; Duplex streams are streams that implement both the <code>Readable</code> and <code>Writable</code> interfaces.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L802">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L802</a>  <ul>  <p>

Examples of `Duplex` streams include:

- `TCP sockets`
- `zlib streams`
- `crypto streams`

</p>
      <p>  <details id="constructor$1706" title="Constructor" ><summary><span><a href="#constructor$1706">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L820">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L820</a>  <ul>    <p>  <details id="new Duplex$1707" title="ConstructorSignature" ><summary><span><a href="#new Duplex$1707">#</a></span>  <code><strong>new Duplex</strong></code><em>()</em>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>      <p>  <details id="opts$1708" title="Parameter" ><summary><span><a href="#opts$1708">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#DuplexOptions$1608">DuplexOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="allowHalfOpen$1716" title="Property" ><summary><span><a href="#allowHalfOpen$1716">#</a></span>  <code><strong>allowHalfOpen</strong></code>     &ndash; If <code>false</code> then the stream will automatically end the writable side when the
readable side ends. Set initially by the <code>allowHalfOpen</code> constructor option,
which defaults to <code>false</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819</a>  <ul><p>boolean</p>  <p>

This can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is
emitted.

</p>
      </ul></details><details id="destroyed$1794" title="Property" ><summary><span><a href="#destroyed$1794">#</a></span>  <code><strong>destroyed</strong></code>     &ndash; Is <code>true</code> after <code>readable.destroy()</code> has been called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115</a>  <ul><p>boolean</p>        </ul></details><details id="readable$1786" title="Property" ><summary><span><a href="#readable$1786">#</a></span>  <code><strong>readable</strong></code>     &ndash; Is <code>true</code> if it is safe to call <code>readable.read()</code>, which means
the stream has not been destroyed or emitted <code>'error'</code> or <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71</a>  <ul><p>boolean</p>        </ul></details><details id="readableAborted$1785" title="Property" ><summary><span><a href="#readableAborted$1785">#</a></span>  <code><strong>readableAborted</strong></code>     &ndash; Returns whether the stream was destroyed or errored before emitting <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65</a>  <ul><p>boolean</p>        </ul></details><details id="readableDidRead$1787" title="Property" ><summary><span><a href="#readableDidRead$1787">#</a></span>  <code><strong>readableDidRead</strong></code>     &ndash; Returns whether <code>'data'</code> has been emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77</a>  <ul><p>boolean</p>        </ul></details><details id="readableEncoding$1788" title="Property" ><summary><span><a href="#readableEncoding$1788">#</a></span>  <code><strong>readableEncoding</strong></code>     &ndash; Getter for the property <code>encoding</code> of a given <code>Readable</code> stream. The <code>encoding</code>property can be set using the <code>readable.setEncoding()</code> method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82</a>  <ul><p><code>null</code> | <a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="readableEnded$1789" title="Property" ><summary><span><a href="#readableEnded$1789">#</a></span>  <code><strong>readableEnded</strong></code>     &ndash; Becomes <code>true</code> when <code>'end'</code> event is emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87</a>  <ul><p>boolean</p>        </ul></details><details id="readableFlowing$1790" title="Property" ><summary><span><a href="#readableFlowing$1790">#</a></span>  <code><strong>readableFlowing</strong></code>     &ndash; This property reflects the current state of a <code>Readable</code> stream as described
in the <code>Three states</code> section.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93</a>  <ul><p><code>null</code> | boolean</p>        </ul></details><details id="readableHighWaterMark$1791" title="Property" ><summary><span><a href="#readableHighWaterMark$1791">#</a></span>  <code><strong>readableHighWaterMark</strong></code>     &ndash; Returns the value of <code>highWaterMark</code> passed when creating this <code>Readable</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98</a>  <ul><p>number</p>        </ul></details><details id="readableLength$1792" title="Property" ><summary><span><a href="#readableLength$1792">#</a></span>  <code><strong>readableLength</strong></code>     &ndash; This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding
the status of the <code>highWaterMark</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$1793" title="Property" ><summary><span><a href="#readableObjectMode$1793">#</a></span>  <code><strong>readableObjectMode</strong></code>     &ndash; Getter for the property <code>objectMode</code> of a given <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110</a>  <ul><p>boolean</p>        </ul></details><details id="writable$1709" title="Property" ><summary><span><a href="#writable$1709">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803</a>  <ul><p>boolean</p>        </ul></details><details id="writableCorked$1715" title="Property" ><summary><span><a href="#writableCorked$1715">#</a></span>  <code><strong>writableCorked</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809</a>  <ul><p>number</p>        </ul></details><details id="writableEnded$1710" title="Property" ><summary><span><a href="#writableEnded$1710">#</a></span>  <code><strong>writableEnded</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804</a>  <ul><p>boolean</p>        </ul></details><details id="writableFinished$1711" title="Property" ><summary><span><a href="#writableFinished$1711">#</a></span>  <code><strong>writableFinished</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805</a>  <ul><p>boolean</p>        </ul></details><details id="writableHighWaterMark$1712" title="Property" ><summary><span><a href="#writableHighWaterMark$1712">#</a></span>  <code><strong>writableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806</a>  <ul><p>number</p>        </ul></details><details id="writableLength$1713" title="Property" ><summary><span><a href="#writableLength$1713">#</a></span>  <code><strong>writableLength</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$1714" title="Property" ><summary><span><a href="#writableObjectMode$1714">#</a></span>  <code><strong>writableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808</a>  <ul><p>boolean</p>        </ul></details><details id="captureRejectionSymbol$1703" title="Property" ><summary><span><a href="#captureRejectionSymbol$1703">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$1704" title="Property" ><summary><span><a href="#captureRejections$1704">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$1705" title="Property" ><summary><span><a href="#defaultMaxListeners$1705">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$1702" title="Property" ><summary><span><a href="#errorMonitor$1702">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="[asyncIterator]$2117" title="Method" ><summary><span><a href="#[asyncIterator]$2117">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479</a>  <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="_construct$1795" title="Method" ><summary><span><a href="#_construct$1795">#</a></span>  <code><strong>_construct</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117</a>  <ul>    <p>    <details id="callback$1797" title="Function" ><summary><span><a href="#callback$1797">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1800" title="Parameter" ><summary><span><a href="#error$1800">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_construct</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_destroy$1735" title="Method" ><summary><span><a href="#_destroy$1735">#</a></span>  <code><strong>_destroy</strong></code><em>(error, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851</a>  <ul>    <p>    <details id="error$1737" title="Parameter" ><summary><span><a href="#error$1737">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$1738" title="Function" ><summary><span><a href="#callback$1738">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1741" title="Parameter" ><summary><span><a href="#error$1741">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_destroy</strong><em>(error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_final$1742" title="Method" ><summary><span><a href="#_final$1742">#</a></span>  <code><strong>_final</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852</a>  <ul>    <p>    <details id="callback$1744" title="Function" ><summary><span><a href="#callback$1744">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1747" title="Parameter" ><summary><span><a href="#error$1747">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_final</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_read$1801" title="Method" ><summary><span><a href="#_read$1801">#</a></span>  <code><strong>_read</strong></code><em>(size)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118</a>  <ul>    <p>    <details id="size$1803" title="Parameter" ><summary><span><a href="#size$1803">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>_read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_write$1717" title="Method" ><summary><span><a href="#_write$1717">#</a></span>  <code><strong>_write</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843</a>  <ul>    <p>    <details id="chunk$1719" title="Parameter" ><summary><span><a href="#chunk$1719">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1720" title="Parameter" ><summary><span><a href="#encoding$1720">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$1721" title="Function" ><summary><span><a href="#callback$1721">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1724" title="Parameter" ><summary><span><a href="#error$1724">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_write</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_writev$1725" title="Method" ><summary><span><a href="#_writev$1725">#</a></span>  <code><strong>_writev</strong></code><em>(chunks, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844</a>  <ul>    <p>    <details id="chunks$1727" title="Parameter" ><summary><span><a href="#chunks$1727">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$1729" title="Property" ><summary><span><a href="#chunk$1729">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846</a>  <ul><p>any</p>        </ul></details><details id="encoding$1730" title="Property" ><summary><span><a href="#encoding$1730">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$1731" title="Function" ><summary><span><a href="#callback$1731">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1734" title="Parameter" ><summary><span><a href="#error$1734">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_writev</strong><em>(chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="addListener$1833" title="Method" ><summary><span><a href="#addListener$1833">#</a></span>  <code><strong>addListener</strong></code><em>(event, listener)</em>     &ndash; Event emitter
The defined events on documents including:
1. close
2. data
3. end
4. error
5. pause
6. readable
7. resume</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423</a>  <ul>    <p>    <details id="event$1835" title="Parameter" ><summary><span><a href="#event$1835">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1836" title="Function" ><summary><span><a href="#listener$1836">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1840" title="Parameter" ><summary><span><a href="#event$1840">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1841" title="Function" ><summary><span><a href="#listener$1841">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1844" title="Parameter" ><summary><span><a href="#chunk$1844">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1846" title="Parameter" ><summary><span><a href="#event$1846">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1847" title="Function" ><summary><span><a href="#listener$1847">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1851" title="Parameter" ><summary><span><a href="#event$1851">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1852" title="Function" ><summary><span><a href="#listener$1852">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1855" title="Parameter" ><summary><span><a href="#err$1855">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1857" title="Parameter" ><summary><span><a href="#event$1857">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1858" title="Function" ><summary><span><a href="#listener$1858">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1862" title="Parameter" ><summary><span><a href="#event$1862">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1863" title="Function" ><summary><span><a href="#listener$1863">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1867" title="Parameter" ><summary><span><a href="#event$1867">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1868" title="Function" ><summary><span><a href="#listener$1868">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1872" title="Parameter" ><summary><span><a href="#event$1872">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1873" title="Function" ><summary><span><a href="#listener$1873">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1876" title="Parameter" ><summary><span><a href="#args$1876">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="cork$1781" title="Method" ><summary><span><a href="#cork$1781">#</a></span>  <code><strong>cork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859</a>  <ul>    <p>      <p><strong>cork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$1830" title="Method" ><summary><span><a href="#destroy$1830">#</a></span>  <code><strong>destroy</strong></code><em>(error)</em>     &ndash; Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code>event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the readable
stream will release any internal resources and subsequent calls to <code>push()</code>will be ignored.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411</a>  <ul>    <p>  <p>

Once `destroy()` has been called any further calls will be a no-op and no
further errors except from `_destroy()` may be emitted as `'error'`.

Implementors should not override this method, but instead implement `readable._destroy()`.

</p>
  <details id="error$1832" title="Parameter" ><summary><span><a href="#error$1832">#</a></span>  <code><strong>error</strong></code>     &ndash; Error which will be passed as payload in <code>'error'</code> event
</summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>destroy</strong><em>(error)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="emit$1877" title="Method" ><summary><span><a href="#emit$1877">#</a></span>  <code><strong>emit</strong></code><em>(event)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431</a>  <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="event$1879" title="Parameter" ><summary><span><a href="#event$1879">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1881" title="Parameter" ><summary><span><a href="#event$1881">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="chunk$1882" title="Parameter" ><summary><span><a href="#chunk$1882">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>emit</strong><em>(event, chunk)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1884" title="Parameter" ><summary><span><a href="#event$1884">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1886" title="Parameter" ><summary><span><a href="#event$1886">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="err$1887" title="Parameter" ><summary><span><a href="#err$1887">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>emit</strong><em>(event, err)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1889" title="Parameter" ><summary><span><a href="#event$1889">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1891" title="Parameter" ><summary><span><a href="#event$1891">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1893" title="Parameter" ><summary><span><a href="#event$1893">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1895" title="Parameter" ><summary><span><a href="#event$1895">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$1896" title="Parameter" ><summary><span><a href="#args$1896">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(event, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$1765" title="Method" ><summary><span><a href="#end$1765">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856</a>  <ul>    <p>    <details id="cb$1767" title="Function" ><summary><span><a href="#cb$1767">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="chunk$1771" title="Parameter" ><summary><span><a href="#chunk$1771">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$1772" title="Function" ><summary><span><a href="#cb$1772">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="chunk$1776" title="Parameter" ><summary><span><a href="#chunk$1776">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1777" title="Parameter" ><summary><span><a href="#encoding$1777">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$1778" title="Function" ><summary><span><a href="#cb$1778">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="eventNames$2150" title="Method" ><summary><span><a href="#eventNames$2150">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$2139" title="Method" ><summary><span><a href="#getMaxListeners$2139">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$1814" title="Method" ><summary><span><a href="#isPaused$1814">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>     &ndash; The <code>readable.isPaused()</code> method returns the current operating state of the<code>Readable</code>. This is used primarily by the mechanism that underlies the<code>readable.pipe()</code> method. In most
typical cases, there will be no reason to
use this method directly.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278</a>  <ul>    <p>  <p>

```js
const readable = new stream.Readable()

readable.isPaused() // === false
readable.pause()
readable.isPaused() // === true
readable.resume()
readable.isPaused() // === false
```

</p>
    <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$2147" title="Method" ><summary><span><a href="#listenerCount$2147">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$2149" title="Parameter" ><summary><span><a href="#eventName$2149">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$2141" title="Method" ><summary><span><a href="#listeners$2141">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$2143" title="Parameter" ><summary><span><a href="#eventName$2143">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$2126" title="Method" ><summary><span><a href="#off$2126">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$2128" title="Parameter" ><summary><span><a href="#eventName$2128">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2129" title="Function" ><summary><span><a href="#listener$2129">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2132" title="Parameter" ><summary><span><a href="#args$2132">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="on$1897" title="Method" ><summary><span><a href="#on$1897">#</a></span>  <code><strong>on</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439</a>  <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$1899" title="Parameter" ><summary><span><a href="#event$1899">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1900" title="Function" ><summary><span><a href="#listener$1900">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1904" title="Parameter" ><summary><span><a href="#event$1904">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1905" title="Function" ><summary><span><a href="#listener$1905">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1908" title="Parameter" ><summary><span><a href="#chunk$1908">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1910" title="Parameter" ><summary><span><a href="#event$1910">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1911" title="Function" ><summary><span><a href="#listener$1911">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1915" title="Parameter" ><summary><span><a href="#event$1915">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1916" title="Function" ><summary><span><a href="#listener$1916">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1919" title="Parameter" ><summary><span><a href="#err$1919">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1921" title="Parameter" ><summary><span><a href="#event$1921">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1922" title="Function" ><summary><span><a href="#listener$1922">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1926" title="Parameter" ><summary><span><a href="#event$1926">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1927" title="Function" ><summary><span><a href="#listener$1927">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1931" title="Parameter" ><summary><span><a href="#event$1931">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1932" title="Function" ><summary><span><a href="#listener$1932">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1936" title="Parameter" ><summary><span><a href="#event$1936">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1937" title="Function" ><summary><span><a href="#listener$1937">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1940" title="Parameter" ><summary><span><a href="#args$1940">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="once$1941" title="Method" ><summary><span><a href="#once$1941">#</a></span>  <code><strong>once</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447</a>  <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$1943" title="Parameter" ><summary><span><a href="#event$1943">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1944" title="Function" ><summary><span><a href="#listener$1944">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1948" title="Parameter" ><summary><span><a href="#event$1948">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1949" title="Function" ><summary><span><a href="#listener$1949">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1952" title="Parameter" ><summary><span><a href="#chunk$1952">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1954" title="Parameter" ><summary><span><a href="#event$1954">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1955" title="Function" ><summary><span><a href="#listener$1955">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1959" title="Parameter" ><summary><span><a href="#event$1959">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1960" title="Function" ><summary><span><a href="#listener$1960">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1963" title="Parameter" ><summary><span><a href="#err$1963">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1965" title="Parameter" ><summary><span><a href="#event$1965">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1966" title="Function" ><summary><span><a href="#listener$1966">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1970" title="Parameter" ><summary><span><a href="#event$1970">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1971" title="Function" ><summary><span><a href="#listener$1971">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1975" title="Parameter" ><summary><span><a href="#event$1975">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1976" title="Function" ><summary><span><a href="#listener$1976">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1980" title="Parameter" ><summary><span><a href="#event$1980">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1981" title="Function" ><summary><span><a href="#listener$1981">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1984" title="Parameter" ><summary><span><a href="#args$1984">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="pause$1810" title="Method" ><summary><span><a href="#pause$1810">#</a></span>  <code><strong>pause</strong></code><em>()</em>     &ndash; The <code>readable.pause()</code> method will cause a stream in flowing mode to stop
emitting <code>'data'</code> events, switching out of flowing mode. Any data that
becomes available will remain in the internal buffer.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242</a>  <ul>    <p>  <p>

```js
const readable = getReadableStreamSomehow()
readable.on('data', chunk => {
  console.log(`Received ${chunk.length} bytes of data.`)
  readable.pause()
  console.log('There will be no additional data for 1 second.')
  setTimeout(() => {
    console.log('Now data will start flowing again.')
    readable.resume()
  }, 1000)
})
```

The `readable.pause()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="pipe$2119" title="Method" ><summary><span><a href="#pipe$2119">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$2122" title="Parameter" ><summary><span><a href="#destination$2122">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$2123" title="Parameter" ><summary><span><a href="#options$2123">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$2125" title="Property" ><summary><span><a href="#end$2125">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$1985" title="Method" ><summary><span><a href="#prependListener$1985">#</a></span>  <code><strong>prependListener</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455</a>  <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1987" title="Parameter" ><summary><span><a href="#event$1987">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1988" title="Function" ><summary><span><a href="#listener$1988">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1992" title="Parameter" ><summary><span><a href="#event$1992">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1993" title="Function" ><summary><span><a href="#listener$1993">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1996" title="Parameter" ><summary><span><a href="#chunk$1996">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$1998" title="Parameter" ><summary><span><a href="#event$1998">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1999" title="Function" ><summary><span><a href="#listener$1999">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2003" title="Parameter" ><summary><span><a href="#event$2003">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2004" title="Function" ><summary><span><a href="#listener$2004">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2007" title="Parameter" ><summary><span><a href="#err$2007">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2009" title="Parameter" ><summary><span><a href="#event$2009">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2010" title="Function" ><summary><span><a href="#listener$2010">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2014" title="Parameter" ><summary><span><a href="#event$2014">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2015" title="Function" ><summary><span><a href="#listener$2015">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2019" title="Parameter" ><summary><span><a href="#event$2019">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2020" title="Function" ><summary><span><a href="#listener$2020">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2024" title="Parameter" ><summary><span><a href="#event$2024">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2025" title="Function" ><summary><span><a href="#listener$2025">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2028" title="Parameter" ><summary><span><a href="#args$2028">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="prependOnceListener$2029" title="Method" ><summary><span><a href="#prependOnceListener$2029">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463</a>  <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2031" title="Parameter" ><summary><span><a href="#event$2031">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2032" title="Function" ><summary><span><a href="#listener$2032">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2036" title="Parameter" ><summary><span><a href="#event$2036">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2037" title="Function" ><summary><span><a href="#listener$2037">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2040" title="Parameter" ><summary><span><a href="#chunk$2040">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2042" title="Parameter" ><summary><span><a href="#event$2042">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2043" title="Function" ><summary><span><a href="#listener$2043">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2047" title="Parameter" ><summary><span><a href="#event$2047">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2048" title="Function" ><summary><span><a href="#listener$2048">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2051" title="Parameter" ><summary><span><a href="#err$2051">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2053" title="Parameter" ><summary><span><a href="#event$2053">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2054" title="Function" ><summary><span><a href="#listener$2054">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2058" title="Parameter" ><summary><span><a href="#event$2058">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2059" title="Function" ><summary><span><a href="#listener$2059">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2063" title="Parameter" ><summary><span><a href="#event$2063">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2064" title="Function" ><summary><span><a href="#listener$2064">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2068" title="Parameter" ><summary><span><a href="#event$2068">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2069" title="Function" ><summary><span><a href="#listener$2069">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2072" title="Parameter" ><summary><span><a href="#args$2072">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="push$1826" title="Method" ><summary><span><a href="#push$1826">#</a></span>  <code><strong>push</strong></code><em>(chunk, encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398</a>  <ul>    <p>    <details id="chunk$1828" title="Parameter" ><summary><span><a href="#chunk$1828">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1829" title="Parameter" ><summary><span><a href="#encoding$1829">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>push</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="rawListeners$2144" title="Method" ><summary><span><a href="#rawListeners$2144">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$2146" title="Parameter" ><summary><span><a href="#eventName$2146">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$1804" title="Method" ><summary><span><a href="#read$1804">#</a></span>  <code><strong>read</strong></code><em>(size)</em>     &ndash; The <code>readable.read()</code> method pulls some data out of the internal buffer and
returns it. If no data available to be read, <code>null</code> is returned. By default,
the data will be returned as a <code>Buffer</code> object unless an encoding has been
specified using the <code>readable.setEncoding()</code> method or the stream is operating
in object mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195</a>  <ul>    <p>  <p>

The optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which
case all of the data remaining in the internal
buffer will be returned.

If the `size` argument is not specified, all of the data contained in the
internal buffer will be returned.

The `size` argument must be less than or equal to 1 GiB.

The `readable.read()` method should only be called on `Readable` streams
operating in paused mode. In flowing mode, `readable.read()` is called
automatically until the internal buffer is fully drained.

```js
const readable = getReadableStreamSomehow()

// 'readable' may be triggered multiple times as data is buffered in
readable.on('readable', () => {
  let chunk
  console.log('Stream is readable (new data received in buffer)')
  // Use a loop to make sure we read all currently available data
  while (null !== (chunk = readable.read())) {
    console.log(`Read ${chunk.length} bytes of data...`)
  }
})

// 'end' will be triggered once when there is no more data available
readable.on('end', () => {
  console.log('Reached end of stream.')
})
```

Each call to `readable.read()` returns a chunk of data, or `null`. The chunks
are not concatenated. A `while` loop is necessary to consume all data
currently in the buffer. When reading a large file `.read()` may return `null`,
having consumed all buffered content so far, but there is still more data to
come not yet buffered. In this case a new `'readable'` event will be emitted
when there is more data in the buffer. Finally the `'end'` event will be
emitted when there is no more data to come.

Therefore to read a file's whole contents from a `readable`, it is necessary
to collect chunks across multiple `'readable'` events:

```js
const chunks = []

readable.on('readable', () => {
  let chunk
  while (null !== (chunk = readable.read())) {
    chunks.push(chunk)
  }
})

readable.on('end', () => {
  const content = chunks.join('')
})
```

A `Readable` stream in object mode will always return a single item from
a call to `readable.read(size)`, regardless of the value of the`size` argument.

If the `readable.read()` method returns a chunk of data, a `'data'` event will
also be emitted.

Calling {@link read} after the `'end'` event has
been emitted will return `null`. No runtime error will be raised.

</p>
  <details id="size$1806" title="Parameter" ><summary><span><a href="#size$1806">#</a></span>  <code><strong>size</strong></code>     &ndash; Optional argument to specify how much data to read.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>any</ul></p></p>    </ul></details><details id="removeAllListeners$2133" title="Method" ><summary><span><a href="#removeAllListeners$2133">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2135" title="Parameter" ><summary><span><a href="#event$2135">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="removeListener$2073" title="Method" ><summary><span><a href="#removeListener$2073">#</a></span>  <code><strong>removeListener</strong></code><em>(event, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471</a>  <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2075" title="Parameter" ><summary><span><a href="#event$2075">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2076" title="Function" ><summary><span><a href="#listener$2076">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2080" title="Parameter" ><summary><span><a href="#event$2080">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2081" title="Function" ><summary><span><a href="#listener$2081">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2084" title="Parameter" ><summary><span><a href="#chunk$2084">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2086" title="Parameter" ><summary><span><a href="#event$2086">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2087" title="Function" ><summary><span><a href="#listener$2087">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2091" title="Parameter" ><summary><span><a href="#event$2091">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2092" title="Function" ><summary><span><a href="#listener$2092">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2095" title="Parameter" ><summary><span><a href="#err$2095">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2097" title="Parameter" ><summary><span><a href="#event$2097">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2098" title="Function" ><summary><span><a href="#listener$2098">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2102" title="Parameter" ><summary><span><a href="#event$2102">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2103" title="Function" ><summary><span><a href="#listener$2103">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2107" title="Parameter" ><summary><span><a href="#event$2107">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2108" title="Function" ><summary><span><a href="#listener$2108">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p>  <details id="event$2112" title="Parameter" ><summary><span><a href="#event$2112">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2113" title="Function" ><summary><span><a href="#listener$2113">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2116" title="Parameter" ><summary><span><a href="#args$2116">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="resume$1812" title="Method" ><summary><span><a href="#resume$1812">#</a></span>  <code><strong>resume</strong></code><em>()</em>     &ndash; The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to
resume emitting <code>'data'</code> events, switching the stream into flowing mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261</a>  <ul>    <p>  <p>

The `readable.resume()` method can be used to fully consume the data from a
stream without actually processing any of that data:

```js
getReadableStreamSomehow()
  .resume()
  .on('end', () => {
    console.log('Reached the end, but did not read anything.')
  })
```

The `readable.resume()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="setDefaultEncoding$1762" title="Method" ><summary><span><a href="#setDefaultEncoding$1762">#</a></span>  <code><strong>setDefaultEncoding</strong></code><em>(encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855</a>  <ul>    <p>    <details id="encoding$1764" title="Parameter" ><summary><span><a href="#encoding$1764">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setDefaultEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="setEncoding$1807" title="Method" ><summary><span><a href="#setEncoding$1807">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>     &ndash; The <code>readable.setEncoding()</code> method sets the character encoding for
data read from the <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220</a>  <ul>    <p>  <p>

By default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data
to be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding('utf8')` will cause the
output data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal
string format.

The `Readable` stream will properly handle multi-byte characters delivered
through the stream that would otherwise become improperly decoded if simply
pulled from the stream as `Buffer` objects.

```js
const readable = getReadableStreamSomehow()
readable.setEncoding('utf8')
readable.on('data', chunk => {
  assert.equal(typeof chunk, 'string')
  console.log('Got %d characters of string data:', chunk.length)
})
```

</p>
  <details id="encoding$1809" title="Parameter" ><summary><span><a href="#encoding$1809">#</a></span>  <code><strong>encoding</strong></code>     &ndash; The encoding to use.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="setMaxListeners$2136" title="Method" ><summary><span><a href="#setMaxListeners$2136">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$2138" title="Parameter" ><summary><span><a href="#n$2138">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="uncork$1783" title="Method" ><summary><span><a href="#uncork$1783">#</a></span>  <code><strong>uncork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860</a>  <ul>    <p>      <p><strong>uncork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="unpipe$1816" title="Method" ><summary><span><a href="#unpipe$1816">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>     &ndash; The <code>readable.unpipe()</code> method detaches a <code>Writable</code> stream previously attached
using the {@link pipe} method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305</a>  <ul>    <p>  <p>

If the `destination` is not specified, then _all_ pipes are detached.

If the `destination` is specified, but no pipe is set up for it, then
the method does nothing.

```js
const fs = require('fs')
const readable = getReadableStreamSomehow()
const writable = fs.createWriteStream('file.txt')
// All the data from readable goes into 'file.txt',
// but only for the first second.
readable.pipe(writable)
setTimeout(() => {
  console.log('Stop writing to file.txt.')
  readable.unpipe(writable)
  console.log('Manually close the file stream.')
  writable.end()
}, 1000)
```

</p>
  <details id="destination$1818" title="Parameter" ><summary><span><a href="#destination$1818">#</a></span>  <code><strong>destination</strong></code>     &ndash; Optional specific stream to unpipe
</summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="unshift$1819" title="Method" ><summary><span><a href="#unshift$1819">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>     &ndash; Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF) and behaves the
same as <code>readable.push(null)</code>, after which no more data can be written. The EOF
signal is put at the end of the buffer and any buffered data will still be
flushed.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371</a>  <ul>    <p>  <p>

The `readable.unshift()` method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.

The `stream.unshift(chunk)` method cannot be called after the `'end'` event
has been emitted or a runtime error will be thrown.

Developers using `stream.unshift()` often should consider switching to
use of a `Transform` stream instead. See the `API for stream implementers` section for more information.

```js
// Pull off a header delimited by \n\n.
// Use unshift() if we get too much.
// Call the callback with (error, header, stream).
const { StringDecoder } = require('string_decoder')
function parseHeader(stream, callback) {
  stream.on('error', callback)
  stream.on('readable', onReadable)
  const decoder = new StringDecoder('utf8')
  let header = ''
  function onReadable() {
    let chunk
    while (null !== (chunk = stream.read())) {
      const str = decoder.write(chunk)
      if (str.match(/\n\n/)) {
        // Found the header boundary.
        const split = str.split(/\n\n/)
        header += split.shift()
        const remaining = split.join('\n\n')
        const buf = Buffer.from(remaining, 'utf8')
        stream.removeListener('error', callback)
        // Remove the 'readable' listener before unshifting.
        stream.removeListener('readable', onReadable)
        if (buf.length)
          stream.unshift(buf)
        // Now the body of the message can be read from the stream.
        callback(null, header, stream)
      } else {
        // Still reading the header.
        header += str
      }
    }
  }
}
```

Unlike {@link push}, `stream.unshift(chunk)` will not
end the reading process by resetting the internal reading state of the stream.
This can cause unexpected results if `readable.unshift()` is called during a
read (i.e. from within a {@link _read} implementation on a
custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,
however it is best to simply avoid calling `readable.unshift()` while in the
process of performing a read.

</p>
  <details id="chunk$1821" title="Parameter" ><summary><span><a href="#chunk$1821">#</a></span>  <code><strong>chunk</strong></code>     &ndash; Chunk of data to unshift onto the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code>, <code>Uint8Array</code> or <code>null</code>. For object mode
streams, <code>chunk</code> may be any JavaScript value.</summary>    <ul><p>any</p>        </ul></details><details id="encoding$1822" title="Parameter" ><summary><span><a href="#encoding$1822">#</a></span>  <code><strong>encoding</strong></code>     &ndash; Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$1823" title="Method" ><summary><span><a href="#wrap$1823">#</a></span>  <code><strong>wrap</strong></code><em>(stream)</em>     &ndash; Prior to Node.js 0.10, streams did not implement the entire <code>stream</code> module API
as it is currently defined. (See <code>Compatibility</code> for more information.)</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397</a>  <ul>    <p>  <p>

When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`
stream that uses
the old stream as its data source.

It will rarely be necessary to use `readable.wrap()` but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.

```js
const { OldReader } = require('./old-api-module.js')
const { Readable } = require('stream')
const oreader = new OldReader()
const myReader = new Readable().wrap(oreader)

myReader.on('readable', () => {
  myReader.read() // etc.
})
```

</p>
  <details id="stream$1825" title="Parameter" ><summary><span><a href="#stream$1825">#</a></span>  <code><strong>stream</strong></code>     &ndash; An &quot;old style&quot; readable stream
</summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="write$1748" title="Method" ><summary><span><a href="#write$1748">#</a></span>  <code><strong>write</strong></code><em>(chunk, encoding, cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853</a>  <ul>    <p>    <details id="chunk$1750" title="Parameter" ><summary><span><a href="#chunk$1750">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1751" title="Parameter" ><summary><span><a href="#encoding$1751">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$1752" title="Function" ><summary><span><a href="#cb$1752">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1755" title="Parameter" ><summary><span><a href="#error$1755">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="chunk$1757" title="Parameter" ><summary><span><a href="#chunk$1757">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$1758" title="Function" ><summary><span><a href="#cb$1758">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1761" title="Parameter" ><summary><span><a href="#error$1761">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="from$1670" title="Method" ><summary><span><a href="#from$1670">#</a></span>  <code><strong>from</strong></code><em>(src)</em>     &ndash; A utility method for creating duplex streams.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842</a>  <ul>    <p>  <p>

- `Stream` converts writable stream into writable `Duplex` and readable stream
  to `Duplex`.
- `Blob` converts into readable `Duplex`.
- `string` converts into readable `Duplex`.
- `ArrayBuffer` converts into readable `Duplex`.
- `AsyncIterable` converts into a readable `Duplex`. Cannot yield `null`.
- `AsyncGeneratorFunction` converts into a readable/writable transform
  `Duplex`. Must take a source `AsyncIterable` as first parameter. Cannot yield
  `null`.
- `AsyncFunction` converts into a writable `Duplex`. Must return
  either `null` or `undefined`
- `Object ({ writable, readable })` converts `readable` and
  `writable` into `Stream` and then combines them into `Duplex` where the
  `Duplex` will write to the `writable` and read from the `readable`.
- `Promise` converts into readable `Duplex`. Value `null` is ignored.

</p>
  <details id="src$1672" title="Parameter" ><summary><span><a href="#src$1672">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p>string | <span>Object</span> | <a href="#Stream$119">Stream</a> | <span>ArrayBuffer</span> | <span>Promise</span>&lt;any&gt; | <span>Iterable</span>&lt;any&gt; | <span>AsyncIterable</span>&lt;any&gt; | <span>Blob</span> | <span>AsyncGeneratorFunction</span></p>        </ul></details>  <p><strong>from</strong><em>(src)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="getEventListeners$1694" title="Method" ><summary><span><a href="#getEventListeners$1694">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$1696" title="Parameter" ><summary><span><a href="#emitter$1696">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$1697" title="Parameter" ><summary><span><a href="#name$1697">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="isDisturbed$1673" title="Method" ><summary><span><a href="#isDisturbed$1673">#</a></span>  <code><strong>isDisturbed</strong></code><em>(stream)</em>     &ndash; Returns whether the stream has been read from or cancelled.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59</a>  <ul>    <p>    <details id="stream$1675" title="Parameter" ><summary><span><a href="#stream$1675">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>isDisturbed</strong><em>(stream)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$1690" title="Method" ><summary><span><a href="#listenerCount$1690">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$1692" title="Parameter" ><summary><span><a href="#emitter$1692">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$1693" title="Parameter" ><summary><span><a href="#eventName$1693">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$1685" title="Method" ><summary><span><a href="#on$1685">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$1687" title="Parameter" ><summary><span><a href="#emitter$1687">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$1688" title="Parameter" ><summary><span><a href="#eventName$1688">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$1689" title="Parameter" ><summary><span><a href="#options$1689">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$1676" title="Method" ><summary><span><a href="#once$1676">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$1678" title="Parameter" ><summary><span><a href="#emitter$1678">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$1679" title="Parameter" ><summary><span><a href="#eventName$1679">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$1680" title="Parameter" ><summary><span><a href="#options$1680">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$1682" title="Parameter" ><summary><span><a href="#emitter$1682">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$1683" title="Parameter" ><summary><span><a href="#eventName$1683">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$1684" title="Parameter" ><summary><span><a href="#options$1684">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$1698" title="Method" ><summary><span><a href="#setMaxListeners$1698">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$1700" title="Parameter" ><summary><span><a href="#n$1700">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$1701" title="Parameter" ><summary><span><a href="#eventTargets$1701">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="PassThrough$2719" title="Class" ><summary><span><a href="#PassThrough$2719">#</a></span>  <code><strong>PassThrough</strong></code>     &ndash; The <code>stream.PassThrough</code> class is a trivial implementation of a <code>Transform</code> stream that simply passes the input bytes across to the output. Its purpose is
primarily for examples and testing, but there are some use cases where<code>stream.PassThrough</code> is useful as a building block for novel sorts of streams.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L900">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L900</a>  <ul>        <p>  <details id="constructor$2756" title="Constructor" ><summary><span><a href="#constructor$2756">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>    <ul>    <p>  <details id="new PassThrough$2757" title="ConstructorSignature" ><summary><span><a href="#new PassThrough$2757">#</a></span>  <code><strong>new PassThrough</strong></code><em>()</em>    </summary>    <ul><p><a href="#PassThrough$2719">PassThrough</a></p>      <p>  <details id="opts$2758" title="Parameter" ><summary><span><a href="#opts$2758">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#TransformOptions$2157">TransformOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="allowHalfOpen$2774" title="Property" ><summary><span><a href="#allowHalfOpen$2774">#</a></span>  <code><strong>allowHalfOpen</strong></code>     &ndash; If <code>false</code> then the stream will automatically end the writable side when the
readable side ends. Set initially by the <code>allowHalfOpen</code> constructor option,
which defaults to <code>false</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819</a>  <ul><p>boolean</p>  <p>

This can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is
emitted.

</p>
      </ul></details><details id="destroyed$2852" title="Property" ><summary><span><a href="#destroyed$2852">#</a></span>  <code><strong>destroyed</strong></code>     &ndash; Is <code>true</code> after <code>readable.destroy()</code> has been called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115</a>  <ul><p>boolean</p>        </ul></details><details id="readable$2844" title="Property" ><summary><span><a href="#readable$2844">#</a></span>  <code><strong>readable</strong></code>     &ndash; Is <code>true</code> if it is safe to call <code>readable.read()</code>, which means
the stream has not been destroyed or emitted <code>'error'</code> or <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71</a>  <ul><p>boolean</p>        </ul></details><details id="readableAborted$2843" title="Property" ><summary><span><a href="#readableAborted$2843">#</a></span>  <code><strong>readableAborted</strong></code>     &ndash; Returns whether the stream was destroyed or errored before emitting <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65</a>  <ul><p>boolean</p>        </ul></details><details id="readableDidRead$2845" title="Property" ><summary><span><a href="#readableDidRead$2845">#</a></span>  <code><strong>readableDidRead</strong></code>     &ndash; Returns whether <code>'data'</code> has been emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77</a>  <ul><p>boolean</p>        </ul></details><details id="readableEncoding$2846" title="Property" ><summary><span><a href="#readableEncoding$2846">#</a></span>  <code><strong>readableEncoding</strong></code>     &ndash; Getter for the property <code>encoding</code> of a given <code>Readable</code> stream. The <code>encoding</code>property can be set using the <code>readable.setEncoding()</code> method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82</a>  <ul><p><code>null</code> | <a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="readableEnded$2847" title="Property" ><summary><span><a href="#readableEnded$2847">#</a></span>  <code><strong>readableEnded</strong></code>     &ndash; Becomes <code>true</code> when <code>'end'</code> event is emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87</a>  <ul><p>boolean</p>        </ul></details><details id="readableFlowing$2848" title="Property" ><summary><span><a href="#readableFlowing$2848">#</a></span>  <code><strong>readableFlowing</strong></code>     &ndash; This property reflects the current state of a <code>Readable</code> stream as described
in the <code>Three states</code> section.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93</a>  <ul><p><code>null</code> | boolean</p>        </ul></details><details id="readableHighWaterMark$2849" title="Property" ><summary><span><a href="#readableHighWaterMark$2849">#</a></span>  <code><strong>readableHighWaterMark</strong></code>     &ndash; Returns the value of <code>highWaterMark</code> passed when creating this <code>Readable</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98</a>  <ul><p>number</p>        </ul></details><details id="readableLength$2850" title="Property" ><summary><span><a href="#readableLength$2850">#</a></span>  <code><strong>readableLength</strong></code>     &ndash; This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding
the status of the <code>highWaterMark</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$2851" title="Property" ><summary><span><a href="#readableObjectMode$2851">#</a></span>  <code><strong>readableObjectMode</strong></code>     &ndash; Getter for the property <code>objectMode</code> of a given <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110</a>  <ul><p>boolean</p>        </ul></details><details id="writable$2767" title="Property" ><summary><span><a href="#writable$2767">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803</a>  <ul><p>boolean</p>        </ul></details><details id="writableCorked$2773" title="Property" ><summary><span><a href="#writableCorked$2773">#</a></span>  <code><strong>writableCorked</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809</a>  <ul><p>number</p>        </ul></details><details id="writableEnded$2768" title="Property" ><summary><span><a href="#writableEnded$2768">#</a></span>  <code><strong>writableEnded</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804</a>  <ul><p>boolean</p>        </ul></details><details id="writableFinished$2769" title="Property" ><summary><span><a href="#writableFinished$2769">#</a></span>  <code><strong>writableFinished</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805</a>  <ul><p>boolean</p>        </ul></details><details id="writableHighWaterMark$2770" title="Property" ><summary><span><a href="#writableHighWaterMark$2770">#</a></span>  <code><strong>writableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806</a>  <ul><p>number</p>        </ul></details><details id="writableLength$2771" title="Property" ><summary><span><a href="#writableLength$2771">#</a></span>  <code><strong>writableLength</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$2772" title="Property" ><summary><span><a href="#writableObjectMode$2772">#</a></span>  <code><strong>writableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808</a>  <ul><p>boolean</p>        </ul></details><details id="captureRejectionSymbol$2753" title="Property" ><summary><span><a href="#captureRejectionSymbol$2753">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$2754" title="Property" ><summary><span><a href="#captureRejections$2754">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$2755" title="Property" ><summary><span><a href="#defaultMaxListeners$2755">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$2752" title="Property" ><summary><span><a href="#errorMonitor$2752">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="[asyncIterator]$3175" title="Method" ><summary><span><a href="#[asyncIterator]$3175">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479</a>  <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="_construct$2853" title="Method" ><summary><span><a href="#_construct$2853">#</a></span>  <code><strong>_construct</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117</a>  <ul>    <p>    <details id="callback$2855" title="Function" ><summary><span><a href="#callback$2855">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2858" title="Parameter" ><summary><span><a href="#error$2858">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_construct</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_destroy$2793" title="Method" ><summary><span><a href="#_destroy$2793">#</a></span>  <code><strong>_destroy</strong></code><em>(error, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851</a>  <ul>    <p>    <details id="error$2795" title="Parameter" ><summary><span><a href="#error$2795">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$2796" title="Function" ><summary><span><a href="#callback$2796">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2799" title="Parameter" ><summary><span><a href="#error$2799">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_destroy</strong><em>(error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_final$2800" title="Method" ><summary><span><a href="#_final$2800">#</a></span>  <code><strong>_final</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852</a>  <ul>    <p>    <details id="callback$2802" title="Function" ><summary><span><a href="#callback$2802">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2805" title="Parameter" ><summary><span><a href="#error$2805">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_final</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_flush$2764" title="Method" ><summary><span><a href="#_flush$2764">#</a></span>  <code><strong>_flush</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L894">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L894</a>  <ul>    <p>    <details id="callback$2766" title="Parameter" ><summary><span><a href="#callback$2766">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>_flush</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_read$2859" title="Method" ><summary><span><a href="#_read$2859">#</a></span>  <code><strong>_read</strong></code><em>(size)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118</a>  <ul>    <p>    <details id="size$2861" title="Parameter" ><summary><span><a href="#size$2861">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>_read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_transform$2759" title="Method" ><summary><span><a href="#_transform$2759">#</a></span>  <code><strong>_transform</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L893">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L893</a>  <ul>    <p>    <details id="chunk$2761" title="Parameter" ><summary><span><a href="#chunk$2761">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2762" title="Parameter" ><summary><span><a href="#encoding$2762">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2763" title="Parameter" ><summary><span><a href="#callback$2763">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>_transform</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_write$2775" title="Method" ><summary><span><a href="#_write$2775">#</a></span>  <code><strong>_write</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843</a>  <ul>    <p>    <details id="chunk$2777" title="Parameter" ><summary><span><a href="#chunk$2777">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2778" title="Parameter" ><summary><span><a href="#encoding$2778">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2779" title="Function" ><summary><span><a href="#callback$2779">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2782" title="Parameter" ><summary><span><a href="#error$2782">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_write</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_writev$2783" title="Method" ><summary><span><a href="#_writev$2783">#</a></span>  <code><strong>_writev</strong></code><em>(chunks, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844</a>  <ul>    <p>    <details id="chunks$2785" title="Parameter" ><summary><span><a href="#chunks$2785">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$2787" title="Property" ><summary><span><a href="#chunk$2787">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846</a>  <ul><p>any</p>        </ul></details><details id="encoding$2788" title="Property" ><summary><span><a href="#encoding$2788">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$2789" title="Function" ><summary><span><a href="#callback$2789">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2792" title="Parameter" ><summary><span><a href="#error$2792">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_writev</strong><em>(chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="addListener$2891" title="Method" ><summary><span><a href="#addListener$2891">#</a></span>  <code><strong>addListener</strong></code><em>(event, listener)</em>     &ndash; Event emitter
The defined events on documents including:
1. close
2. data
3. end
4. error
5. pause
6. readable
7. resume</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423</a>  <ul>    <p>    <details id="event$2893" title="Parameter" ><summary><span><a href="#event$2893">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2894" title="Function" ><summary><span><a href="#listener$2894">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2898" title="Parameter" ><summary><span><a href="#event$2898">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2899" title="Function" ><summary><span><a href="#listener$2899">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2902" title="Parameter" ><summary><span><a href="#chunk$2902">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2904" title="Parameter" ><summary><span><a href="#event$2904">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2905" title="Function" ><summary><span><a href="#listener$2905">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2909" title="Parameter" ><summary><span><a href="#event$2909">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2910" title="Function" ><summary><span><a href="#listener$2910">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2913" title="Parameter" ><summary><span><a href="#err$2913">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2915" title="Parameter" ><summary><span><a href="#event$2915">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2916" title="Function" ><summary><span><a href="#listener$2916">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2920" title="Parameter" ><summary><span><a href="#event$2920">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2921" title="Function" ><summary><span><a href="#listener$2921">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2925" title="Parameter" ><summary><span><a href="#event$2925">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2926" title="Function" ><summary><span><a href="#listener$2926">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2930" title="Parameter" ><summary><span><a href="#event$2930">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2931" title="Function" ><summary><span><a href="#listener$2931">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2934" title="Parameter" ><summary><span><a href="#args$2934">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="cork$2839" title="Method" ><summary><span><a href="#cork$2839">#</a></span>  <code><strong>cork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859</a>  <ul>    <p>      <p><strong>cork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$2888" title="Method" ><summary><span><a href="#destroy$2888">#</a></span>  <code><strong>destroy</strong></code><em>(error)</em>     &ndash; Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code>event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the readable
stream will release any internal resources and subsequent calls to <code>push()</code>will be ignored.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411</a>  <ul>    <p>  <p>

Once `destroy()` has been called any further calls will be a no-op and no
further errors except from `_destroy()` may be emitted as `'error'`.

Implementors should not override this method, but instead implement `readable._destroy()`.

</p>
  <details id="error$2890" title="Parameter" ><summary><span><a href="#error$2890">#</a></span>  <code><strong>error</strong></code>     &ndash; Error which will be passed as payload in <code>'error'</code> event
</summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>destroy</strong><em>(error)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="emit$2935" title="Method" ><summary><span><a href="#emit$2935">#</a></span>  <code><strong>emit</strong></code><em>(event)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431</a>  <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="event$2937" title="Parameter" ><summary><span><a href="#event$2937">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2939" title="Parameter" ><summary><span><a href="#event$2939">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="chunk$2940" title="Parameter" ><summary><span><a href="#chunk$2940">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>emit</strong><em>(event, chunk)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2942" title="Parameter" ><summary><span><a href="#event$2942">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2944" title="Parameter" ><summary><span><a href="#event$2944">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="err$2945" title="Parameter" ><summary><span><a href="#err$2945">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>emit</strong><em>(event, err)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2947" title="Parameter" ><summary><span><a href="#event$2947">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2949" title="Parameter" ><summary><span><a href="#event$2949">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2951" title="Parameter" ><summary><span><a href="#event$2951">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2953" title="Parameter" ><summary><span><a href="#event$2953">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$2954" title="Parameter" ><summary><span><a href="#args$2954">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(event, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$2823" title="Method" ><summary><span><a href="#end$2823">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856</a>  <ul>    <p>    <details id="cb$2825" title="Function" ><summary><span><a href="#cb$2825">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="chunk$2829" title="Parameter" ><summary><span><a href="#chunk$2829">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$2830" title="Function" ><summary><span><a href="#cb$2830">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="chunk$2834" title="Parameter" ><summary><span><a href="#chunk$2834">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2835" title="Parameter" ><summary><span><a href="#encoding$2835">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$2836" title="Function" ><summary><span><a href="#cb$2836">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="eventNames$3208" title="Method" ><summary><span><a href="#eventNames$3208">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3197" title="Method" ><summary><span><a href="#getMaxListeners$3197">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$2872" title="Method" ><summary><span><a href="#isPaused$2872">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>     &ndash; The <code>readable.isPaused()</code> method returns the current operating state of the<code>Readable</code>. This is used primarily by the mechanism that underlies the<code>readable.pipe()</code> method. In most
typical cases, there will be no reason to
use this method directly.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278</a>  <ul>    <p>  <p>

```js
const readable = new stream.Readable()

readable.isPaused() // === false
readable.pause()
readable.isPaused() // === true
readable.resume()
readable.isPaused() // === false
```

</p>
    <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$3205" title="Method" ><summary><span><a href="#listenerCount$3205">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3207" title="Parameter" ><summary><span><a href="#eventName$3207">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3199" title="Method" ><summary><span><a href="#listeners$3199">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3201" title="Parameter" ><summary><span><a href="#eventName$3201">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3184" title="Method" ><summary><span><a href="#off$3184">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3186" title="Parameter" ><summary><span><a href="#eventName$3186">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3187" title="Function" ><summary><span><a href="#listener$3187">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3190" title="Parameter" ><summary><span><a href="#args$3190">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="on$2955" title="Method" ><summary><span><a href="#on$2955">#</a></span>  <code><strong>on</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439</a>  <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$2957" title="Parameter" ><summary><span><a href="#event$2957">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2958" title="Function" ><summary><span><a href="#listener$2958">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2962" title="Parameter" ><summary><span><a href="#event$2962">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2963" title="Function" ><summary><span><a href="#listener$2963">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2966" title="Parameter" ><summary><span><a href="#chunk$2966">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2968" title="Parameter" ><summary><span><a href="#event$2968">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2969" title="Function" ><summary><span><a href="#listener$2969">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2973" title="Parameter" ><summary><span><a href="#event$2973">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2974" title="Function" ><summary><span><a href="#listener$2974">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2977" title="Parameter" ><summary><span><a href="#err$2977">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2979" title="Parameter" ><summary><span><a href="#event$2979">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2980" title="Function" ><summary><span><a href="#listener$2980">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2984" title="Parameter" ><summary><span><a href="#event$2984">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2985" title="Function" ><summary><span><a href="#listener$2985">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2989" title="Parameter" ><summary><span><a href="#event$2989">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2990" title="Function" ><summary><span><a href="#listener$2990">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$2994" title="Parameter" ><summary><span><a href="#event$2994">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2995" title="Function" ><summary><span><a href="#listener$2995">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2998" title="Parameter" ><summary><span><a href="#args$2998">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="once$2999" title="Method" ><summary><span><a href="#once$2999">#</a></span>  <code><strong>once</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447</a>  <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$3001" title="Parameter" ><summary><span><a href="#event$3001">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$3002" title="Function" ><summary><span><a href="#listener$3002">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3006" title="Parameter" ><summary><span><a href="#event$3006">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$3007" title="Function" ><summary><span><a href="#listener$3007">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$3010" title="Parameter" ><summary><span><a href="#chunk$3010">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3012" title="Parameter" ><summary><span><a href="#event$3012">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$3013" title="Function" ><summary><span><a href="#listener$3013">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3017" title="Parameter" ><summary><span><a href="#event$3017">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$3018" title="Function" ><summary><span><a href="#listener$3018">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3021" title="Parameter" ><summary><span><a href="#err$3021">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3023" title="Parameter" ><summary><span><a href="#event$3023">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$3024" title="Function" ><summary><span><a href="#listener$3024">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3028" title="Parameter" ><summary><span><a href="#event$3028">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$3029" title="Function" ><summary><span><a href="#listener$3029">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3033" title="Parameter" ><summary><span><a href="#event$3033">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$3034" title="Function" ><summary><span><a href="#listener$3034">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3038" title="Parameter" ><summary><span><a href="#event$3038">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3039" title="Function" ><summary><span><a href="#listener$3039">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3042" title="Parameter" ><summary><span><a href="#args$3042">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="pause$2868" title="Method" ><summary><span><a href="#pause$2868">#</a></span>  <code><strong>pause</strong></code><em>()</em>     &ndash; The <code>readable.pause()</code> method will cause a stream in flowing mode to stop
emitting <code>'data'</code> events, switching out of flowing mode. Any data that
becomes available will remain in the internal buffer.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242</a>  <ul>    <p>  <p>

```js
const readable = getReadableStreamSomehow()
readable.on('data', chunk => {
  console.log(`Received ${chunk.length} bytes of data.`)
  readable.pause()
  console.log('There will be no additional data for 1 second.')
  setTimeout(() => {
    console.log('Now data will start flowing again.')
    readable.resume()
  }, 1000)
})
```

The `readable.pause()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="pipe$3177" title="Method" ><summary><span><a href="#pipe$3177">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$3180" title="Parameter" ><summary><span><a href="#destination$3180">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$3181" title="Parameter" ><summary><span><a href="#options$3181">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$3183" title="Property" ><summary><span><a href="#end$3183">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$3043" title="Method" ><summary><span><a href="#prependListener$3043">#</a></span>  <code><strong>prependListener</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455</a>  <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3045" title="Parameter" ><summary><span><a href="#event$3045">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$3046" title="Function" ><summary><span><a href="#listener$3046">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3050" title="Parameter" ><summary><span><a href="#event$3050">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$3051" title="Function" ><summary><span><a href="#listener$3051">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$3054" title="Parameter" ><summary><span><a href="#chunk$3054">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3056" title="Parameter" ><summary><span><a href="#event$3056">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$3057" title="Function" ><summary><span><a href="#listener$3057">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3061" title="Parameter" ><summary><span><a href="#event$3061">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$3062" title="Function" ><summary><span><a href="#listener$3062">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3065" title="Parameter" ><summary><span><a href="#err$3065">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3067" title="Parameter" ><summary><span><a href="#event$3067">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$3068" title="Function" ><summary><span><a href="#listener$3068">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3072" title="Parameter" ><summary><span><a href="#event$3072">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$3073" title="Function" ><summary><span><a href="#listener$3073">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3077" title="Parameter" ><summary><span><a href="#event$3077">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$3078" title="Function" ><summary><span><a href="#listener$3078">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3082" title="Parameter" ><summary><span><a href="#event$3082">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3083" title="Function" ><summary><span><a href="#listener$3083">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3086" title="Parameter" ><summary><span><a href="#args$3086">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="prependOnceListener$3087" title="Method" ><summary><span><a href="#prependOnceListener$3087">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463</a>  <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3089" title="Parameter" ><summary><span><a href="#event$3089">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$3090" title="Function" ><summary><span><a href="#listener$3090">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3094" title="Parameter" ><summary><span><a href="#event$3094">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$3095" title="Function" ><summary><span><a href="#listener$3095">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$3098" title="Parameter" ><summary><span><a href="#chunk$3098">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3100" title="Parameter" ><summary><span><a href="#event$3100">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$3101" title="Function" ><summary><span><a href="#listener$3101">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3105" title="Parameter" ><summary><span><a href="#event$3105">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$3106" title="Function" ><summary><span><a href="#listener$3106">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3109" title="Parameter" ><summary><span><a href="#err$3109">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3111" title="Parameter" ><summary><span><a href="#event$3111">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$3112" title="Function" ><summary><span><a href="#listener$3112">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3116" title="Parameter" ><summary><span><a href="#event$3116">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$3117" title="Function" ><summary><span><a href="#listener$3117">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3121" title="Parameter" ><summary><span><a href="#event$3121">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$3122" title="Function" ><summary><span><a href="#listener$3122">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3126" title="Parameter" ><summary><span><a href="#event$3126">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3127" title="Function" ><summary><span><a href="#listener$3127">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3130" title="Parameter" ><summary><span><a href="#args$3130">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="push$2884" title="Method" ><summary><span><a href="#push$2884">#</a></span>  <code><strong>push</strong></code><em>(chunk, encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398</a>  <ul>    <p>    <details id="chunk$2886" title="Parameter" ><summary><span><a href="#chunk$2886">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2887" title="Parameter" ><summary><span><a href="#encoding$2887">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>push</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="rawListeners$3202" title="Method" ><summary><span><a href="#rawListeners$3202">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3204" title="Parameter" ><summary><span><a href="#eventName$3204">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$2862" title="Method" ><summary><span><a href="#read$2862">#</a></span>  <code><strong>read</strong></code><em>(size)</em>     &ndash; The <code>readable.read()</code> method pulls some data out of the internal buffer and
returns it. If no data available to be read, <code>null</code> is returned. By default,
the data will be returned as a <code>Buffer</code> object unless an encoding has been
specified using the <code>readable.setEncoding()</code> method or the stream is operating
in object mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195</a>  <ul>    <p>  <p>

The optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which
case all of the data remaining in the internal
buffer will be returned.

If the `size` argument is not specified, all of the data contained in the
internal buffer will be returned.

The `size` argument must be less than or equal to 1 GiB.

The `readable.read()` method should only be called on `Readable` streams
operating in paused mode. In flowing mode, `readable.read()` is called
automatically until the internal buffer is fully drained.

```js
const readable = getReadableStreamSomehow()

// 'readable' may be triggered multiple times as data is buffered in
readable.on('readable', () => {
  let chunk
  console.log('Stream is readable (new data received in buffer)')
  // Use a loop to make sure we read all currently available data
  while (null !== (chunk = readable.read())) {
    console.log(`Read ${chunk.length} bytes of data...`)
  }
})

// 'end' will be triggered once when there is no more data available
readable.on('end', () => {
  console.log('Reached end of stream.')
})
```

Each call to `readable.read()` returns a chunk of data, or `null`. The chunks
are not concatenated. A `while` loop is necessary to consume all data
currently in the buffer. When reading a large file `.read()` may return `null`,
having consumed all buffered content so far, but there is still more data to
come not yet buffered. In this case a new `'readable'` event will be emitted
when there is more data in the buffer. Finally the `'end'` event will be
emitted when there is no more data to come.

Therefore to read a file's whole contents from a `readable`, it is necessary
to collect chunks across multiple `'readable'` events:

```js
const chunks = []

readable.on('readable', () => {
  let chunk
  while (null !== (chunk = readable.read())) {
    chunks.push(chunk)
  }
})

readable.on('end', () => {
  const content = chunks.join('')
})
```

A `Readable` stream in object mode will always return a single item from
a call to `readable.read(size)`, regardless of the value of the`size` argument.

If the `readable.read()` method returns a chunk of data, a `'data'` event will
also be emitted.

Calling {@link read} after the `'end'` event has
been emitted will return `null`. No runtime error will be raised.

</p>
  <details id="size$2864" title="Parameter" ><summary><span><a href="#size$2864">#</a></span>  <code><strong>size</strong></code>     &ndash; Optional argument to specify how much data to read.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>any</ul></p></p>    </ul></details><details id="removeAllListeners$3191" title="Method" ><summary><span><a href="#removeAllListeners$3191">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3193" title="Parameter" ><summary><span><a href="#event$3193">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="removeListener$3131" title="Method" ><summary><span><a href="#removeListener$3131">#</a></span>  <code><strong>removeListener</strong></code><em>(event, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471</a>  <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3133" title="Parameter" ><summary><span><a href="#event$3133">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$3134" title="Function" ><summary><span><a href="#listener$3134">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3138" title="Parameter" ><summary><span><a href="#event$3138">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$3139" title="Function" ><summary><span><a href="#listener$3139">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$3142" title="Parameter" ><summary><span><a href="#chunk$3142">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3144" title="Parameter" ><summary><span><a href="#event$3144">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$3145" title="Function" ><summary><span><a href="#listener$3145">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3149" title="Parameter" ><summary><span><a href="#event$3149">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$3150" title="Function" ><summary><span><a href="#listener$3150">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3153" title="Parameter" ><summary><span><a href="#err$3153">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3155" title="Parameter" ><summary><span><a href="#event$3155">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$3156" title="Function" ><summary><span><a href="#listener$3156">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3160" title="Parameter" ><summary><span><a href="#event$3160">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$3161" title="Function" ><summary><span><a href="#listener$3161">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3165" title="Parameter" ><summary><span><a href="#event$3165">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$3166" title="Function" ><summary><span><a href="#listener$3166">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p>  <details id="event$3170" title="Parameter" ><summary><span><a href="#event$3170">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3171" title="Function" ><summary><span><a href="#listener$3171">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3174" title="Parameter" ><summary><span><a href="#args$3174">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="resume$2870" title="Method" ><summary><span><a href="#resume$2870">#</a></span>  <code><strong>resume</strong></code><em>()</em>     &ndash; The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to
resume emitting <code>'data'</code> events, switching the stream into flowing mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261</a>  <ul>    <p>  <p>

The `readable.resume()` method can be used to fully consume the data from a
stream without actually processing any of that data:

```js
getReadableStreamSomehow()
  .resume()
  .on('end', () => {
    console.log('Reached the end, but did not read anything.')
  })
```

The `readable.resume()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="setDefaultEncoding$2820" title="Method" ><summary><span><a href="#setDefaultEncoding$2820">#</a></span>  <code><strong>setDefaultEncoding</strong></code><em>(encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855</a>  <ul>    <p>    <details id="encoding$2822" title="Parameter" ><summary><span><a href="#encoding$2822">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setDefaultEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="setEncoding$2865" title="Method" ><summary><span><a href="#setEncoding$2865">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>     &ndash; The <code>readable.setEncoding()</code> method sets the character encoding for
data read from the <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220</a>  <ul>    <p>  <p>

By default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data
to be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding('utf8')` will cause the
output data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal
string format.

The `Readable` stream will properly handle multi-byte characters delivered
through the stream that would otherwise become improperly decoded if simply
pulled from the stream as `Buffer` objects.

```js
const readable = getReadableStreamSomehow()
readable.setEncoding('utf8')
readable.on('data', chunk => {
  assert.equal(typeof chunk, 'string')
  console.log('Got %d characters of string data:', chunk.length)
})
```

</p>
  <details id="encoding$2867" title="Parameter" ><summary><span><a href="#encoding$2867">#</a></span>  <code><strong>encoding</strong></code>     &ndash; The encoding to use.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="setMaxListeners$3194" title="Method" ><summary><span><a href="#setMaxListeners$3194">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3196" title="Parameter" ><summary><span><a href="#n$3196">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="uncork$2841" title="Method" ><summary><span><a href="#uncork$2841">#</a></span>  <code><strong>uncork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860</a>  <ul>    <p>      <p><strong>uncork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="unpipe$2874" title="Method" ><summary><span><a href="#unpipe$2874">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>     &ndash; The <code>readable.unpipe()</code> method detaches a <code>Writable</code> stream previously attached
using the {@link pipe} method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305</a>  <ul>    <p>  <p>

If the `destination` is not specified, then _all_ pipes are detached.

If the `destination` is specified, but no pipe is set up for it, then
the method does nothing.

```js
const fs = require('fs')
const readable = getReadableStreamSomehow()
const writable = fs.createWriteStream('file.txt')
// All the data from readable goes into 'file.txt',
// but only for the first second.
readable.pipe(writable)
setTimeout(() => {
  console.log('Stop writing to file.txt.')
  readable.unpipe(writable)
  console.log('Manually close the file stream.')
  writable.end()
}, 1000)
```

</p>
  <details id="destination$2876" title="Parameter" ><summary><span><a href="#destination$2876">#</a></span>  <code><strong>destination</strong></code>     &ndash; Optional specific stream to unpipe
</summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="unshift$2877" title="Method" ><summary><span><a href="#unshift$2877">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>     &ndash; Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF) and behaves the
same as <code>readable.push(null)</code>, after which no more data can be written. The EOF
signal is put at the end of the buffer and any buffered data will still be
flushed.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371</a>  <ul>    <p>  <p>

The `readable.unshift()` method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.

The `stream.unshift(chunk)` method cannot be called after the `'end'` event
has been emitted or a runtime error will be thrown.

Developers using `stream.unshift()` often should consider switching to
use of a `Transform` stream instead. See the `API for stream implementers` section for more information.

```js
// Pull off a header delimited by \n\n.
// Use unshift() if we get too much.
// Call the callback with (error, header, stream).
const { StringDecoder } = require('string_decoder')
function parseHeader(stream, callback) {
  stream.on('error', callback)
  stream.on('readable', onReadable)
  const decoder = new StringDecoder('utf8')
  let header = ''
  function onReadable() {
    let chunk
    while (null !== (chunk = stream.read())) {
      const str = decoder.write(chunk)
      if (str.match(/\n\n/)) {
        // Found the header boundary.
        const split = str.split(/\n\n/)
        header += split.shift()
        const remaining = split.join('\n\n')
        const buf = Buffer.from(remaining, 'utf8')
        stream.removeListener('error', callback)
        // Remove the 'readable' listener before unshifting.
        stream.removeListener('readable', onReadable)
        if (buf.length)
          stream.unshift(buf)
        // Now the body of the message can be read from the stream.
        callback(null, header, stream)
      } else {
        // Still reading the header.
        header += str
      }
    }
  }
}
```

Unlike {@link push}, `stream.unshift(chunk)` will not
end the reading process by resetting the internal reading state of the stream.
This can cause unexpected results if `readable.unshift()` is called during a
read (i.e. from within a {@link _read} implementation on a
custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,
however it is best to simply avoid calling `readable.unshift()` while in the
process of performing a read.

</p>
  <details id="chunk$2879" title="Parameter" ><summary><span><a href="#chunk$2879">#</a></span>  <code><strong>chunk</strong></code>     &ndash; Chunk of data to unshift onto the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code>, <code>Uint8Array</code> or <code>null</code>. For object mode
streams, <code>chunk</code> may be any JavaScript value.</summary>    <ul><p>any</p>        </ul></details><details id="encoding$2880" title="Parameter" ><summary><span><a href="#encoding$2880">#</a></span>  <code><strong>encoding</strong></code>     &ndash; Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$2881" title="Method" ><summary><span><a href="#wrap$2881">#</a></span>  <code><strong>wrap</strong></code><em>(stream)</em>     &ndash; Prior to Node.js 0.10, streams did not implement the entire <code>stream</code> module API
as it is currently defined. (See <code>Compatibility</code> for more information.)</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397</a>  <ul>    <p>  <p>

When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`
stream that uses
the old stream as its data source.

It will rarely be necessary to use `readable.wrap()` but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.

```js
const { OldReader } = require('./old-api-module.js')
const { Readable } = require('stream')
const oreader = new OldReader()
const myReader = new Readable().wrap(oreader)

myReader.on('readable', () => {
  myReader.read() // etc.
})
```

</p>
  <details id="stream$2883" title="Parameter" ><summary><span><a href="#stream$2883">#</a></span>  <code><strong>stream</strong></code>     &ndash; An &quot;old style&quot; readable stream
</summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><a href="#PassThrough$2719">PassThrough</a></ul></p></p>    </ul></details><details id="write$2806" title="Method" ><summary><span><a href="#write$2806">#</a></span>  <code><strong>write</strong></code><em>(chunk, encoding, cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853</a>  <ul>    <p>    <details id="chunk$2808" title="Parameter" ><summary><span><a href="#chunk$2808">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2809" title="Parameter" ><summary><span><a href="#encoding$2809">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$2810" title="Function" ><summary><span><a href="#cb$2810">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2813" title="Parameter" ><summary><span><a href="#error$2813">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="chunk$2815" title="Parameter" ><summary><span><a href="#chunk$2815">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$2816" title="Function" ><summary><span><a href="#cb$2816">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2819" title="Parameter" ><summary><span><a href="#error$2819">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="from$2720" title="Method" ><summary><span><a href="#from$2720">#</a></span>  <code><strong>from</strong></code><em>(src)</em>     &ndash; A utility method for creating duplex streams.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842</a>  <ul>    <p>  <p>

- `Stream` converts writable stream into writable `Duplex` and readable stream
  to `Duplex`.
- `Blob` converts into readable `Duplex`.
- `string` converts into readable `Duplex`.
- `ArrayBuffer` converts into readable `Duplex`.
- `AsyncIterable` converts into a readable `Duplex`. Cannot yield `null`.
- `AsyncGeneratorFunction` converts into a readable/writable transform
  `Duplex`. Must take a source `AsyncIterable` as first parameter. Cannot yield
  `null`.
- `AsyncFunction` converts into a writable `Duplex`. Must return
  either `null` or `undefined`
- `Object ({ writable, readable })` converts `readable` and
  `writable` into `Stream` and then combines them into `Duplex` where the
  `Duplex` will write to the `writable` and read from the `readable`.
- `Promise` converts into readable `Duplex`. Value `null` is ignored.

</p>
  <details id="src$2722" title="Parameter" ><summary><span><a href="#src$2722">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p>string | <span>Object</span> | <a href="#Stream$119">Stream</a> | <span>ArrayBuffer</span> | <span>Promise</span>&lt;any&gt; | <span>Iterable</span>&lt;any&gt; | <span>AsyncIterable</span>&lt;any&gt; | <span>Blob</span> | <span>AsyncGeneratorFunction</span></p>        </ul></details>  <p><strong>from</strong><em>(src)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="getEventListeners$2744" title="Method" ><summary><span><a href="#getEventListeners$2744">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$2746" title="Parameter" ><summary><span><a href="#emitter$2746">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$2747" title="Parameter" ><summary><span><a href="#name$2747">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="isDisturbed$2723" title="Method" ><summary><span><a href="#isDisturbed$2723">#</a></span>  <code><strong>isDisturbed</strong></code><em>(stream)</em>     &ndash; Returns whether the stream has been read from or cancelled.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59</a>  <ul>    <p>    <details id="stream$2725" title="Parameter" ><summary><span><a href="#stream$2725">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>isDisturbed</strong><em>(stream)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$2740" title="Method" ><summary><span><a href="#listenerCount$2740">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$2742" title="Parameter" ><summary><span><a href="#emitter$2742">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$2743" title="Parameter" ><summary><span><a href="#eventName$2743">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$2735" title="Method" ><summary><span><a href="#on$2735">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$2737" title="Parameter" ><summary><span><a href="#emitter$2737">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$2738" title="Parameter" ><summary><span><a href="#eventName$2738">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$2739" title="Parameter" ><summary><span><a href="#options$2739">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$2726" title="Method" ><summary><span><a href="#once$2726">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$2728" title="Parameter" ><summary><span><a href="#emitter$2728">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$2729" title="Parameter" ><summary><span><a href="#eventName$2729">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$2730" title="Parameter" ><summary><span><a href="#options$2730">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$2732" title="Parameter" ><summary><span><a href="#emitter$2732">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$2733" title="Parameter" ><summary><span><a href="#eventName$2733">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$2734" title="Parameter" ><summary><span><a href="#options$2734">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$2748" title="Method" ><summary><span><a href="#setMaxListeners$2748">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$2750" title="Parameter" ><summary><span><a href="#n$2750">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$2751" title="Parameter" ><summary><span><a href="#eventTargets$2751">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="Readable$732" title="Class" ><summary><span><a href="#Readable$732">#</a></span>  <code><strong>Readable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L50">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L50</a>  <ul>        <p>  <details id="constructor$770" title="Constructor" ><summary><span><a href="#constructor$770">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L116">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L116</a>  <ul>    <p>  <details id="new Readable$771" title="ConstructorSignature" ><summary><span><a href="#new Readable$771">#</a></span>  <code><strong>new Readable</strong></code><em>()</em>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>      <p>  <details id="opts$772" title="Parameter" ><summary><span><a href="#opts$772">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#ReadableOptions$706">ReadableOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="destroyed$782" title="Property" ><summary><span><a href="#destroyed$782">#</a></span>  <code><strong>destroyed</strong></code>     &ndash; Is <code>true</code> after <code>readable.destroy()</code> has been called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115</a>  <ul><p>boolean</p>        </ul></details><details id="readable$774" title="Property" ><summary><span><a href="#readable$774">#</a></span>  <code><strong>readable</strong></code>     &ndash; Is <code>true</code> if it is safe to call <code>readable.read()</code>, which means
the stream has not been destroyed or emitted <code>'error'</code> or <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71</a>  <ul><p>boolean</p>        </ul></details><details id="readableAborted$773" title="Property" ><summary><span><a href="#readableAborted$773">#</a></span>  <code><strong>readableAborted</strong></code>     &ndash; Returns whether the stream was destroyed or errored before emitting <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65</a>  <ul><p>boolean</p>        </ul></details><details id="readableDidRead$775" title="Property" ><summary><span><a href="#readableDidRead$775">#</a></span>  <code><strong>readableDidRead</strong></code>     &ndash; Returns whether <code>'data'</code> has been emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77</a>  <ul><p>boolean</p>        </ul></details><details id="readableEncoding$776" title="Property" ><summary><span><a href="#readableEncoding$776">#</a></span>  <code><strong>readableEncoding</strong></code>     &ndash; Getter for the property <code>encoding</code> of a given <code>Readable</code> stream. The <code>encoding</code>property can be set using the <code>readable.setEncoding()</code> method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82</a>  <ul><p><code>null</code> | <a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="readableEnded$777" title="Property" ><summary><span><a href="#readableEnded$777">#</a></span>  <code><strong>readableEnded</strong></code>     &ndash; Becomes <code>true</code> when <code>'end'</code> event is emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87</a>  <ul><p>boolean</p>        </ul></details><details id="readableFlowing$778" title="Property" ><summary><span><a href="#readableFlowing$778">#</a></span>  <code><strong>readableFlowing</strong></code>     &ndash; This property reflects the current state of a <code>Readable</code> stream as described
in the <code>Three states</code> section.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93</a>  <ul><p><code>null</code> | boolean</p>        </ul></details><details id="readableHighWaterMark$779" title="Property" ><summary><span><a href="#readableHighWaterMark$779">#</a></span>  <code><strong>readableHighWaterMark</strong></code>     &ndash; Returns the value of <code>highWaterMark</code> passed when creating this <code>Readable</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98</a>  <ul><p>number</p>        </ul></details><details id="readableLength$780" title="Property" ><summary><span><a href="#readableLength$780">#</a></span>  <code><strong>readableLength</strong></code>     &ndash; This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding
the status of the <code>highWaterMark</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$781" title="Property" ><summary><span><a href="#readableObjectMode$781">#</a></span>  <code><strong>readableObjectMode</strong></code>     &ndash; Getter for the property <code>objectMode</code> of a given <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110</a>  <ul><p>boolean</p>        </ul></details><details id="captureRejectionSymbol$767" title="Property" ><summary><span><a href="#captureRejectionSymbol$767">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$768" title="Property" ><summary><span><a href="#captureRejections$768">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$769" title="Property" ><summary><span><a href="#defaultMaxListeners$769">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$766" title="Property" ><summary><span><a href="#errorMonitor$766">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="[asyncIterator]$1112" title="Method" ><summary><span><a href="#[asyncIterator]$1112">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479</a>  <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="_construct$783" title="Method" ><summary><span><a href="#_construct$783">#</a></span>  <code><strong>_construct</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117</a>  <ul>    <p>    <details id="callback$785" title="Function" ><summary><span><a href="#callback$785">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$788" title="Parameter" ><summary><span><a href="#error$788">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_construct</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_destroy$818" title="Method" ><summary><span><a href="#_destroy$818">#</a></span>  <code><strong>_destroy</strong></code><em>(error, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L399">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L399</a>  <ul>    <p>    <details id="error$820" title="Parameter" ><summary><span><a href="#error$820">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$821" title="Function" ><summary><span><a href="#callback$821">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$824" title="Parameter" ><summary><span><a href="#error$824">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_destroy</strong><em>(error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_read$789" title="Method" ><summary><span><a href="#_read$789">#</a></span>  <code><strong>_read</strong></code><em>(size)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118</a>  <ul>    <p>    <details id="size$791" title="Parameter" ><summary><span><a href="#size$791">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>_read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="addListener$828" title="Method" ><summary><span><a href="#addListener$828">#</a></span>  <code><strong>addListener</strong></code><em>(event, listener)</em>     &ndash; Event emitter
The defined events on documents including:
1. close
2. data
3. end
4. error
5. pause
6. readable
7. resume</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423</a>  <ul>    <p>    <details id="event$830" title="Parameter" ><summary><span><a href="#event$830">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$831" title="Function" ><summary><span><a href="#listener$831">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$835" title="Parameter" ><summary><span><a href="#event$835">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$836" title="Function" ><summary><span><a href="#listener$836">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$839" title="Parameter" ><summary><span><a href="#chunk$839">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$841" title="Parameter" ><summary><span><a href="#event$841">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$842" title="Function" ><summary><span><a href="#listener$842">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$846" title="Parameter" ><summary><span><a href="#event$846">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$847" title="Function" ><summary><span><a href="#listener$847">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$850" title="Parameter" ><summary><span><a href="#err$850">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$852" title="Parameter" ><summary><span><a href="#event$852">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$853" title="Function" ><summary><span><a href="#listener$853">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$857" title="Parameter" ><summary><span><a href="#event$857">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$858" title="Function" ><summary><span><a href="#listener$858">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$862" title="Parameter" ><summary><span><a href="#event$862">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$863" title="Function" ><summary><span><a href="#listener$863">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$867" title="Parameter" ><summary><span><a href="#event$867">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$868" title="Function" ><summary><span><a href="#listener$868">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$871" title="Parameter" ><summary><span><a href="#args$871">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="destroy$825" title="Method" ><summary><span><a href="#destroy$825">#</a></span>  <code><strong>destroy</strong></code><em>(error)</em>     &ndash; Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code>event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the readable
stream will release any internal resources and subsequent calls to <code>push()</code>will be ignored.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411</a>  <ul>    <p>  <p>

Once `destroy()` has been called any further calls will be a no-op and no
further errors except from `_destroy()` may be emitted as `'error'`.

Implementors should not override this method, but instead implement `readable._destroy()`.

</p>
  <details id="error$827" title="Parameter" ><summary><span><a href="#error$827">#</a></span>  <code><strong>error</strong></code>     &ndash; Error which will be passed as payload in <code>'error'</code> event
</summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>destroy</strong><em>(error)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="emit$872" title="Method" ><summary><span><a href="#emit$872">#</a></span>  <code><strong>emit</strong></code><em>(event)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431</a>  <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="event$874" title="Parameter" ><summary><span><a href="#event$874">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$876" title="Parameter" ><summary><span><a href="#event$876">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="chunk$877" title="Parameter" ><summary><span><a href="#chunk$877">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>emit</strong><em>(event, chunk)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$879" title="Parameter" ><summary><span><a href="#event$879">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$881" title="Parameter" ><summary><span><a href="#event$881">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="err$882" title="Parameter" ><summary><span><a href="#err$882">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>emit</strong><em>(event, err)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$884" title="Parameter" ><summary><span><a href="#event$884">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$886" title="Parameter" ><summary><span><a href="#event$886">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$888" title="Parameter" ><summary><span><a href="#event$888">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$890" title="Parameter" ><summary><span><a href="#event$890">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$891" title="Parameter" ><summary><span><a href="#args$891">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(event, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$1145" title="Method" ><summary><span><a href="#eventNames$1145">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$1134" title="Method" ><summary><span><a href="#getMaxListeners$1134">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$802" title="Method" ><summary><span><a href="#isPaused$802">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>     &ndash; The <code>readable.isPaused()</code> method returns the current operating state of the<code>Readable</code>. This is used primarily by the mechanism that underlies the<code>readable.pipe()</code> method. In most
typical cases, there will be no reason to
use this method directly.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278</a>  <ul>    <p>  <p>

```js
const readable = new stream.Readable()

readable.isPaused() // === false
readable.pause()
readable.isPaused() // === true
readable.resume()
readable.isPaused() // === false
```

</p>
    <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$1142" title="Method" ><summary><span><a href="#listenerCount$1142">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$1144" title="Parameter" ><summary><span><a href="#eventName$1144">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$1136" title="Method" ><summary><span><a href="#listeners$1136">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$1138" title="Parameter" ><summary><span><a href="#eventName$1138">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$1121" title="Method" ><summary><span><a href="#off$1121">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$1123" title="Parameter" ><summary><span><a href="#eventName$1123">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1124" title="Function" ><summary><span><a href="#listener$1124">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1127" title="Parameter" ><summary><span><a href="#args$1127">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="on$892" title="Method" ><summary><span><a href="#on$892">#</a></span>  <code><strong>on</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439</a>  <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$894" title="Parameter" ><summary><span><a href="#event$894">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$895" title="Function" ><summary><span><a href="#listener$895">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$899" title="Parameter" ><summary><span><a href="#event$899">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$900" title="Function" ><summary><span><a href="#listener$900">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$903" title="Parameter" ><summary><span><a href="#chunk$903">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$905" title="Parameter" ><summary><span><a href="#event$905">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$906" title="Function" ><summary><span><a href="#listener$906">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$910" title="Parameter" ><summary><span><a href="#event$910">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$911" title="Function" ><summary><span><a href="#listener$911">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$914" title="Parameter" ><summary><span><a href="#err$914">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$916" title="Parameter" ><summary><span><a href="#event$916">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$917" title="Function" ><summary><span><a href="#listener$917">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$921" title="Parameter" ><summary><span><a href="#event$921">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$922" title="Function" ><summary><span><a href="#listener$922">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$926" title="Parameter" ><summary><span><a href="#event$926">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$927" title="Function" ><summary><span><a href="#listener$927">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$931" title="Parameter" ><summary><span><a href="#event$931">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$932" title="Function" ><summary><span><a href="#listener$932">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$935" title="Parameter" ><summary><span><a href="#args$935">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="once$936" title="Method" ><summary><span><a href="#once$936">#</a></span>  <code><strong>once</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447</a>  <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$938" title="Parameter" ><summary><span><a href="#event$938">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$939" title="Function" ><summary><span><a href="#listener$939">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$943" title="Parameter" ><summary><span><a href="#event$943">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$944" title="Function" ><summary><span><a href="#listener$944">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$947" title="Parameter" ><summary><span><a href="#chunk$947">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$949" title="Parameter" ><summary><span><a href="#event$949">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$950" title="Function" ><summary><span><a href="#listener$950">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$954" title="Parameter" ><summary><span><a href="#event$954">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$955" title="Function" ><summary><span><a href="#listener$955">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$958" title="Parameter" ><summary><span><a href="#err$958">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$960" title="Parameter" ><summary><span><a href="#event$960">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$961" title="Function" ><summary><span><a href="#listener$961">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$965" title="Parameter" ><summary><span><a href="#event$965">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$966" title="Function" ><summary><span><a href="#listener$966">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$970" title="Parameter" ><summary><span><a href="#event$970">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$971" title="Function" ><summary><span><a href="#listener$971">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$975" title="Parameter" ><summary><span><a href="#event$975">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$976" title="Function" ><summary><span><a href="#listener$976">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$979" title="Parameter" ><summary><span><a href="#args$979">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="pause$798" title="Method" ><summary><span><a href="#pause$798">#</a></span>  <code><strong>pause</strong></code><em>()</em>     &ndash; The <code>readable.pause()</code> method will cause a stream in flowing mode to stop
emitting <code>'data'</code> events, switching out of flowing mode. Any data that
becomes available will remain in the internal buffer.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242</a>  <ul>    <p>  <p>

```js
const readable = getReadableStreamSomehow()
readable.on('data', chunk => {
  console.log(`Received ${chunk.length} bytes of data.`)
  readable.pause()
  console.log('There will be no additional data for 1 second.')
  setTimeout(() => {
    console.log('Now data will start flowing again.')
    readable.resume()
  }, 1000)
})
```

The `readable.pause()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="pipe$1114" title="Method" ><summary><span><a href="#pipe$1114">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$1117" title="Parameter" ><summary><span><a href="#destination$1117">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$1118" title="Parameter" ><summary><span><a href="#options$1118">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$1120" title="Property" ><summary><span><a href="#end$1120">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$980" title="Method" ><summary><span><a href="#prependListener$980">#</a></span>  <code><strong>prependListener</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455</a>  <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$982" title="Parameter" ><summary><span><a href="#event$982">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$983" title="Function" ><summary><span><a href="#listener$983">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$987" title="Parameter" ><summary><span><a href="#event$987">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$988" title="Function" ><summary><span><a href="#listener$988">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$991" title="Parameter" ><summary><span><a href="#chunk$991">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$993" title="Parameter" ><summary><span><a href="#event$993">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$994" title="Function" ><summary><span><a href="#listener$994">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$998" title="Parameter" ><summary><span><a href="#event$998">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$999" title="Function" ><summary><span><a href="#listener$999">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1002" title="Parameter" ><summary><span><a href="#err$1002">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1004" title="Parameter" ><summary><span><a href="#event$1004">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1005" title="Function" ><summary><span><a href="#listener$1005">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1009" title="Parameter" ><summary><span><a href="#event$1009">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1010" title="Function" ><summary><span><a href="#listener$1010">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1014" title="Parameter" ><summary><span><a href="#event$1014">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1015" title="Function" ><summary><span><a href="#listener$1015">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1019" title="Parameter" ><summary><span><a href="#event$1019">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1020" title="Function" ><summary><span><a href="#listener$1020">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1023" title="Parameter" ><summary><span><a href="#args$1023">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="prependOnceListener$1024" title="Method" ><summary><span><a href="#prependOnceListener$1024">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463</a>  <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1026" title="Parameter" ><summary><span><a href="#event$1026">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1027" title="Function" ><summary><span><a href="#listener$1027">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1031" title="Parameter" ><summary><span><a href="#event$1031">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1032" title="Function" ><summary><span><a href="#listener$1032">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1035" title="Parameter" ><summary><span><a href="#chunk$1035">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1037" title="Parameter" ><summary><span><a href="#event$1037">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1038" title="Function" ><summary><span><a href="#listener$1038">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1042" title="Parameter" ><summary><span><a href="#event$1042">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1043" title="Function" ><summary><span><a href="#listener$1043">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1046" title="Parameter" ><summary><span><a href="#err$1046">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1048" title="Parameter" ><summary><span><a href="#event$1048">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1049" title="Function" ><summary><span><a href="#listener$1049">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1053" title="Parameter" ><summary><span><a href="#event$1053">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1054" title="Function" ><summary><span><a href="#listener$1054">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1058" title="Parameter" ><summary><span><a href="#event$1058">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1059" title="Function" ><summary><span><a href="#listener$1059">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1063" title="Parameter" ><summary><span><a href="#event$1063">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1064" title="Function" ><summary><span><a href="#listener$1064">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1067" title="Parameter" ><summary><span><a href="#args$1067">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="push$814" title="Method" ><summary><span><a href="#push$814">#</a></span>  <code><strong>push</strong></code><em>(chunk, encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398</a>  <ul>    <p>    <details id="chunk$816" title="Parameter" ><summary><span><a href="#chunk$816">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$817" title="Parameter" ><summary><span><a href="#encoding$817">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>push</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="rawListeners$1139" title="Method" ><summary><span><a href="#rawListeners$1139">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$1141" title="Parameter" ><summary><span><a href="#eventName$1141">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$792" title="Method" ><summary><span><a href="#read$792">#</a></span>  <code><strong>read</strong></code><em>(size)</em>     &ndash; The <code>readable.read()</code> method pulls some data out of the internal buffer and
returns it. If no data available to be read, <code>null</code> is returned. By default,
the data will be returned as a <code>Buffer</code> object unless an encoding has been
specified using the <code>readable.setEncoding()</code> method or the stream is operating
in object mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195</a>  <ul>    <p>  <p>

The optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which
case all of the data remaining in the internal
buffer will be returned.

If the `size` argument is not specified, all of the data contained in the
internal buffer will be returned.

The `size` argument must be less than or equal to 1 GiB.

The `readable.read()` method should only be called on `Readable` streams
operating in paused mode. In flowing mode, `readable.read()` is called
automatically until the internal buffer is fully drained.

```js
const readable = getReadableStreamSomehow()

// 'readable' may be triggered multiple times as data is buffered in
readable.on('readable', () => {
  let chunk
  console.log('Stream is readable (new data received in buffer)')
  // Use a loop to make sure we read all currently available data
  while (null !== (chunk = readable.read())) {
    console.log(`Read ${chunk.length} bytes of data...`)
  }
})

// 'end' will be triggered once when there is no more data available
readable.on('end', () => {
  console.log('Reached end of stream.')
})
```

Each call to `readable.read()` returns a chunk of data, or `null`. The chunks
are not concatenated. A `while` loop is necessary to consume all data
currently in the buffer. When reading a large file `.read()` may return `null`,
having consumed all buffered content so far, but there is still more data to
come not yet buffered. In this case a new `'readable'` event will be emitted
when there is more data in the buffer. Finally the `'end'` event will be
emitted when there is no more data to come.

Therefore to read a file's whole contents from a `readable`, it is necessary
to collect chunks across multiple `'readable'` events:

```js
const chunks = []

readable.on('readable', () => {
  let chunk
  while (null !== (chunk = readable.read())) {
    chunks.push(chunk)
  }
})

readable.on('end', () => {
  const content = chunks.join('')
})
```

A `Readable` stream in object mode will always return a single item from
a call to `readable.read(size)`, regardless of the value of the`size` argument.

If the `readable.read()` method returns a chunk of data, a `'data'` event will
also be emitted.

Calling {@link read} after the `'end'` event has
been emitted will return `null`. No runtime error will be raised.

</p>
  <details id="size$794" title="Parameter" ><summary><span><a href="#size$794">#</a></span>  <code><strong>size</strong></code>     &ndash; Optional argument to specify how much data to read.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>any</ul></p></p>    </ul></details><details id="removeAllListeners$1128" title="Method" ><summary><span><a href="#removeAllListeners$1128">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1130" title="Parameter" ><summary><span><a href="#event$1130">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="removeListener$1068" title="Method" ><summary><span><a href="#removeListener$1068">#</a></span>  <code><strong>removeListener</strong></code><em>(event, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471</a>  <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1070" title="Parameter" ><summary><span><a href="#event$1070">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1071" title="Function" ><summary><span><a href="#listener$1071">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1075" title="Parameter" ><summary><span><a href="#event$1075">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$1076" title="Function" ><summary><span><a href="#listener$1076">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$1079" title="Parameter" ><summary><span><a href="#chunk$1079">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1081" title="Parameter" ><summary><span><a href="#event$1081">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$1082" title="Function" ><summary><span><a href="#listener$1082">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1086" title="Parameter" ><summary><span><a href="#event$1086">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1087" title="Function" ><summary><span><a href="#listener$1087">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1090" title="Parameter" ><summary><span><a href="#err$1090">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1092" title="Parameter" ><summary><span><a href="#event$1092">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$1093" title="Function" ><summary><span><a href="#listener$1093">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1097" title="Parameter" ><summary><span><a href="#event$1097">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$1098" title="Function" ><summary><span><a href="#listener$1098">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1102" title="Parameter" ><summary><span><a href="#event$1102">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$1103" title="Function" ><summary><span><a href="#listener$1103">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p>  <details id="event$1107" title="Parameter" ><summary><span><a href="#event$1107">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1108" title="Function" ><summary><span><a href="#listener$1108">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1111" title="Parameter" ><summary><span><a href="#args$1111">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="resume$800" title="Method" ><summary><span><a href="#resume$800">#</a></span>  <code><strong>resume</strong></code><em>()</em>     &ndash; The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to
resume emitting <code>'data'</code> events, switching the stream into flowing mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261</a>  <ul>    <p>  <p>

The `readable.resume()` method can be used to fully consume the data from a
stream without actually processing any of that data:

```js
getReadableStreamSomehow()
  .resume()
  .on('end', () => {
    console.log('Reached the end, but did not read anything.')
  })
```

The `readable.resume()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="setEncoding$795" title="Method" ><summary><span><a href="#setEncoding$795">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>     &ndash; The <code>readable.setEncoding()</code> method sets the character encoding for
data read from the <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220</a>  <ul>    <p>  <p>

By default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data
to be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding('utf8')` will cause the
output data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal
string format.

The `Readable` stream will properly handle multi-byte characters delivered
through the stream that would otherwise become improperly decoded if simply
pulled from the stream as `Buffer` objects.

```js
const readable = getReadableStreamSomehow()
readable.setEncoding('utf8')
readable.on('data', chunk => {
  assert.equal(typeof chunk, 'string')
  console.log('Got %d characters of string data:', chunk.length)
})
```

</p>
  <details id="encoding$797" title="Parameter" ><summary><span><a href="#encoding$797">#</a></span>  <code><strong>encoding</strong></code>     &ndash; The encoding to use.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="setMaxListeners$1131" title="Method" ><summary><span><a href="#setMaxListeners$1131">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$1133" title="Parameter" ><summary><span><a href="#n$1133">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="unpipe$804" title="Method" ><summary><span><a href="#unpipe$804">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>     &ndash; The <code>readable.unpipe()</code> method detaches a <code>Writable</code> stream previously attached
using the {@link pipe} method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305</a>  <ul>    <p>  <p>

If the `destination` is not specified, then _all_ pipes are detached.

If the `destination` is specified, but no pipe is set up for it, then
the method does nothing.

```js
const fs = require('fs')
const readable = getReadableStreamSomehow()
const writable = fs.createWriteStream('file.txt')
// All the data from readable goes into 'file.txt',
// but only for the first second.
readable.pipe(writable)
setTimeout(() => {
  console.log('Stop writing to file.txt.')
  readable.unpipe(writable)
  console.log('Manually close the file stream.')
  writable.end()
}, 1000)
```

</p>
  <details id="destination$806" title="Parameter" ><summary><span><a href="#destination$806">#</a></span>  <code><strong>destination</strong></code>     &ndash; Optional specific stream to unpipe
</summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="unshift$807" title="Method" ><summary><span><a href="#unshift$807">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>     &ndash; Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF) and behaves the
same as <code>readable.push(null)</code>, after which no more data can be written. The EOF
signal is put at the end of the buffer and any buffered data will still be
flushed.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371</a>  <ul>    <p>  <p>

The `readable.unshift()` method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.

The `stream.unshift(chunk)` method cannot be called after the `'end'` event
has been emitted or a runtime error will be thrown.

Developers using `stream.unshift()` often should consider switching to
use of a `Transform` stream instead. See the `API for stream implementers` section for more information.

```js
// Pull off a header delimited by \n\n.
// Use unshift() if we get too much.
// Call the callback with (error, header, stream).
const { StringDecoder } = require('string_decoder')
function parseHeader(stream, callback) {
  stream.on('error', callback)
  stream.on('readable', onReadable)
  const decoder = new StringDecoder('utf8')
  let header = ''
  function onReadable() {
    let chunk
    while (null !== (chunk = stream.read())) {
      const str = decoder.write(chunk)
      if (str.match(/\n\n/)) {
        // Found the header boundary.
        const split = str.split(/\n\n/)
        header += split.shift()
        const remaining = split.join('\n\n')
        const buf = Buffer.from(remaining, 'utf8')
        stream.removeListener('error', callback)
        // Remove the 'readable' listener before unshifting.
        stream.removeListener('readable', onReadable)
        if (buf.length)
          stream.unshift(buf)
        // Now the body of the message can be read from the stream.
        callback(null, header, stream)
      } else {
        // Still reading the header.
        header += str
      }
    }
  }
}
```

Unlike {@link push}, `stream.unshift(chunk)` will not
end the reading process by resetting the internal reading state of the stream.
This can cause unexpected results if `readable.unshift()` is called during a
read (i.e. from within a {@link _read} implementation on a
custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,
however it is best to simply avoid calling `readable.unshift()` while in the
process of performing a read.

</p>
  <details id="chunk$809" title="Parameter" ><summary><span><a href="#chunk$809">#</a></span>  <code><strong>chunk</strong></code>     &ndash; Chunk of data to unshift onto the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code>, <code>Uint8Array</code> or <code>null</code>. For object mode
streams, <code>chunk</code> may be any JavaScript value.</summary>    <ul><p>any</p>        </ul></details><details id="encoding$810" title="Parameter" ><summary><span><a href="#encoding$810">#</a></span>  <code><strong>encoding</strong></code>     &ndash; Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$811" title="Method" ><summary><span><a href="#wrap$811">#</a></span>  <code><strong>wrap</strong></code><em>(stream)</em>     &ndash; Prior to Node.js 0.10, streams did not implement the entire <code>stream</code> module API
as it is currently defined. (See <code>Compatibility</code> for more information.)</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397</a>  <ul>    <p>  <p>

When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`
stream that uses
the old stream as its data source.

It will rarely be necessary to use `readable.wrap()` but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.

```js
const { OldReader } = require('./old-api-module.js')
const { Readable } = require('stream')
const oreader = new OldReader()
const myReader = new Readable().wrap(oreader)

myReader.on('readable', () => {
  myReader.read() // etc.
})
```

</p>
  <details id="stream$813" title="Parameter" ><summary><span><a href="#stream$813">#</a></span>  <code><strong>stream</strong></code>     &ndash; An &quot;old style&quot; readable stream
</summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="from$733" title="Method" ><summary><span><a href="#from$733">#</a></span>  <code><strong>from</strong></code><em>(iterable, options)</em>     &ndash; A utility method for creating Readable Streams out of iterators.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L54">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L54</a>  <ul>    <p>    <details id="iterable$735" title="Parameter" ><summary><span><a href="#iterable$735">#</a></span>  <code><strong>iterable</strong></code>    </summary>    <ul><p><span>Iterable</span>&lt;any&gt; | <span>AsyncIterable</span>&lt;any&gt;</p>        </ul></details><details id="options$736" title="Parameter" ><summary><span><a href="#options$736">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#ReadableOptions$706">ReadableOptions</a></p>        </ul></details>  <p><strong>from</strong><em>(iterable, options)</em>  &nbsp;=&gt;  <ul><a href="#Readable$732">Readable</a></ul></p></p>    </ul></details><details id="getEventListeners$758" title="Method" ><summary><span><a href="#getEventListeners$758">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$760" title="Parameter" ><summary><span><a href="#emitter$760">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$761" title="Parameter" ><summary><span><a href="#name$761">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="isDisturbed$737" title="Method" ><summary><span><a href="#isDisturbed$737">#</a></span>  <code><strong>isDisturbed</strong></code><em>(stream)</em>     &ndash; Returns whether the stream has been read from or cancelled.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59</a>  <ul>    <p>    <details id="stream$739" title="Parameter" ><summary><span><a href="#stream$739">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>isDisturbed</strong><em>(stream)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$754" title="Method" ><summary><span><a href="#listenerCount$754">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$756" title="Parameter" ><summary><span><a href="#emitter$756">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$757" title="Parameter" ><summary><span><a href="#eventName$757">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$749" title="Method" ><summary><span><a href="#on$749">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$751" title="Parameter" ><summary><span><a href="#emitter$751">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$752" title="Parameter" ><summary><span><a href="#eventName$752">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$753" title="Parameter" ><summary><span><a href="#options$753">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$740" title="Method" ><summary><span><a href="#once$740">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$742" title="Parameter" ><summary><span><a href="#emitter$742">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$743" title="Parameter" ><summary><span><a href="#eventName$743">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$744" title="Parameter" ><summary><span><a href="#options$744">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$746" title="Parameter" ><summary><span><a href="#emitter$746">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$747" title="Parameter" ><summary><span><a href="#eventName$747">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$748" title="Parameter" ><summary><span><a href="#options$748">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$762" title="Method" ><summary><span><a href="#setMaxListeners$762">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$764" title="Parameter" ><summary><span><a href="#n$764">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$765" title="Parameter" ><summary><span><a href="#eventTargets$765">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="Stream$571" title="Class" ><summary><span><a href="#Stream$571">#</a></span>  <code><strong>Stream</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L32">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L32</a>  <ul>        <p>  <details id="constructor$602" title="Constructor" ><summary><span><a href="#constructor$602">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L33">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L33</a>  <ul>    <p>  <details id="new Stream$603" title="ConstructorSignature" ><summary><span><a href="#new Stream$603">#</a></span>  <code><strong>new Stream</strong></code><em>()</em>    </summary>    <ul><p><a href="#Stream$119">Stream</a></p>      <p>  <details id="opts$604" title="Parameter" ><summary><span><a href="#opts$604">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#ReadableOptions$706">ReadableOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="captureRejectionSymbol$599" title="Property" ><summary><span><a href="#captureRejectionSymbol$599">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$600" title="Property" ><summary><span><a href="#captureRejections$600">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$601" title="Property" ><summary><span><a href="#defaultMaxListeners$601">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$598" title="Property" ><summary><span><a href="#errorMonitor$598">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="addListener$612" title="Method" ><summary><span><a href="#addListener$612">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$614" title="Parameter" ><summary><span><a href="#eventName$614">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$615" title="Function" ><summary><span><a href="#listener$615">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$618" title="Parameter" ><summary><span><a href="#args$618">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="emit$661" title="Method" ><summary><span><a href="#emit$661">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$663" title="Parameter" ><summary><span><a href="#eventName$663">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$664" title="Parameter" ><summary><span><a href="#args$664">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$682" title="Method" ><summary><span><a href="#eventNames$682">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$653" title="Method" ><summary><span><a href="#getMaxListeners$653">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$665" title="Method" ><summary><span><a href="#listenerCount$665">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$667" title="Parameter" ><summary><span><a href="#eventName$667">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$655" title="Method" ><summary><span><a href="#listeners$655">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$657" title="Parameter" ><summary><span><a href="#eventName$657">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$640" title="Method" ><summary><span><a href="#off$640">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$642" title="Parameter" ><summary><span><a href="#eventName$642">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$643" title="Function" ><summary><span><a href="#listener$643">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$646" title="Parameter" ><summary><span><a href="#args$646">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="on$619" title="Method" ><summary><span><a href="#on$619">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$621" title="Parameter" ><summary><span><a href="#eventName$621">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$622" title="Function" ><summary><span><a href="#listener$622">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$625" title="Parameter" ><summary><span><a href="#args$625">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="once$626" title="Method" ><summary><span><a href="#once$626">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$628" title="Parameter" ><summary><span><a href="#eventName$628">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$629" title="Function" ><summary><span><a href="#listener$629">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$632" title="Parameter" ><summary><span><a href="#args$632">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="pipe$605" title="Method" ><summary><span><a href="#pipe$605">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$608" title="Parameter" ><summary><span><a href="#destination$608">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$609" title="Parameter" ><summary><span><a href="#options$609">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$611" title="Property" ><summary><span><a href="#end$611">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$668" title="Method" ><summary><span><a href="#prependListener$668">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$670" title="Parameter" ><summary><span><a href="#eventName$670">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$671" title="Function" ><summary><span><a href="#listener$671">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$674" title="Parameter" ><summary><span><a href="#args$674">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="prependOnceListener$675" title="Method" ><summary><span><a href="#prependOnceListener$675">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$677" title="Parameter" ><summary><span><a href="#eventName$677">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$678" title="Function" ><summary><span><a href="#listener$678">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$681" title="Parameter" ><summary><span><a href="#args$681">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="rawListeners$658" title="Method" ><summary><span><a href="#rawListeners$658">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$660" title="Parameter" ><summary><span><a href="#eventName$660">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$647" title="Method" ><summary><span><a href="#removeAllListeners$647">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$649" title="Parameter" ><summary><span><a href="#event$649">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="removeListener$633" title="Method" ><summary><span><a href="#removeListener$633">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$635" title="Parameter" ><summary><span><a href="#eventName$635">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$636" title="Function" ><summary><span><a href="#listener$636">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$639" title="Parameter" ><summary><span><a href="#args$639">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="setMaxListeners$650" title="Method" ><summary><span><a href="#setMaxListeners$650">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$652" title="Parameter" ><summary><span><a href="#n$652">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="getEventListeners$590" title="Method" ><summary><span><a href="#getEventListeners$590">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$592" title="Parameter" ><summary><span><a href="#emitter$592">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$593" title="Parameter" ><summary><span><a href="#name$593">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$586" title="Method" ><summary><span><a href="#listenerCount$586">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$588" title="Parameter" ><summary><span><a href="#emitter$588">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$589" title="Parameter" ><summary><span><a href="#eventName$589">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$581" title="Method" ><summary><span><a href="#on$581">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$583" title="Parameter" ><summary><span><a href="#emitter$583">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$584" title="Parameter" ><summary><span><a href="#eventName$584">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$585" title="Parameter" ><summary><span><a href="#options$585">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$572" title="Method" ><summary><span><a href="#once$572">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$574" title="Parameter" ><summary><span><a href="#emitter$574">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$575" title="Parameter" ><summary><span><a href="#eventName$575">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$576" title="Parameter" ><summary><span><a href="#options$576">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$578" title="Parameter" ><summary><span><a href="#emitter$578">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$579" title="Parameter" ><summary><span><a href="#eventName$579">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$580" title="Parameter" ><summary><span><a href="#options$580">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$594" title="Method" ><summary><span><a href="#setMaxListeners$594">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$596" title="Parameter" ><summary><span><a href="#n$596">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$597" title="Parameter" ><summary><span><a href="#eventTargets$597">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="Transform$2228" title="Class" ><summary><span><a href="#Transform$2228">#</a></span>  <code><strong>Transform</strong></code>     &ndash; Transform streams are <code>Duplex</code> streams where the output is in some way
related to the input. Like all <code>Duplex</code> streams, <code>Transform</code> streams
implement both the <code>Readable</code> and <code>Writable</code> interfaces.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L891">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L891</a>  <ul>  <p>

Examples of `Transform` streams include:

- `zlib streams`
- `crypto streams`

</p>
      <p>  <details id="constructor$2265" title="Constructor" ><summary><span><a href="#constructor$2265">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L892">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L892</a>  <ul>    <p>  <details id="new Transform$2266" title="ConstructorSignature" ><summary><span><a href="#new Transform$2266">#</a></span>  <code><strong>new Transform</strong></code><em>()</em>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>      <p>  <details id="opts$2267" title="Parameter" ><summary><span><a href="#opts$2267">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#TransformOptions$2157">TransformOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="allowHalfOpen$2283" title="Property" ><summary><span><a href="#allowHalfOpen$2283">#</a></span>  <code><strong>allowHalfOpen</strong></code>     &ndash; If <code>false</code> then the stream will automatically end the writable side when the
readable side ends. Set initially by the <code>allowHalfOpen</code> constructor option,
which defaults to <code>false</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L819</a>  <ul><p>boolean</p>  <p>

This can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is
emitted.

</p>
      </ul></details><details id="destroyed$2361" title="Property" ><summary><span><a href="#destroyed$2361">#</a></span>  <code><strong>destroyed</strong></code>     &ndash; Is <code>true</code> after <code>readable.destroy()</code> has been called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L115</a>  <ul><p>boolean</p>        </ul></details><details id="readable$2353" title="Property" ><summary><span><a href="#readable$2353">#</a></span>  <code><strong>readable</strong></code>     &ndash; Is <code>true</code> if it is safe to call <code>readable.read()</code>, which means
the stream has not been destroyed or emitted <code>'error'</code> or <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L71</a>  <ul><p>boolean</p>        </ul></details><details id="readableAborted$2352" title="Property" ><summary><span><a href="#readableAborted$2352">#</a></span>  <code><strong>readableAborted</strong></code>     &ndash; Returns whether the stream was destroyed or errored before emitting <code>'end'</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L65</a>  <ul><p>boolean</p>        </ul></details><details id="readableDidRead$2354" title="Property" ><summary><span><a href="#readableDidRead$2354">#</a></span>  <code><strong>readableDidRead</strong></code>     &ndash; Returns whether <code>'data'</code> has been emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L77</a>  <ul><p>boolean</p>        </ul></details><details id="readableEncoding$2355" title="Property" ><summary><span><a href="#readableEncoding$2355">#</a></span>  <code><strong>readableEncoding</strong></code>     &ndash; Getter for the property <code>encoding</code> of a given <code>Readable</code> stream. The <code>encoding</code>property can be set using the <code>readable.setEncoding()</code> method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L82</a>  <ul><p><code>null</code> | <a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="readableEnded$2356" title="Property" ><summary><span><a href="#readableEnded$2356">#</a></span>  <code><strong>readableEnded</strong></code>     &ndash; Becomes <code>true</code> when <code>'end'</code> event is emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L87</a>  <ul><p>boolean</p>        </ul></details><details id="readableFlowing$2357" title="Property" ><summary><span><a href="#readableFlowing$2357">#</a></span>  <code><strong>readableFlowing</strong></code>     &ndash; This property reflects the current state of a <code>Readable</code> stream as described
in the <code>Three states</code> section.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L93</a>  <ul><p><code>null</code> | boolean</p>        </ul></details><details id="readableHighWaterMark$2358" title="Property" ><summary><span><a href="#readableHighWaterMark$2358">#</a></span>  <code><strong>readableHighWaterMark</strong></code>     &ndash; Returns the value of <code>highWaterMark</code> passed when creating this <code>Readable</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L98</a>  <ul><p>number</p>        </ul></details><details id="readableLength$2359" title="Property" ><summary><span><a href="#readableLength$2359">#</a></span>  <code><strong>readableLength</strong></code>     &ndash; This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding
the status of the <code>highWaterMark</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L105</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$2360" title="Property" ><summary><span><a href="#readableObjectMode$2360">#</a></span>  <code><strong>readableObjectMode</strong></code>     &ndash; Getter for the property <code>objectMode</code> of a given <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L110</a>  <ul><p>boolean</p>        </ul></details><details id="writable$2276" title="Property" ><summary><span><a href="#writable$2276">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L803</a>  <ul><p>boolean</p>        </ul></details><details id="writableCorked$2282" title="Property" ><summary><span><a href="#writableCorked$2282">#</a></span>  <code><strong>writableCorked</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L809</a>  <ul><p>number</p>        </ul></details><details id="writableEnded$2277" title="Property" ><summary><span><a href="#writableEnded$2277">#</a></span>  <code><strong>writableEnded</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L804</a>  <ul><p>boolean</p>        </ul></details><details id="writableFinished$2278" title="Property" ><summary><span><a href="#writableFinished$2278">#</a></span>  <code><strong>writableFinished</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L805</a>  <ul><p>boolean</p>        </ul></details><details id="writableHighWaterMark$2279" title="Property" ><summary><span><a href="#writableHighWaterMark$2279">#</a></span>  <code><strong>writableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L806</a>  <ul><p>number</p>        </ul></details><details id="writableLength$2280" title="Property" ><summary><span><a href="#writableLength$2280">#</a></span>  <code><strong>writableLength</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L807</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$2281" title="Property" ><summary><span><a href="#writableObjectMode$2281">#</a></span>  <code><strong>writableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L808</a>  <ul><p>boolean</p>        </ul></details><details id="captureRejectionSymbol$2262" title="Property" ><summary><span><a href="#captureRejectionSymbol$2262">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$2263" title="Property" ><summary><span><a href="#captureRejections$2263">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$2264" title="Property" ><summary><span><a href="#defaultMaxListeners$2264">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$2261" title="Property" ><summary><span><a href="#errorMonitor$2261">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="[asyncIterator]$2684" title="Method" ><summary><span><a href="#[asyncIterator]$2684">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L479</a>  <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="_construct$2362" title="Method" ><summary><span><a href="#_construct$2362">#</a></span>  <code><strong>_construct</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L117</a>  <ul>    <p>    <details id="callback$2364" title="Function" ><summary><span><a href="#callback$2364">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2367" title="Parameter" ><summary><span><a href="#error$2367">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_construct</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_destroy$2302" title="Method" ><summary><span><a href="#_destroy$2302">#</a></span>  <code><strong>_destroy</strong></code><em>(error, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L851</a>  <ul>    <p>    <details id="error$2304" title="Parameter" ><summary><span><a href="#error$2304">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$2305" title="Function" ><summary><span><a href="#callback$2305">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2308" title="Parameter" ><summary><span><a href="#error$2308">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_destroy</strong><em>(error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_final$2309" title="Method" ><summary><span><a href="#_final$2309">#</a></span>  <code><strong>_final</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L852</a>  <ul>    <p>    <details id="callback$2311" title="Function" ><summary><span><a href="#callback$2311">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2314" title="Parameter" ><summary><span><a href="#error$2314">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_final</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_flush$2273" title="Method" ><summary><span><a href="#_flush$2273">#</a></span>  <code><strong>_flush</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L894">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L894</a>  <ul>    <p>    <details id="callback$2275" title="Parameter" ><summary><span><a href="#callback$2275">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>_flush</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_read$2368" title="Method" ><summary><span><a href="#_read$2368">#</a></span>  <code><strong>_read</strong></code><em>(size)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L118</a>  <ul>    <p>    <details id="size$2370" title="Parameter" ><summary><span><a href="#size$2370">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>_read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_transform$2268" title="Method" ><summary><span><a href="#_transform$2268">#</a></span>  <code><strong>_transform</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L893">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L893</a>  <ul>    <p>    <details id="chunk$2270" title="Parameter" ><summary><span><a href="#chunk$2270">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2271" title="Parameter" ><summary><span><a href="#encoding$2271">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2272" title="Parameter" ><summary><span><a href="#callback$2272">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>_transform</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_write$2284" title="Method" ><summary><span><a href="#_write$2284">#</a></span>  <code><strong>_write</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L843</a>  <ul>    <p>    <details id="chunk$2286" title="Parameter" ><summary><span><a href="#chunk$2286">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2287" title="Parameter" ><summary><span><a href="#encoding$2287">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2288" title="Function" ><summary><span><a href="#callback$2288">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2291" title="Parameter" ><summary><span><a href="#error$2291">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_write</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_writev$2292" title="Method" ><summary><span><a href="#_writev$2292">#</a></span>  <code><strong>_writev</strong></code><em>(chunks, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L844</a>  <ul>    <p>    <details id="chunks$2294" title="Parameter" ><summary><span><a href="#chunks$2294">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$2296" title="Property" ><summary><span><a href="#chunk$2296">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L846</a>  <ul><p>any</p>        </ul></details><details id="encoding$2297" title="Property" ><summary><span><a href="#encoding$2297">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L847</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$2298" title="Function" ><summary><span><a href="#callback$2298">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2301" title="Parameter" ><summary><span><a href="#error$2301">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_writev</strong><em>(chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="addListener$2400" title="Method" ><summary><span><a href="#addListener$2400">#</a></span>  <code><strong>addListener</strong></code><em>(event, listener)</em>     &ndash; Event emitter
The defined events on documents including:
1. close
2. data
3. end
4. error
5. pause
6. readable
7. resume</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L423</a>  <ul>    <p>    <details id="event$2402" title="Parameter" ><summary><span><a href="#event$2402">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2403" title="Function" ><summary><span><a href="#listener$2403">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2407" title="Parameter" ><summary><span><a href="#event$2407">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2408" title="Function" ><summary><span><a href="#listener$2408">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2411" title="Parameter" ><summary><span><a href="#chunk$2411">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2413" title="Parameter" ><summary><span><a href="#event$2413">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2414" title="Function" ><summary><span><a href="#listener$2414">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2418" title="Parameter" ><summary><span><a href="#event$2418">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2419" title="Function" ><summary><span><a href="#listener$2419">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2422" title="Parameter" ><summary><span><a href="#err$2422">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2424" title="Parameter" ><summary><span><a href="#event$2424">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2425" title="Function" ><summary><span><a href="#listener$2425">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2429" title="Parameter" ><summary><span><a href="#event$2429">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2430" title="Function" ><summary><span><a href="#listener$2430">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2434" title="Parameter" ><summary><span><a href="#event$2434">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2435" title="Function" ><summary><span><a href="#listener$2435">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2439" title="Parameter" ><summary><span><a href="#event$2439">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2440" title="Function" ><summary><span><a href="#listener$2440">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2443" title="Parameter" ><summary><span><a href="#args$2443">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="cork$2348" title="Method" ><summary><span><a href="#cork$2348">#</a></span>  <code><strong>cork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L859</a>  <ul>    <p>      <p><strong>cork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$2397" title="Method" ><summary><span><a href="#destroy$2397">#</a></span>  <code><strong>destroy</strong></code><em>(error)</em>     &ndash; Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code>event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the readable
stream will release any internal resources and subsequent calls to <code>push()</code>will be ignored.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L411</a>  <ul>    <p>  <p>

Once `destroy()` has been called any further calls will be a no-op and no
further errors except from `_destroy()` may be emitted as `'error'`.

Implementors should not override this method, but instead implement `readable._destroy()`.

</p>
  <details id="error$2399" title="Parameter" ><summary><span><a href="#error$2399">#</a></span>  <code><strong>error</strong></code>     &ndash; Error which will be passed as payload in <code>'error'</code> event
</summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>destroy</strong><em>(error)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="emit$2444" title="Method" ><summary><span><a href="#emit$2444">#</a></span>  <code><strong>emit</strong></code><em>(event)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L431</a>  <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="event$2446" title="Parameter" ><summary><span><a href="#event$2446">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2448" title="Parameter" ><summary><span><a href="#event$2448">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="chunk$2449" title="Parameter" ><summary><span><a href="#chunk$2449">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>emit</strong><em>(event, chunk)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2451" title="Parameter" ><summary><span><a href="#event$2451">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2453" title="Parameter" ><summary><span><a href="#event$2453">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="err$2454" title="Parameter" ><summary><span><a href="#err$2454">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>emit</strong><em>(event, err)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2456" title="Parameter" ><summary><span><a href="#event$2456">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2458" title="Parameter" ><summary><span><a href="#event$2458">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2460" title="Parameter" ><summary><span><a href="#event$2460">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$2462" title="Parameter" ><summary><span><a href="#event$2462">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$2463" title="Parameter" ><summary><span><a href="#args$2463">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(event, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$2332" title="Method" ><summary><span><a href="#end$2332">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L856</a>  <ul>    <p>    <details id="cb$2334" title="Function" ><summary><span><a href="#cb$2334">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="chunk$2338" title="Parameter" ><summary><span><a href="#chunk$2338">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$2339" title="Function" ><summary><span><a href="#cb$2339">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="chunk$2343" title="Parameter" ><summary><span><a href="#chunk$2343">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2344" title="Parameter" ><summary><span><a href="#encoding$2344">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$2345" title="Function" ><summary><span><a href="#cb$2345">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="eventNames$2717" title="Method" ><summary><span><a href="#eventNames$2717">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$2706" title="Method" ><summary><span><a href="#getMaxListeners$2706">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$2381" title="Method" ><summary><span><a href="#isPaused$2381">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>     &ndash; The <code>readable.isPaused()</code> method returns the current operating state of the<code>Readable</code>. This is used primarily by the mechanism that underlies the<code>readable.pipe()</code> method. In most
typical cases, there will be no reason to
use this method directly.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L278</a>  <ul>    <p>  <p>

```js
const readable = new stream.Readable()

readable.isPaused() // === false
readable.pause()
readable.isPaused() // === true
readable.resume()
readable.isPaused() // === false
```

</p>
    <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$2714" title="Method" ><summary><span><a href="#listenerCount$2714">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$2716" title="Parameter" ><summary><span><a href="#eventName$2716">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$2708" title="Method" ><summary><span><a href="#listeners$2708">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$2710" title="Parameter" ><summary><span><a href="#eventName$2710">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$2693" title="Method" ><summary><span><a href="#off$2693">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$2695" title="Parameter" ><summary><span><a href="#eventName$2695">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2696" title="Function" ><summary><span><a href="#listener$2696">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2699" title="Parameter" ><summary><span><a href="#args$2699">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="on$2464" title="Method" ><summary><span><a href="#on$2464">#</a></span>  <code><strong>on</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L439</a>  <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$2466" title="Parameter" ><summary><span><a href="#event$2466">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2467" title="Function" ><summary><span><a href="#listener$2467">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2471" title="Parameter" ><summary><span><a href="#event$2471">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2472" title="Function" ><summary><span><a href="#listener$2472">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2475" title="Parameter" ><summary><span><a href="#chunk$2475">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2477" title="Parameter" ><summary><span><a href="#event$2477">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2478" title="Function" ><summary><span><a href="#listener$2478">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2482" title="Parameter" ><summary><span><a href="#event$2482">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2483" title="Function" ><summary><span><a href="#listener$2483">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2486" title="Parameter" ><summary><span><a href="#err$2486">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2488" title="Parameter" ><summary><span><a href="#event$2488">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2489" title="Function" ><summary><span><a href="#listener$2489">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2493" title="Parameter" ><summary><span><a href="#event$2493">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2494" title="Function" ><summary><span><a href="#listener$2494">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2498" title="Parameter" ><summary><span><a href="#event$2498">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2499" title="Function" ><summary><span><a href="#listener$2499">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2503" title="Parameter" ><summary><span><a href="#event$2503">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2504" title="Function" ><summary><span><a href="#listener$2504">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2507" title="Parameter" ><summary><span><a href="#args$2507">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="once$2508" title="Method" ><summary><span><a href="#once$2508">#</a></span>  <code><strong>once</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L447</a>  <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$2510" title="Parameter" ><summary><span><a href="#event$2510">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2511" title="Function" ><summary><span><a href="#listener$2511">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2515" title="Parameter" ><summary><span><a href="#event$2515">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2516" title="Function" ><summary><span><a href="#listener$2516">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2519" title="Parameter" ><summary><span><a href="#chunk$2519">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2521" title="Parameter" ><summary><span><a href="#event$2521">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2522" title="Function" ><summary><span><a href="#listener$2522">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2526" title="Parameter" ><summary><span><a href="#event$2526">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2527" title="Function" ><summary><span><a href="#listener$2527">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2530" title="Parameter" ><summary><span><a href="#err$2530">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2532" title="Parameter" ><summary><span><a href="#event$2532">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2533" title="Function" ><summary><span><a href="#listener$2533">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2537" title="Parameter" ><summary><span><a href="#event$2537">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2538" title="Function" ><summary><span><a href="#listener$2538">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2542" title="Parameter" ><summary><span><a href="#event$2542">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2543" title="Function" ><summary><span><a href="#listener$2543">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2547" title="Parameter" ><summary><span><a href="#event$2547">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2548" title="Function" ><summary><span><a href="#listener$2548">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2551" title="Parameter" ><summary><span><a href="#args$2551">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="pause$2377" title="Method" ><summary><span><a href="#pause$2377">#</a></span>  <code><strong>pause</strong></code><em>()</em>     &ndash; The <code>readable.pause()</code> method will cause a stream in flowing mode to stop
emitting <code>'data'</code> events, switching out of flowing mode. Any data that
becomes available will remain in the internal buffer.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L242</a>  <ul>    <p>  <p>

```js
const readable = getReadableStreamSomehow()
readable.on('data', chunk => {
  console.log(`Received ${chunk.length} bytes of data.`)
  readable.pause()
  console.log('There will be no additional data for 1 second.')
  setTimeout(() => {
    console.log('Now data will start flowing again.')
    readable.resume()
  }, 1000)
})
```

The `readable.pause()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="pipe$2686" title="Method" ><summary><span><a href="#pipe$2686">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$2689" title="Parameter" ><summary><span><a href="#destination$2689">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$2690" title="Parameter" ><summary><span><a href="#options$2690">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$2692" title="Property" ><summary><span><a href="#end$2692">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$2552" title="Method" ><summary><span><a href="#prependListener$2552">#</a></span>  <code><strong>prependListener</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L455</a>  <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2554" title="Parameter" ><summary><span><a href="#event$2554">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2555" title="Function" ><summary><span><a href="#listener$2555">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2559" title="Parameter" ><summary><span><a href="#event$2559">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2560" title="Function" ><summary><span><a href="#listener$2560">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2563" title="Parameter" ><summary><span><a href="#chunk$2563">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2565" title="Parameter" ><summary><span><a href="#event$2565">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2566" title="Function" ><summary><span><a href="#listener$2566">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2570" title="Parameter" ><summary><span><a href="#event$2570">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2571" title="Function" ><summary><span><a href="#listener$2571">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2574" title="Parameter" ><summary><span><a href="#err$2574">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2576" title="Parameter" ><summary><span><a href="#event$2576">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2577" title="Function" ><summary><span><a href="#listener$2577">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2581" title="Parameter" ><summary><span><a href="#event$2581">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2582" title="Function" ><summary><span><a href="#listener$2582">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2586" title="Parameter" ><summary><span><a href="#event$2586">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2587" title="Function" ><summary><span><a href="#listener$2587">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2591" title="Parameter" ><summary><span><a href="#event$2591">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2592" title="Function" ><summary><span><a href="#listener$2592">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2595" title="Parameter" ><summary><span><a href="#args$2595">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="prependOnceListener$2596" title="Method" ><summary><span><a href="#prependOnceListener$2596">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L463</a>  <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2598" title="Parameter" ><summary><span><a href="#event$2598">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2599" title="Function" ><summary><span><a href="#listener$2599">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2603" title="Parameter" ><summary><span><a href="#event$2603">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2604" title="Function" ><summary><span><a href="#listener$2604">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2607" title="Parameter" ><summary><span><a href="#chunk$2607">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2609" title="Parameter" ><summary><span><a href="#event$2609">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2610" title="Function" ><summary><span><a href="#listener$2610">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2614" title="Parameter" ><summary><span><a href="#event$2614">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2615" title="Function" ><summary><span><a href="#listener$2615">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2618" title="Parameter" ><summary><span><a href="#err$2618">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2620" title="Parameter" ><summary><span><a href="#event$2620">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2621" title="Function" ><summary><span><a href="#listener$2621">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2625" title="Parameter" ><summary><span><a href="#event$2625">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2626" title="Function" ><summary><span><a href="#listener$2626">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2630" title="Parameter" ><summary><span><a href="#event$2630">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2631" title="Function" ><summary><span><a href="#listener$2631">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2635" title="Parameter" ><summary><span><a href="#event$2635">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2636" title="Function" ><summary><span><a href="#listener$2636">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2639" title="Parameter" ><summary><span><a href="#args$2639">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="push$2393" title="Method" ><summary><span><a href="#push$2393">#</a></span>  <code><strong>push</strong></code><em>(chunk, encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L398</a>  <ul>    <p>    <details id="chunk$2395" title="Parameter" ><summary><span><a href="#chunk$2395">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2396" title="Parameter" ><summary><span><a href="#encoding$2396">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>push</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="rawListeners$2711" title="Method" ><summary><span><a href="#rawListeners$2711">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$2713" title="Parameter" ><summary><span><a href="#eventName$2713">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$2371" title="Method" ><summary><span><a href="#read$2371">#</a></span>  <code><strong>read</strong></code><em>(size)</em>     &ndash; The <code>readable.read()</code> method pulls some data out of the internal buffer and
returns it. If no data available to be read, <code>null</code> is returned. By default,
the data will be returned as a <code>Buffer</code> object unless an encoding has been
specified using the <code>readable.setEncoding()</code> method or the stream is operating
in object mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L195</a>  <ul>    <p>  <p>

The optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which
case all of the data remaining in the internal
buffer will be returned.

If the `size` argument is not specified, all of the data contained in the
internal buffer will be returned.

The `size` argument must be less than or equal to 1 GiB.

The `readable.read()` method should only be called on `Readable` streams
operating in paused mode. In flowing mode, `readable.read()` is called
automatically until the internal buffer is fully drained.

```js
const readable = getReadableStreamSomehow()

// 'readable' may be triggered multiple times as data is buffered in
readable.on('readable', () => {
  let chunk
  console.log('Stream is readable (new data received in buffer)')
  // Use a loop to make sure we read all currently available data
  while (null !== (chunk = readable.read())) {
    console.log(`Read ${chunk.length} bytes of data...`)
  }
})

// 'end' will be triggered once when there is no more data available
readable.on('end', () => {
  console.log('Reached end of stream.')
})
```

Each call to `readable.read()` returns a chunk of data, or `null`. The chunks
are not concatenated. A `while` loop is necessary to consume all data
currently in the buffer. When reading a large file `.read()` may return `null`,
having consumed all buffered content so far, but there is still more data to
come not yet buffered. In this case a new `'readable'` event will be emitted
when there is more data in the buffer. Finally the `'end'` event will be
emitted when there is no more data to come.

Therefore to read a file's whole contents from a `readable`, it is necessary
to collect chunks across multiple `'readable'` events:

```js
const chunks = []

readable.on('readable', () => {
  let chunk
  while (null !== (chunk = readable.read())) {
    chunks.push(chunk)
  }
})

readable.on('end', () => {
  const content = chunks.join('')
})
```

A `Readable` stream in object mode will always return a single item from
a call to `readable.read(size)`, regardless of the value of the`size` argument.

If the `readable.read()` method returns a chunk of data, a `'data'` event will
also be emitted.

Calling {@link read} after the `'end'` event has
been emitted will return `null`. No runtime error will be raised.

</p>
  <details id="size$2373" title="Parameter" ><summary><span><a href="#size$2373">#</a></span>  <code><strong>size</strong></code>     &ndash; Optional argument to specify how much data to read.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>any</ul></p></p>    </ul></details><details id="removeAllListeners$2700" title="Method" ><summary><span><a href="#removeAllListeners$2700">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2702" title="Parameter" ><summary><span><a href="#event$2702">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="removeListener$2640" title="Method" ><summary><span><a href="#removeListener$2640">#</a></span>  <code><strong>removeListener</strong></code><em>(event, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L471</a>  <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$2642" title="Parameter" ><summary><span><a href="#event$2642">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$2643" title="Function" ><summary><span><a href="#listener$2643">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2647" title="Parameter" ><summary><span><a href="#event$2647">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"data"</code></p>        </ul></details><details id="listener$2648" title="Function" ><summary><span><a href="#listener$2648">#</a></span>  <code><strong>listener</strong></code><em>(chunk)</em>    </summary>    <ul>    <p>    <details id="chunk$2651" title="Parameter" ><summary><span><a href="#chunk$2651">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>listener</strong><em>(chunk)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2653" title="Parameter" ><summary><span><a href="#event$2653">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"end"</code></p>        </ul></details><details id="listener$2654" title="Function" ><summary><span><a href="#listener$2654">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2658" title="Parameter" ><summary><span><a href="#event$2658">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$2659" title="Function" ><summary><span><a href="#listener$2659">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$2662" title="Parameter" ><summary><span><a href="#err$2662">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2664" title="Parameter" ><summary><span><a href="#event$2664">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pause"</code></p>        </ul></details><details id="listener$2665" title="Function" ><summary><span><a href="#listener$2665">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2669" title="Parameter" ><summary><span><a href="#event$2669">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"readable"</code></p>        </ul></details><details id="listener$2670" title="Function" ><summary><span><a href="#listener$2670">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2674" title="Parameter" ><summary><span><a href="#event$2674">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"resume"</code></p>        </ul></details><details id="listener$2675" title="Function" ><summary><span><a href="#listener$2675">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p>  <details id="event$2679" title="Parameter" ><summary><span><a href="#event$2679">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$2680" title="Function" ><summary><span><a href="#listener$2680">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$2683" title="Parameter" ><summary><span><a href="#args$2683">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="resume$2379" title="Method" ><summary><span><a href="#resume$2379">#</a></span>  <code><strong>resume</strong></code><em>()</em>     &ndash; The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to
resume emitting <code>'data'</code> events, switching the stream into flowing mode.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L261</a>  <ul>    <p>  <p>

The `readable.resume()` method can be used to fully consume the data from a
stream without actually processing any of that data:

```js
getReadableStreamSomehow()
  .resume()
  .on('end', () => {
    console.log('Reached the end, but did not read anything.')
  })
```

The `readable.resume()` method has no effect if there is a `'readable'`event listener.

</p>
    <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="setDefaultEncoding$2329" title="Method" ><summary><span><a href="#setDefaultEncoding$2329">#</a></span>  <code><strong>setDefaultEncoding</strong></code><em>(encoding)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L855</a>  <ul>    <p>    <details id="encoding$2331" title="Parameter" ><summary><span><a href="#encoding$2331">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setDefaultEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="setEncoding$2374" title="Method" ><summary><span><a href="#setEncoding$2374">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>     &ndash; The <code>readable.setEncoding()</code> method sets the character encoding for
data read from the <code>Readable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L220</a>  <ul>    <p>  <p>

By default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data
to be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding('utf8')` will cause the
output data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal
string format.

The `Readable` stream will properly handle multi-byte characters delivered
through the stream that would otherwise become improperly decoded if simply
pulled from the stream as `Buffer` objects.

```js
const readable = getReadableStreamSomehow()
readable.setEncoding('utf8')
readable.on('data', chunk => {
  assert.equal(typeof chunk, 'string')
  console.log('Got %d characters of string data:', chunk.length)
})
```

</p>
  <details id="encoding$2376" title="Parameter" ><summary><span><a href="#encoding$2376">#</a></span>  <code><strong>encoding</strong></code>     &ndash; The encoding to use.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="setMaxListeners$2703" title="Method" ><summary><span><a href="#setMaxListeners$2703">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$2705" title="Parameter" ><summary><span><a href="#n$2705">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="uncork$2350" title="Method" ><summary><span><a href="#uncork$2350">#</a></span>  <code><strong>uncork</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L860</a>  <ul>    <p>      <p><strong>uncork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="unpipe$2383" title="Method" ><summary><span><a href="#unpipe$2383">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>     &ndash; The <code>readable.unpipe()</code> method detaches a <code>Writable</code> stream previously attached
using the {@link pipe} method.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L305</a>  <ul>    <p>  <p>

If the `destination` is not specified, then _all_ pipes are detached.

If the `destination` is specified, but no pipe is set up for it, then
the method does nothing.

```js
const fs = require('fs')
const readable = getReadableStreamSomehow()
const writable = fs.createWriteStream('file.txt')
// All the data from readable goes into 'file.txt',
// but only for the first second.
readable.pipe(writable)
setTimeout(() => {
  console.log('Stop writing to file.txt.')
  readable.unpipe(writable)
  console.log('Manually close the file stream.')
  writable.end()
}, 1000)
```

</p>
  <details id="destination$2385" title="Parameter" ><summary><span><a href="#destination$2385">#</a></span>  <code><strong>destination</strong></code>     &ndash; Optional specific stream to unpipe
</summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="unshift$2386" title="Method" ><summary><span><a href="#unshift$2386">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>     &ndash; Passing <code>chunk</code> as <code>null</code> signals the end of the stream (EOF) and behaves the
same as <code>readable.push(null)</code>, after which no more data can be written. The EOF
signal is put at the end of the buffer and any buffered data will still be
flushed.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L371</a>  <ul>    <p>  <p>

The `readable.unshift()` method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.

The `stream.unshift(chunk)` method cannot be called after the `'end'` event
has been emitted or a runtime error will be thrown.

Developers using `stream.unshift()` often should consider switching to
use of a `Transform` stream instead. See the `API for stream implementers` section for more information.

```js
// Pull off a header delimited by \n\n.
// Use unshift() if we get too much.
// Call the callback with (error, header, stream).
const { StringDecoder } = require('string_decoder')
function parseHeader(stream, callback) {
  stream.on('error', callback)
  stream.on('readable', onReadable)
  const decoder = new StringDecoder('utf8')
  let header = ''
  function onReadable() {
    let chunk
    while (null !== (chunk = stream.read())) {
      const str = decoder.write(chunk)
      if (str.match(/\n\n/)) {
        // Found the header boundary.
        const split = str.split(/\n\n/)
        header += split.shift()
        const remaining = split.join('\n\n')
        const buf = Buffer.from(remaining, 'utf8')
        stream.removeListener('error', callback)
        // Remove the 'readable' listener before unshifting.
        stream.removeListener('readable', onReadable)
        if (buf.length)
          stream.unshift(buf)
        // Now the body of the message can be read from the stream.
        callback(null, header, stream)
      } else {
        // Still reading the header.
        header += str
      }
    }
  }
}
```

Unlike {@link push}, `stream.unshift(chunk)` will not
end the reading process by resetting the internal reading state of the stream.
This can cause unexpected results if `readable.unshift()` is called during a
read (i.e. from within a {@link _read} implementation on a
custom stream). Following the call to `readable.unshift()` with an immediate {@link push} will reset the reading state appropriately,
however it is best to simply avoid calling `readable.unshift()` while in the
process of performing a read.

</p>
  <details id="chunk$2388" title="Parameter" ><summary><span><a href="#chunk$2388">#</a></span>  <code><strong>chunk</strong></code>     &ndash; Chunk of data to unshift onto the read queue. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code>, <code>Uint8Array</code> or <code>null</code>. For object mode
streams, <code>chunk</code> may be any JavaScript value.</summary>    <ul><p>any</p>        </ul></details><details id="encoding$2389" title="Parameter" ><summary><span><a href="#encoding$2389">#</a></span>  <code><strong>encoding</strong></code>     &ndash; Encoding of string chunks. Must be a valid <code>Buffer</code> encoding, such as <code>'utf8'</code> or <code>'ascii'</code>.
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$2390" title="Method" ><summary><span><a href="#wrap$2390">#</a></span>  <code><strong>wrap</strong></code><em>(stream)</em>     &ndash; Prior to Node.js 0.10, streams did not implement the entire <code>stream</code> module API
as it is currently defined. (See <code>Compatibility</code> for more information.)</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L397</a>  <ul>    <p>  <p>

When using an older Node.js library that emits `'data'` events and has a {@link pause} method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`
stream that uses
the old stream as its data source.

It will rarely be necessary to use `readable.wrap()` but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.

```js
const { OldReader } = require('./old-api-module.js')
const { Readable } = require('stream')
const oreader = new OldReader()
const myReader = new Readable().wrap(oreader)

myReader.on('readable', () => {
  myReader.read() // etc.
})
```

</p>
  <details id="stream$2392" title="Parameter" ><summary><span><a href="#stream$2392">#</a></span>  <code><strong>stream</strong></code>     &ndash; An &quot;old style&quot; readable stream
</summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(stream)</em>  &nbsp;=&gt;  <ul><a href="#Transform$2228">Transform</a></ul></p></p>    </ul></details><details id="write$2315" title="Method" ><summary><span><a href="#write$2315">#</a></span>  <code><strong>write</strong></code><em>(chunk, encoding, cb)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L853</a>  <ul>    <p>    <details id="chunk$2317" title="Parameter" ><summary><span><a href="#chunk$2317">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2318" title="Parameter" ><summary><span><a href="#encoding$2318">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$2319" title="Function" ><summary><span><a href="#cb$2319">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2322" title="Parameter" ><summary><span><a href="#error$2322">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="chunk$2324" title="Parameter" ><summary><span><a href="#chunk$2324">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$2325" title="Function" ><summary><span><a href="#cb$2325">#</a></span>  <code><strong>cb</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2328" title="Parameter" ><summary><span><a href="#error$2328">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="from$2229" title="Method" ><summary><span><a href="#from$2229">#</a></span>  <code><strong>from</strong></code><em>(src)</em>     &ndash; A utility method for creating duplex streams.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L842</a>  <ul>    <p>  <p>

- `Stream` converts writable stream into writable `Duplex` and readable stream
  to `Duplex`.
- `Blob` converts into readable `Duplex`.
- `string` converts into readable `Duplex`.
- `ArrayBuffer` converts into readable `Duplex`.
- `AsyncIterable` converts into a readable `Duplex`. Cannot yield `null`.
- `AsyncGeneratorFunction` converts into a readable/writable transform
  `Duplex`. Must take a source `AsyncIterable` as first parameter. Cannot yield
  `null`.
- `AsyncFunction` converts into a writable `Duplex`. Must return
  either `null` or `undefined`
- `Object ({ writable, readable })` converts `readable` and
  `writable` into `Stream` and then combines them into `Duplex` where the
  `Duplex` will write to the `writable` and read from the `readable`.
- `Promise` converts into readable `Duplex`. Value `null` is ignored.

</p>
  <details id="src$2231" title="Parameter" ><summary><span><a href="#src$2231">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p>string | <span>Object</span> | <a href="#Stream$119">Stream</a> | <span>ArrayBuffer</span> | <span>Promise</span>&lt;any&gt; | <span>Iterable</span>&lt;any&gt; | <span>AsyncIterable</span>&lt;any&gt; | <span>Blob</span> | <span>AsyncGeneratorFunction</span></p>        </ul></details>  <p><strong>from</strong><em>(src)</em>  &nbsp;=&gt;  <ul><a href="#Duplex$1669">Duplex</a></ul></p></p>    </ul></details><details id="getEventListeners$2253" title="Method" ><summary><span><a href="#getEventListeners$2253">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$2255" title="Parameter" ><summary><span><a href="#emitter$2255">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$2256" title="Parameter" ><summary><span><a href="#name$2256">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="isDisturbed$2232" title="Method" ><summary><span><a href="#isDisturbed$2232">#</a></span>  <code><strong>isDisturbed</strong></code><em>(stream)</em>     &ndash; Returns whether the stream has been read from or cancelled.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L59</a>  <ul>    <p>    <details id="stream$2234" title="Parameter" ><summary><span><a href="#stream$2234">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a> | <a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>isDisturbed</strong><em>(stream)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$2249" title="Method" ><summary><span><a href="#listenerCount$2249">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$2251" title="Parameter" ><summary><span><a href="#emitter$2251">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$2252" title="Parameter" ><summary><span><a href="#eventName$2252">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$2244" title="Method" ><summary><span><a href="#on$2244">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$2246" title="Parameter" ><summary><span><a href="#emitter$2246">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$2247" title="Parameter" ><summary><span><a href="#eventName$2247">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$2248" title="Parameter" ><summary><span><a href="#options$2248">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$2235" title="Method" ><summary><span><a href="#once$2235">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$2237" title="Parameter" ><summary><span><a href="#emitter$2237">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$2238" title="Parameter" ><summary><span><a href="#eventName$2238">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$2239" title="Parameter" ><summary><span><a href="#options$2239">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$2241" title="Parameter" ><summary><span><a href="#emitter$2241">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$2242" title="Parameter" ><summary><span><a href="#eventName$2242">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$2243" title="Parameter" ><summary><span><a href="#options$2243">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$2257" title="Method" ><summary><span><a href="#setMaxListeners$2257">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$2259" title="Parameter" ><summary><span><a href="#n$2259">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$2260" title="Parameter" ><summary><span><a href="#eventTargets$2260">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="Writable$1197" title="Class" ><summary><span><a href="#Writable$1197">#</a></span>  <code><strong>Writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L498">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L498</a>  <ul>        <p>  <details id="constructor$1228" title="Constructor" ><summary><span><a href="#constructor$1228">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L544">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L544</a>  <ul>    <p>  <details id="new Writable$1229" title="ConstructorSignature" ><summary><span><a href="#new Writable$1229">#</a></span>  <code><strong>new Writable</strong></code><em>()</em>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>      <p>  <details id="opts$1230" title="Parameter" ><summary><span><a href="#opts$1230">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#WritableOptions$1147">WritableOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="destroyed$1238" title="Property" ><summary><span><a href="#destroyed$1238">#</a></span>  <code><strong>destroyed</strong></code>     &ndash; Is <code>true</code> after <code>writable.destroy()</code> has been called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L543">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L543</a>  <ul><p>boolean</p>        </ul></details><details id="writable$1231" title="Property" ><summary><span><a href="#writable$1231">#</a></span>  <code><strong>writable</strong></code>     &ndash; Is <code>true</code> if it is safe to call <code>writable.write()</code>, which means
the stream has not been destroyed, errored or ended.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L504">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L504</a>  <ul><p>boolean</p>        </ul></details><details id="writableCorked$1237" title="Property" ><summary><span><a href="#writableCorked$1237">#</a></span>  <code><strong>writableCorked</strong></code>     &ndash; Number of times <code>writable.uncork()</code> needs to be
called in order to fully uncork the stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L538">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L538</a>  <ul><p>number</p>        </ul></details><details id="writableEnded$1232" title="Property" ><summary><span><a href="#writableEnded$1232">#</a></span>  <code><strong>writableEnded</strong></code>     &ndash; Is <code>true</code> after <code>writable.end()</code> has been called. This property
does not indicate whether the data has been flushed, for this use <code>writable.writableFinished</code> instead.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L510">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L510</a>  <ul><p>boolean</p>        </ul></details><details id="writableFinished$1233" title="Property" ><summary><span><a href="#writableFinished$1233">#</a></span>  <code><strong>writableFinished</strong></code>     &ndash; Is set to <code>true</code> immediately before the <code>'finish'</code> event is emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L515">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L515</a>  <ul><p>boolean</p>        </ul></details><details id="writableHighWaterMark$1234" title="Property" ><summary><span><a href="#writableHighWaterMark$1234">#</a></span>  <code><strong>writableHighWaterMark</strong></code>     &ndash; Return the value of <code>highWaterMark</code> passed when creating this <code>Writable</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L520">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L520</a>  <ul><p>number</p>        </ul></details><details id="writableLength$1235" title="Property" ><summary><span><a href="#writableLength$1235">#</a></span>  <code><strong>writableLength</strong></code>     &ndash; This property contains the number of bytes (or objects) in the queue
ready to be written. The value provides introspection data regarding
the status of the <code>highWaterMark</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L527">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L527</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$1236" title="Property" ><summary><span><a href="#writableObjectMode$1236">#</a></span>  <code><strong>writableObjectMode</strong></code>     &ndash; Getter for the property <code>objectMode</code> of a given <code>Writable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L532">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L532</a>  <ul><p>boolean</p>        </ul></details><details id="captureRejectionSymbol$1225" title="Property" ><summary><span><a href="#captureRejectionSymbol$1225">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$1226" title="Property" ><summary><span><a href="#captureRejections$1226">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$1227" title="Property" ><summary><span><a href="#defaultMaxListeners$1227">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$1224" title="Property" ><summary><span><a href="#errorMonitor$1224">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="_construct$1257" title="Method" ><summary><span><a href="#_construct$1257">#</a></span>  <code><strong>_construct</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L553">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L553</a>  <ul>    <p>    <details id="callback$1259" title="Function" ><summary><span><a href="#callback$1259">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1262" title="Parameter" ><summary><span><a href="#error$1262">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_construct</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_destroy$1263" title="Method" ><summary><span><a href="#_destroy$1263">#</a></span>  <code><strong>_destroy</strong></code><em>(error, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L554">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L554</a>  <ul>    <p>    <details id="error$1265" title="Parameter" ><summary><span><a href="#error$1265">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$1266" title="Function" ><summary><span><a href="#callback$1266">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1269" title="Parameter" ><summary><span><a href="#error$1269">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_destroy</strong><em>(error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_final$1270" title="Method" ><summary><span><a href="#_final$1270">#</a></span>  <code><strong>_final</strong></code><em>(callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L555">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L555</a>  <ul>    <p>    <details id="callback$1272" title="Function" ><summary><span><a href="#callback$1272">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1275" title="Parameter" ><summary><span><a href="#error$1275">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_final</strong><em>(callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_write$1239" title="Method" ><summary><span><a href="#_write$1239">#</a></span>  <code><strong>_write</strong></code><em>(chunk, encoding, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L545">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L545</a>  <ul>    <p>    <details id="chunk$1241" title="Parameter" ><summary><span><a href="#chunk$1241">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1242" title="Parameter" ><summary><span><a href="#encoding$1242">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$1243" title="Function" ><summary><span><a href="#callback$1243">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1246" title="Parameter" ><summary><span><a href="#error$1246">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_write</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="_writev$1247" title="Method" ><summary><span><a href="#_writev$1247">#</a></span>  <code><strong>_writev</strong></code><em>(chunks, callback)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L546">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L546</a>  <ul>    <p>    <details id="chunks$1249" title="Parameter" ><summary><span><a href="#chunks$1249">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$1251" title="Property" ><summary><span><a href="#chunk$1251">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L548">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L548</a>  <ul><p>any</p>        </ul></details><details id="encoding$1252" title="Property" ><summary><span><a href="#encoding$1252">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L549">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L549</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$1253" title="Function" ><summary><span><a href="#callback$1253">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1256" title="Parameter" ><summary><span><a href="#error$1256">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>_writev</strong><em>(chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="addListener$1316" title="Method" ><summary><span><a href="#addListener$1316">#</a></span>  <code><strong>addListener</strong></code><em>(event, listener)</em>     &ndash; Event emitter
The defined events on documents including:
1. close
2. drain
3. error
4. finish
5. pipe
6. unpipe</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L721">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L721</a>  <ul>    <p>    <details id="event$1318" title="Parameter" ><summary><span><a href="#event$1318">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1319" title="Function" ><summary><span><a href="#listener$1319">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1323" title="Parameter" ><summary><span><a href="#event$1323">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1324" title="Function" ><summary><span><a href="#listener$1324">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1328" title="Parameter" ><summary><span><a href="#event$1328">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1329" title="Function" ><summary><span><a href="#listener$1329">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1332" title="Parameter" ><summary><span><a href="#err$1332">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1334" title="Parameter" ><summary><span><a href="#event$1334">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1335" title="Function" ><summary><span><a href="#listener$1335">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1339" title="Parameter" ><summary><span><a href="#event$1339">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1340" title="Function" ><summary><span><a href="#listener$1340">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1343" title="Parameter" ><summary><span><a href="#src$1343">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1345" title="Parameter" ><summary><span><a href="#event$1345">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1346" title="Function" ><summary><span><a href="#listener$1346">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1349" title="Parameter" ><summary><span><a href="#src$1349">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1351" title="Parameter" ><summary><span><a href="#event$1351">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1352" title="Function" ><summary><span><a href="#listener$1352">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1355" title="Parameter" ><summary><span><a href="#args$1355">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="cork$1309" title="Method" ><summary><span><a href="#cork$1309">#</a></span>  <code><strong>cork</strong></code><em>()</em>     &ndash; The <code>writable.cork()</code> method forces all written data to be buffered in memory.
The buffered data will be flushed when either the {@link uncork} or {@link end} methods are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L659">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L659</a>  <ul>    <p>  <p>

The primary intent of `writable.cork()` is to accommodate a situation in which
several small chunks are written to the stream in rapid succession. Instead of
immediately forwarding them to the underlying destination, `writable.cork()`buffers all the chunks until `writable.uncork()` is called, which will pass them
all to `writable._writev()`, if present. This prevents a head-of-line blocking
situation where data is being buffered while waiting for the first small chunk
to be processed. However, use of `writable.cork()` without implementing`writable._writev()` may have an adverse effect on throughput.

See also: `writable.uncork()`, `writable._writev()`.

</p>
    <p><strong>cork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$1313" title="Method" ><summary><span><a href="#destroy$1313">#</a></span>  <code><strong>destroy</strong></code><em>(error)</em>     &ndash; Destroy the stream. Optionally emit an <code>'error'</code> event, and emit a <code>'close'</code>event (unless <code>emitClose</code> is set to <code>false</code>). After this call, the writable
stream has ended and subsequent calls to <code>write()</code> or <code>end()</code> will result in
an <code>ERR_STREAM_DESTROYED</code> error.
This is a destructive and immediate way to destroy a stream. Previous calls to<code>write()</code> may not have drained, and may trigger an <code>ERR_STREAM_DESTROYED</code> error.
Use <code>end()</code> instead of destroy if data should flush before close, or wait for
the <code>'drain'</code> event before destroying the stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L710">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L710</a>  <ul>    <p>  <p>

Once `destroy()` has been called any further calls will be a no-op and no
further errors except from `_destroy()` may be emitted as `'error'`.

Implementors should not override this method,
but instead implement `writable._destroy()`.

</p>
  <details id="error$1315" title="Parameter" ><summary><span><a href="#error$1315">#</a></span>  <code><strong>error</strong></code>     &ndash; Optional, an error to emit with <code>'error'</code> event.
</summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>destroy</strong><em>(error)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="emit$1356" title="Method" ><summary><span><a href="#emit$1356">#</a></span>  <code><strong>emit</strong></code><em>(event)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L728">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L728</a>  <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="event$1358" title="Parameter" ><summary><span><a href="#event$1358">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1360" title="Parameter" ><summary><span><a href="#event$1360">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1362" title="Parameter" ><summary><span><a href="#event$1362">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="err$1363" title="Parameter" ><summary><span><a href="#err$1363">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>emit</strong><em>(event, err)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1365" title="Parameter" ><summary><span><a href="#event$1365">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details>  <p><strong>emit</strong><em>(event)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1367" title="Parameter" ><summary><span><a href="#event$1367">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="src$1368" title="Parameter" ><summary><span><a href="#src$1368">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>emit</strong><em>(event, src)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1370" title="Parameter" ><summary><span><a href="#event$1370">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="src$1371" title="Parameter" ><summary><span><a href="#src$1371">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>emit</strong><em>(event, src)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="event$1373" title="Parameter" ><summary><span><a href="#event$1373">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$1374" title="Parameter" ><summary><span><a href="#args$1374">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(event, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$1293" title="Method" ><summary><span><a href="#end$1293">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>     &ndash; Calling the <code>writable.end()</code> method signals that no more data will be written
to the <code>Writable</code>. The optional <code>chunk</code> and <code>encoding</code> arguments allow one
final additional chunk of data to be written immediately before closing the
stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L642">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L642</a>  <ul>    <p>  <p>

Calling the {@link write} method after calling {@link end} will raise an error.

```js
// Write 'hello, ' and then end with 'world!'.
const fs = require('fs')
const file = fs.createWriteStream('example.txt')
file.write('hello, ')
file.end('world!')
// Writing more now is not allowed!
```

</p>
  <details id="cb$1295" title="Function" ><summary><span><a href="#cb$1295">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="chunk$1299" title="Parameter" ><summary><span><a href="#chunk$1299">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="cb$1300" title="Function" ><summary><span><a href="#cb$1300">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, cb)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="chunk$1304" title="Parameter" ><summary><span><a href="#chunk$1304">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1305" title="Parameter" ><summary><span><a href="#encoding$1305">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$1306" title="Function" ><summary><span><a href="#cb$1306">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(chunk, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="eventNames$1606" title="Method" ><summary><span><a href="#eventNames$1606">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$1595" title="Method" ><summary><span><a href="#getMaxListeners$1595">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$1603" title="Method" ><summary><span><a href="#listenerCount$1603">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$1605" title="Parameter" ><summary><span><a href="#eventName$1605">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$1597" title="Method" ><summary><span><a href="#listeners$1597">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$1599" title="Parameter" ><summary><span><a href="#eventName$1599">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$1582" title="Method" ><summary><span><a href="#off$1582">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$1584" title="Parameter" ><summary><span><a href="#eventName$1584">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1585" title="Function" ><summary><span><a href="#listener$1585">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1588" title="Parameter" ><summary><span><a href="#args$1588">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="on$1375" title="Method" ><summary><span><a href="#on$1375">#</a></span>  <code><strong>on</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L735">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L735</a>  <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$1377" title="Parameter" ><summary><span><a href="#event$1377">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1378" title="Function" ><summary><span><a href="#listener$1378">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1382" title="Parameter" ><summary><span><a href="#event$1382">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1383" title="Function" ><summary><span><a href="#listener$1383">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1387" title="Parameter" ><summary><span><a href="#event$1387">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1388" title="Function" ><summary><span><a href="#listener$1388">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1391" title="Parameter" ><summary><span><a href="#err$1391">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1393" title="Parameter" ><summary><span><a href="#event$1393">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1394" title="Function" ><summary><span><a href="#listener$1394">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1398" title="Parameter" ><summary><span><a href="#event$1398">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1399" title="Function" ><summary><span><a href="#listener$1399">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1402" title="Parameter" ><summary><span><a href="#src$1402">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1404" title="Parameter" ><summary><span><a href="#event$1404">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1405" title="Function" ><summary><span><a href="#listener$1405">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1408" title="Parameter" ><summary><span><a href="#src$1408">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1410" title="Parameter" ><summary><span><a href="#event$1410">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1411" title="Function" ><summary><span><a href="#listener$1411">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1414" title="Parameter" ><summary><span><a href="#args$1414">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="once$1415" title="Method" ><summary><span><a href="#once$1415">#</a></span>  <code><strong>once</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L742">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L742</a>  <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="event$1417" title="Parameter" ><summary><span><a href="#event$1417">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1418" title="Function" ><summary><span><a href="#listener$1418">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1422" title="Parameter" ><summary><span><a href="#event$1422">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1423" title="Function" ><summary><span><a href="#listener$1423">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1427" title="Parameter" ><summary><span><a href="#event$1427">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1428" title="Function" ><summary><span><a href="#listener$1428">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1431" title="Parameter" ><summary><span><a href="#err$1431">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1433" title="Parameter" ><summary><span><a href="#event$1433">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1434" title="Function" ><summary><span><a href="#listener$1434">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1438" title="Parameter" ><summary><span><a href="#event$1438">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1439" title="Function" ><summary><span><a href="#listener$1439">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1442" title="Parameter" ><summary><span><a href="#src$1442">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1444" title="Parameter" ><summary><span><a href="#event$1444">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1445" title="Function" ><summary><span><a href="#listener$1445">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1448" title="Parameter" ><summary><span><a href="#src$1448">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1450" title="Parameter" ><summary><span><a href="#event$1450">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1451" title="Function" ><summary><span><a href="#listener$1451">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1454" title="Parameter" ><summary><span><a href="#args$1454">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="pipe$1575" title="Method" ><summary><span><a href="#pipe$1575">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$1578" title="Parameter" ><summary><span><a href="#destination$1578">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$1579" title="Parameter" ><summary><span><a href="#options$1579">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$1581" title="Property" ><summary><span><a href="#end$1581">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$1455" title="Method" ><summary><span><a href="#prependListener$1455">#</a></span>  <code><strong>prependListener</strong></code><em>(event, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L749">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L749</a>  <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1457" title="Parameter" ><summary><span><a href="#event$1457">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1458" title="Function" ><summary><span><a href="#listener$1458">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1462" title="Parameter" ><summary><span><a href="#event$1462">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1463" title="Function" ><summary><span><a href="#listener$1463">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1467" title="Parameter" ><summary><span><a href="#event$1467">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1468" title="Function" ><summary><span><a href="#listener$1468">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1471" title="Parameter" ><summary><span><a href="#err$1471">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1473" title="Parameter" ><summary><span><a href="#event$1473">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1474" title="Function" ><summary><span><a href="#listener$1474">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1478" title="Parameter" ><summary><span><a href="#event$1478">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1479" title="Function" ><summary><span><a href="#listener$1479">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1482" title="Parameter" ><summary><span><a href="#src$1482">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1484" title="Parameter" ><summary><span><a href="#event$1484">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1485" title="Function" ><summary><span><a href="#listener$1485">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1488" title="Parameter" ><summary><span><a href="#src$1488">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1490" title="Parameter" ><summary><span><a href="#event$1490">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1491" title="Function" ><summary><span><a href="#listener$1491">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1494" title="Parameter" ><summary><span><a href="#args$1494">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="prependOnceListener$1495" title="Method" ><summary><span><a href="#prependOnceListener$1495">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(event, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L756">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L756</a>  <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1497" title="Parameter" ><summary><span><a href="#event$1497">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1498" title="Function" ><summary><span><a href="#listener$1498">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1502" title="Parameter" ><summary><span><a href="#event$1502">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1503" title="Function" ><summary><span><a href="#listener$1503">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1507" title="Parameter" ><summary><span><a href="#event$1507">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1508" title="Function" ><summary><span><a href="#listener$1508">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1511" title="Parameter" ><summary><span><a href="#err$1511">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1513" title="Parameter" ><summary><span><a href="#event$1513">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1514" title="Function" ><summary><span><a href="#listener$1514">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1518" title="Parameter" ><summary><span><a href="#event$1518">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1519" title="Function" ><summary><span><a href="#listener$1519">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1522" title="Parameter" ><summary><span><a href="#src$1522">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1524" title="Parameter" ><summary><span><a href="#event$1524">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1525" title="Function" ><summary><span><a href="#listener$1525">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1528" title="Parameter" ><summary><span><a href="#src$1528">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1530" title="Parameter" ><summary><span><a href="#event$1530">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1531" title="Function" ><summary><span><a href="#listener$1531">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1534" title="Parameter" ><summary><span><a href="#args$1534">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="rawListeners$1600" title="Method" ><summary><span><a href="#rawListeners$1600">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$1602" title="Parameter" ><summary><span><a href="#eventName$1602">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$1589" title="Method" ><summary><span><a href="#removeAllListeners$1589">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1591" title="Parameter" ><summary><span><a href="#event$1591">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="removeListener$1535" title="Method" ><summary><span><a href="#removeListener$1535">#</a></span>  <code><strong>removeListener</strong></code><em>(event, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L763">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L763</a>  <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$1537" title="Parameter" ><summary><span><a href="#event$1537">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"close"</code></p>        </ul></details><details id="listener$1538" title="Function" ><summary><span><a href="#listener$1538">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1542" title="Parameter" ><summary><span><a href="#event$1542">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"drain"</code></p>        </ul></details><details id="listener$1543" title="Function" ><summary><span><a href="#listener$1543">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1547" title="Parameter" ><summary><span><a href="#event$1547">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"error"</code></p>        </ul></details><details id="listener$1548" title="Function" ><summary><span><a href="#listener$1548">#</a></span>  <code><strong>listener</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$1551" title="Parameter" ><summary><span><a href="#err$1551">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><span>Error</span></p>        </ul></details>  <p><strong>listener</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1553" title="Parameter" ><summary><span><a href="#event$1553">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"finish"</code></p>        </ul></details><details id="listener$1554" title="Function" ><summary><span><a href="#listener$1554">#</a></span>  <code><strong>listener</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>listener</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1558" title="Parameter" ><summary><span><a href="#event$1558">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"pipe"</code></p>        </ul></details><details id="listener$1559" title="Function" ><summary><span><a href="#listener$1559">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1562" title="Parameter" ><summary><span><a href="#src$1562">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1564" title="Parameter" ><summary><span><a href="#event$1564">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p><code>"unpipe"</code></p>        </ul></details><details id="listener$1565" title="Function" ><summary><span><a href="#listener$1565">#</a></span>  <code><strong>listener</strong></code><em>(src)</em>    </summary>    <ul>    <p>    <details id="src$1568" title="Parameter" ><summary><span><a href="#src$1568">#</a></span>  <code><strong>src</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details>  <p><strong>listener</strong><em>(src)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p>  <details id="event$1570" title="Parameter" ><summary><span><a href="#event$1570">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$1571" title="Function" ><summary><span><a href="#listener$1571">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$1574" title="Parameter" ><summary><span><a href="#args$1574">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(event, listener)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="setDefaultEncoding$1290" title="Method" ><summary><span><a href="#setDefaultEncoding$1290">#</a></span>  <code><strong>setDefaultEncoding</strong></code><em>(encoding)</em>     &ndash; The <code>writable.setDefaultEncoding()</code> method sets the default <code>encoding</code> for a <code>Writable</code> stream.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L619">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L619</a>  <ul>    <p>    <details id="encoding$1292" title="Parameter" ><summary><span><a href="#encoding$1292">#</a></span>  <code><strong>encoding</strong></code>     &ndash; The new default encoding
</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setDefaultEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="setMaxListeners$1592" title="Method" ><summary><span><a href="#setMaxListeners$1592">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$1594" title="Parameter" ><summary><span><a href="#n$1594">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Writable$1197">Writable</a></ul></p></p>    </ul></details><details id="uncork$1311" title="Method" ><summary><span><a href="#uncork$1311">#</a></span>  <code><strong>uncork</strong></code><em>()</em>     &ndash; The <code>writable.uncork()</code> method flushes all data buffered since {@link cork} was called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L693">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L693</a>  <ul>    <p>  <p>

When using `writable.cork()` and `writable.uncork()` to manage the buffering
of writes to a stream, it is recommended that calls to `writable.uncork()` be
deferred using `process.nextTick()`. Doing so allows batching of all`writable.write()` calls that occur within a given Node.js event loop phase.

```js
stream.cork()
stream.write('some ')
stream.write('data ')
process.nextTick(() => stream.uncork())
```

If the `writable.cork()` method is called multiple times on a stream, the
same number of calls to `writable.uncork()` must be called to flush the buffered
data.

```js
stream.cork()
stream.write('some ')
stream.cork()
stream.write('data ')
process.nextTick(() => {
  stream.uncork()
  // The data will not be flushed until uncork() is called a second time.
  stream.uncork()
})
```

See also: `writable.cork()`.

</p>
    <p><strong>uncork</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="write$1276" title="Method" ><summary><span><a href="#write$1276">#</a></span>  <code><strong>write</strong></code><em>(chunk, callback)</em>     &ndash; The <code>writable.write()</code> method writes some data to the stream, and calls the
supplied <code>callback</code> once the data has been fully handled. If an error
occurs, the <code>callback</code> will be called with the error as its
first argument. The <code>callback</code> is called asynchronously and before <code>'error'</code> is
emitted.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L612">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L612</a>  <ul>    <p>  <p>

The return value is `true` if the internal buffer is less than the`highWaterMark` configured when the stream was created after admitting `chunk`.
If `false` is returned, further attempts to write data to the stream should
stop until the `'drain'` event is emitted.

While a stream is not draining, calls to `write()` will buffer `chunk`, and
return false. Once all currently buffered chunks are drained (accepted for
delivery by the operating system), the `'drain'` event will be emitted.
It is recommended that once `write()` returns false, no more chunks be written
until the `'drain'` event is emitted. While calling `write()` on a stream that
is not draining is allowed, Node.js will buffer all written chunks until
maximum memory usage occurs, at which point it will abort unconditionally.
Even before it aborts, high memory usage will cause poor garbage collector
performance and high RSS (which is not typically released back to the system,
even after the memory is no longer required). Since TCP sockets may never
drain if the remote peer does not read the data, writing a socket that is
not draining may lead to a remotely exploitable vulnerability.

Writing data while the stream is not draining is particularly
problematic for a `Transform`, because the `Transform` streams are paused
by default until they are piped or a `'data'` or `'readable'` event handler
is added.

If the data to be written can be generated or fetched on demand, it is
recommended to encapsulate the logic into a `Readable` and use {@link pipe}. However, if calling `write()` is preferred, it is
possible to respect backpressure and avoid memory issues using the `'drain'` event:

```js
function write(data, cb) {
  if (!stream.write(data)) {
    stream.once('drain', cb)
  } else {
    process.nextTick(cb)
  }
}

// Wait for cb to be called before doing any other write.
write('hello', () => {
  console.log('Write completed, do more writes now.')
})
```

A `Writable` stream in object mode will always ignore the `encoding` argument.

</p>
  <details id="chunk$1278" title="Parameter" ><summary><span><a href="#chunk$1278">#</a></span>  <code><strong>chunk</strong></code>     &ndash; Optional data to write. For streams not operating in object mode, <code>chunk</code> must be a string, <code>Buffer</code> or <code>Uint8Array</code>. For object mode streams, <code>chunk</code> may be any
JavaScript value other than <code>null</code>.</summary>    <ul><p>any</p>        </ul></details><details id="callback$1279" title="Function" ><summary><span><a href="#callback$1279">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1282" title="Parameter" ><summary><span><a href="#error$1282">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, callback)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="chunk$1284" title="Parameter" ><summary><span><a href="#chunk$1284">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1285" title="Parameter" ><summary><span><a href="#encoding$1285">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$1286" title="Function" ><summary><span><a href="#callback$1286">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1289" title="Parameter" ><summary><span><a href="#error$1289">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p>undefined | <code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="getEventListeners$1216" title="Method" ><summary><span><a href="#getEventListeners$1216">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$1218" title="Parameter" ><summary><span><a href="#emitter$1218">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$1219" title="Parameter" ><summary><span><a href="#name$1219">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$1212" title="Method" ><summary><span><a href="#listenerCount$1212">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$1214" title="Parameter" ><summary><span><a href="#emitter$1214">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$1215" title="Parameter" ><summary><span><a href="#eventName$1215">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$1207" title="Method" ><summary><span><a href="#on$1207">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$1209" title="Parameter" ><summary><span><a href="#emitter$1209">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$1210" title="Parameter" ><summary><span><a href="#eventName$1210">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$1211" title="Parameter" ><summary><span><a href="#options$1211">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$1198" title="Method" ><summary><span><a href="#once$1198">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$1200" title="Parameter" ><summary><span><a href="#emitter$1200">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$1201" title="Parameter" ><summary><span><a href="#eventName$1201">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$1202" title="Parameter" ><summary><span><a href="#options$1202">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$1204" title="Parameter" ><summary><span><a href="#emitter$1204">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$1205" title="Parameter" ><summary><span><a href="#eventName$1205">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$1206" title="Parameter" ><summary><span><a href="#options$1206">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$1220" title="Method" ><summary><span><a href="#setMaxListeners$1220">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$1222" title="Parameter" ><summary><span><a href="#n$1222">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$1223" title="Parameter" ><summary><span><a href="#eventTargets$1223">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="DuplexOptions$1608" title="Interface" ><summary><span><a href="#DuplexOptions$1608">#</a></span>  <code><strong>DuplexOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L771">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L771</a>  <ul>        <p>  <details id="allowHalfOpen$1609" title="Property" ><summary><span><a href="#allowHalfOpen$1609">#</a></span>  <code><strong>allowHalfOpen</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L772">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L772</a>  <ul><p>boolean</p>        </ul></details><details id="autoDestroy$1665" title="Property" ><summary><span><a href="#autoDestroy$1665">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="decodeStrings$1667" title="Property" ><summary><span><a href="#decodeStrings$1667">#</a></span>  <code><strong>decodeStrings</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482</a>  <ul><p>boolean</p>        </ul></details><details id="defaultEncoding$1668" title="Property" ><summary><span><a href="#defaultEncoding$1668">#</a></span>  <code><strong>defaultEncoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="emitClose$1662" title="Property" ><summary><span><a href="#emitClose$1662">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="encoding$1661" title="Property" ><summary><span><a href="#encoding$1661">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="highWaterMark$1663" title="Property" ><summary><span><a href="#highWaterMark$1663">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$1664" title="Property" ><summary><span><a href="#objectMode$1664">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="readableHighWaterMark$1612" title="Property" ><summary><span><a href="#readableHighWaterMark$1612">#</a></span>  <code><strong>readableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L775">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L775</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$1610" title="Property" ><summary><span><a href="#readableObjectMode$1610">#</a></span>  <code><strong>readableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L773">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L773</a>  <ul><p>boolean</p>        </ul></details><details id="signal$1666" title="Property" ><summary><span><a href="#signal$1666">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="writableCorked$1614" title="Property" ><summary><span><a href="#writableCorked$1614">#</a></span>  <code><strong>writableCorked</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L777">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L777</a>  <ul><p>number</p>        </ul></details><details id="writableHighWaterMark$1613" title="Property" ><summary><span><a href="#writableHighWaterMark$1613">#</a></span>  <code><strong>writableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L776">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L776</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$1611" title="Property" ><summary><span><a href="#writableObjectMode$1611">#</a></span>  <code><strong>writableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L774">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L774</a>  <ul><p>boolean</p>        </ul></details><details id="construct$1615" title="Method" ><summary><span><a href="#construct$1615">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$1617" title="Parameter" ><summary><span><a href="#this$1617">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="callback$1618" title="Function" ><summary><span><a href="#callback$1618">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1621" title="Parameter" ><summary><span><a href="#error$1621">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$1653" title="Method" ><summary><span><a href="#destroy$1653">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$1655" title="Parameter" ><summary><span><a href="#this$1655">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="error$1656" title="Parameter" ><summary><span><a href="#error$1656">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$1657" title="Function" ><summary><span><a href="#callback$1657">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1660" title="Parameter" ><summary><span><a href="#error$1660">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="final$1646" title="Method" ><summary><span><a href="#final$1646">#</a></span>  <code><strong>final</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$1648" title="Parameter" ><summary><span><a href="#this$1648">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="callback$1649" title="Function" ><summary><span><a href="#callback$1649">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1652" title="Parameter" ><summary><span><a href="#error$1652">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>final</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="read$1622" title="Method" ><summary><span><a href="#read$1622">#</a></span>  <code><strong>read</strong></code><em>(this, size)</em>    </summary>    <ul>    <p>    <details id="this$1624" title="Parameter" ><summary><span><a href="#this$1624">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="size$1625" title="Parameter" ><summary><span><a href="#size$1625">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(this, size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="write$1626" title="Method" ><summary><span><a href="#write$1626">#</a></span>  <code><strong>write</strong></code><em>(this, chunk, encoding, callback)</em>    </summary>    <ul>    <p>    <details id="this$1628" title="Parameter" ><summary><span><a href="#this$1628">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="chunk$1629" title="Parameter" ><summary><span><a href="#chunk$1629">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1630" title="Parameter" ><summary><span><a href="#encoding$1630">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$1631" title="Function" ><summary><span><a href="#callback$1631">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1634" title="Parameter" ><summary><span><a href="#error$1634">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(this, chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="writev$1635" title="Method" ><summary><span><a href="#writev$1635">#</a></span>  <code><strong>writev</strong></code><em>(this, chunks, callback)</em>    </summary>    <ul>    <p>    <details id="this$1637" title="Parameter" ><summary><span><a href="#this$1637">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Duplex$1669">Duplex</a></p>        </ul></details><details id="chunks$1638" title="Parameter" ><summary><span><a href="#chunks$1638">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$1640" title="Property" ><summary><span><a href="#chunk$1640">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L784">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L784</a>  <ul><p>any</p>        </ul></details><details id="encoding$1641" title="Property" ><summary><span><a href="#encoding$1641">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L785">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L785</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$1642" title="Function" ><summary><span><a href="#callback$1642">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1645" title="Parameter" ><summary><span><a href="#error$1645">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>writev</strong><em>(this, chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="FinishedOptions$3210" title="Interface" ><summary><span><a href="#FinishedOptions$3210">#</a></span>  <code><strong>FinishedOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L947">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L947</a>  <ul>        <p>  <details id="error$3211" title="Property" ><summary><span><a href="#error$3211">#</a></span>  <code><strong>error</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L948">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L948</a>  <ul><p>boolean</p>        </ul></details><details id="readable$3212" title="Property" ><summary><span><a href="#readable$3212">#</a></span>  <code><strong>readable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L949">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L949</a>  <ul><p>boolean</p>        </ul></details><details id="signal$3214" title="Property" ><summary><span><a href="#signal$3214">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="writable$3213" title="Property" ><summary><span><a href="#writable$3213">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L950">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L950</a>  <ul><p>boolean</p>        </ul></details></p></ul></details><details id="Pipe$3259" title="Interface" ><summary><span><a href="#Pipe$3259">#</a></span>  <code><strong>Pipe</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1235">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1235</a>  <ul>        <p>  <details id="close$3260" title="Method" ><summary><span><a href="#close$3260">#</a></span>  <code><strong>close</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>close</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="hasRef$3262" title="Method" ><summary><span><a href="#hasRef$3262">#</a></span>  <code><strong>hasRef</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>hasRef</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="ref$3264" title="Method" ><summary><span><a href="#ref$3264">#</a></span>  <code><strong>ref</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>ref</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="unref$3266" title="Method" ><summary><span><a href="#unref$3266">#</a></span>  <code><strong>unref</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>unref</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="PipelineOptions$3257" title="Interface" ><summary><span><a href="#PipelineOptions$3257">#</a></span>  <code><strong>PipelineOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1028">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1028</a>  <ul>        <p>  <details id="signal$3258" title="Property" ><summary><span><a href="#signal$3258">#</a></span>  <code><strong>signal</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1029">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1029</a>  <ul><p><span>AbortSignal</span></p>        </ul></details></p></ul></details><details id="ReadableOptions$706" title="Interface" ><summary><span><a href="#ReadableOptions$706">#</a></span>  <code><strong>ReadableOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L43">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L43</a>  <ul>        <p>  <details id="autoDestroy$730" title="Property" ><summary><span><a href="#autoDestroy$730">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="emitClose$712" title="Property" ><summary><span><a href="#emitClose$712">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="encoding$707" title="Property" ><summary><span><a href="#encoding$707">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="highWaterMark$713" title="Property" ><summary><span><a href="#highWaterMark$713">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$714" title="Property" ><summary><span><a href="#objectMode$714">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="signal$731" title="Property" ><summary><span><a href="#signal$731">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="construct$715" title="Method" ><summary><span><a href="#construct$715">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$717" title="Parameter" ><summary><span><a href="#this$717">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="callback$718" title="Function" ><summary><span><a href="#callback$718">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$721" title="Parameter" ><summary><span><a href="#error$721">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$722" title="Method" ><summary><span><a href="#destroy$722">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$724" title="Parameter" ><summary><span><a href="#this$724">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="error$725" title="Parameter" ><summary><span><a href="#error$725">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$726" title="Function" ><summary><span><a href="#callback$726">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$729" title="Parameter" ><summary><span><a href="#error$729">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="read$708" title="Method" ><summary><span><a href="#read$708">#</a></span>  <code><strong>read</strong></code><em>(this, size)</em>    </summary>    <ul>    <p>    <details id="this$710" title="Parameter" ><summary><span><a href="#this$710">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="size$711" title="Parameter" ><summary><span><a href="#size$711">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(this, size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="StreamOptions$684" title="Interface" ><summary><span><a href="#StreamOptions$684">#</a></span>  <code><strong>StreamOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L35">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L35</a>  <ul>        <p>  <details id="autoDestroy$703" title="Property" ><summary><span><a href="#autoDestroy$703">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="emitClose$685" title="Property" ><summary><span><a href="#emitClose$685">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="highWaterMark$686" title="Property" ><summary><span><a href="#highWaterMark$686">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$687" title="Property" ><summary><span><a href="#objectMode$687">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="signal$704" title="Property" ><summary><span><a href="#signal$704">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="construct$688" title="Method" ><summary><span><a href="#construct$688">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$690" title="Parameter" ><summary><span><a href="#this$690">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#T$705">T</a></p>        </ul></details><details id="callback$691" title="Function" ><summary><span><a href="#callback$691">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$694" title="Parameter" ><summary><span><a href="#error$694">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$695" title="Method" ><summary><span><a href="#destroy$695">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$697" title="Parameter" ><summary><span><a href="#this$697">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#T$705">T</a></p>        </ul></details><details id="error$698" title="Parameter" ><summary><span><a href="#error$698">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$699" title="Function" ><summary><span><a href="#callback$699">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$702" title="Parameter" ><summary><span><a href="#error$702">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="TransformOptions$2157" title="Interface" ><summary><span><a href="#TransformOptions$2157">#</a></span>  <code><strong>TransformOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L863">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L863</a>  <ul>        <p>  <details id="allowHalfOpen$2214" title="Property" ><summary><span><a href="#allowHalfOpen$2214">#</a></span>  <code><strong>allowHalfOpen</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L772">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L772</a>  <ul><p>boolean</p>        </ul></details><details id="autoDestroy$2224" title="Property" ><summary><span><a href="#autoDestroy$2224">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="decodeStrings$2226" title="Property" ><summary><span><a href="#decodeStrings$2226">#</a></span>  <code><strong>decodeStrings</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482</a>  <ul><p>boolean</p>        </ul></details><details id="defaultEncoding$2227" title="Property" ><summary><span><a href="#defaultEncoding$2227">#</a></span>  <code><strong>defaultEncoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="emitClose$2221" title="Property" ><summary><span><a href="#emitClose$2221">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="encoding$2220" title="Property" ><summary><span><a href="#encoding$2220">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="highWaterMark$2222" title="Property" ><summary><span><a href="#highWaterMark$2222">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$2223" title="Property" ><summary><span><a href="#objectMode$2223">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="readableHighWaterMark$2217" title="Property" ><summary><span><a href="#readableHighWaterMark$2217">#</a></span>  <code><strong>readableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L775">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L775</a>  <ul><p>number</p>        </ul></details><details id="readableObjectMode$2215" title="Property" ><summary><span><a href="#readableObjectMode$2215">#</a></span>  <code><strong>readableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L773">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L773</a>  <ul><p>boolean</p>        </ul></details><details id="signal$2225" title="Property" ><summary><span><a href="#signal$2225">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="writableCorked$2219" title="Property" ><summary><span><a href="#writableCorked$2219">#</a></span>  <code><strong>writableCorked</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L777">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L777</a>  <ul><p>number</p>        </ul></details><details id="writableHighWaterMark$2218" title="Property" ><summary><span><a href="#writableHighWaterMark$2218">#</a></span>  <code><strong>writableHighWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L776">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L776</a>  <ul><p>number</p>        </ul></details><details id="writableObjectMode$2216" title="Property" ><summary><span><a href="#writableObjectMode$2216">#</a></span>  <code><strong>writableObjectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L774">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L774</a>  <ul><p>boolean</p>        </ul></details><details id="construct$2158" title="Method" ><summary><span><a href="#construct$2158">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$2160" title="Parameter" ><summary><span><a href="#this$2160">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="callback$2161" title="Function" ><summary><span><a href="#callback$2161">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2164" title="Parameter" ><summary><span><a href="#error$2164">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$2196" title="Method" ><summary><span><a href="#destroy$2196">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$2198" title="Parameter" ><summary><span><a href="#this$2198">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="error$2199" title="Parameter" ><summary><span><a href="#error$2199">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$2200" title="Function" ><summary><span><a href="#callback$2200">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2203" title="Parameter" ><summary><span><a href="#error$2203">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="final$2189" title="Method" ><summary><span><a href="#final$2189">#</a></span>  <code><strong>final</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$2191" title="Parameter" ><summary><span><a href="#this$2191">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="callback$2192" title="Function" ><summary><span><a href="#callback$2192">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2195" title="Parameter" ><summary><span><a href="#error$2195">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>final</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="flush$2210" title="Method" ><summary><span><a href="#flush$2210">#</a></span>  <code><strong>flush</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$2212" title="Parameter" ><summary><span><a href="#this$2212">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="callback$2213" title="Parameter" ><summary><span><a href="#callback$2213">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>flush</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="read$2165" title="Method" ><summary><span><a href="#read$2165">#</a></span>  <code><strong>read</strong></code><em>(this, size)</em>    </summary>    <ul>    <p>    <details id="this$2167" title="Parameter" ><summary><span><a href="#this$2167">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="size$2168" title="Parameter" ><summary><span><a href="#size$2168">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(this, size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="transform$2204" title="Method" ><summary><span><a href="#transform$2204">#</a></span>  <code><strong>transform</strong></code><em>(this, chunk, encoding, callback)</em>    </summary>    <ul>    <p>    <details id="this$2206" title="Parameter" ><summary><span><a href="#this$2206">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="chunk$2207" title="Parameter" ><summary><span><a href="#chunk$2207">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2208" title="Parameter" ><summary><span><a href="#encoding$2208">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2209" title="Parameter" ><summary><span><a href="#callback$2209">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#TransformCallback$2152">TransformCallback</a></p>        </ul></details>  <p><strong>transform</strong><em>(this, chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="write$2169" title="Method" ><summary><span><a href="#write$2169">#</a></span>  <code><strong>write</strong></code><em>(this, chunk, encoding, callback)</em>    </summary>    <ul>    <p>    <details id="this$2171" title="Parameter" ><summary><span><a href="#this$2171">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="chunk$2172" title="Parameter" ><summary><span><a href="#chunk$2172">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$2173" title="Parameter" ><summary><span><a href="#encoding$2173">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$2174" title="Function" ><summary><span><a href="#callback$2174">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2177" title="Parameter" ><summary><span><a href="#error$2177">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(this, chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="writev$2178" title="Method" ><summary><span><a href="#writev$2178">#</a></span>  <code><strong>writev</strong></code><em>(this, chunks, callback)</em>    </summary>    <ul>    <p>    <details id="this$2180" title="Parameter" ><summary><span><a href="#this$2180">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Transform$2228">Transform</a></p>        </ul></details><details id="chunks$2181" title="Parameter" ><summary><span><a href="#chunks$2181">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$2183" title="Property" ><summary><span><a href="#chunk$2183">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L870">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L870</a>  <ul><p>any</p>        </ul></details><details id="encoding$2184" title="Property" ><summary><span><a href="#encoding$2184">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L871">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L871</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$2185" title="Function" ><summary><span><a href="#callback$2185">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$2188" title="Parameter" ><summary><span><a href="#error$2188">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>writev</strong><em>(this, chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="WritableOptions$1147" title="Interface" ><summary><span><a href="#WritableOptions$1147">#</a></span>  <code><strong>WritableOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L481">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L481</a>  <ul>        <p>  <details id="autoDestroy$1195" title="Property" ><summary><span><a href="#autoDestroy$1195">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="decodeStrings$1148" title="Property" ><summary><span><a href="#decodeStrings$1148">#</a></span>  <code><strong>decodeStrings</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L482</a>  <ul><p>boolean</p>        </ul></details><details id="defaultEncoding$1149" title="Property" ><summary><span><a href="#defaultEncoding$1149">#</a></span>  <code><strong>defaultEncoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L483</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="emitClose$1177" title="Property" ><summary><span><a href="#emitClose$1177">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="highWaterMark$1178" title="Property" ><summary><span><a href="#highWaterMark$1178">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$1179" title="Property" ><summary><span><a href="#objectMode$1179">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="signal$1196" title="Property" ><summary><span><a href="#signal$1196">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="construct$1180" title="Method" ><summary><span><a href="#construct$1180">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$1182" title="Parameter" ><summary><span><a href="#this$1182">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>        </ul></details><details id="callback$1183" title="Function" ><summary><span><a href="#callback$1183">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1186" title="Parameter" ><summary><span><a href="#error$1186">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$1187" title="Method" ><summary><span><a href="#destroy$1187">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$1189" title="Parameter" ><summary><span><a href="#this$1189">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>        </ul></details><details id="error$1190" title="Parameter" ><summary><span><a href="#error$1190">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$1191" title="Function" ><summary><span><a href="#callback$1191">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1194" title="Parameter" ><summary><span><a href="#error$1194">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="final$1170" title="Method" ><summary><span><a href="#final$1170">#</a></span>  <code><strong>final</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$1172" title="Parameter" ><summary><span><a href="#this$1172">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>        </ul></details><details id="callback$1173" title="Function" ><summary><span><a href="#callback$1173">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1176" title="Parameter" ><summary><span><a href="#error$1176">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>final</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="write$1150" title="Method" ><summary><span><a href="#write$1150">#</a></span>  <code><strong>write</strong></code><em>(this, chunk, encoding, callback)</em>    </summary>    <ul>    <p>    <details id="this$1152" title="Parameter" ><summary><span><a href="#this$1152">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>        </ul></details><details id="chunk$1153" title="Parameter" ><summary><span><a href="#chunk$1153">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>any</p>        </ul></details><details id="encoding$1154" title="Parameter" ><summary><span><a href="#encoding$1154">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="callback$1155" title="Function" ><summary><span><a href="#callback$1155">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1158" title="Parameter" ><summary><span><a href="#error$1158">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(this, chunk, encoding, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="writev$1159" title="Method" ><summary><span><a href="#writev$1159">#</a></span>  <code><strong>writev</strong></code><em>(this, chunks, callback)</em>    </summary>    <ul>    <p>    <details id="this$1161" title="Parameter" ><summary><span><a href="#this$1161">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Writable$1197">Writable</a></p>        </ul></details><details id="chunks$1162" title="Parameter" ><summary><span><a href="#chunks$1162">#</a></span>  <code><strong>chunks</strong></code>    </summary>    <ul><p>{<p>  <details id="chunk$1164" title="Property" ><summary><span><a href="#chunk$1164">#</a></span>  <code><strong>chunk</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L488">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L488</a>  <ul><p>any</p>        </ul></details><details id="encoding$1165" title="Property" ><summary><span><a href="#encoding$1165">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L489">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L489</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>}  []</p>        </ul></details><details id="callback$1166" title="Function" ><summary><span><a href="#callback$1166">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$1169" title="Parameter" ><summary><span><a href="#error$1169">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>writev</strong><em>(this, chunks, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details><details id="PipelineCallback$3246" title="TypeAlias" ><summary><span><a href="#PipelineCallback$3246">#</a></span>  <code><strong>PipelineCallback</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1024">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1024</a>  <ul><p><a href="#S$3254">S</a> extends <a href="#PipelineDestinationPromiseFunction$3237">PipelineDestinationPromiseFunction</a>&lt;any, inferred&gt; ? <details id="__type$3247" title="Function" ><summary><span><a href="#__type$3247">#</a></span>  <em>(err, value)</em>    </summary>    <ul>    <p>    <details id="err$3249" title="Parameter" ><summary><span><a href="#err$3249">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><a href="#NodeJS.ErrnoException$4245">NodeJS.ErrnoException</a> | <code>null</code></p>        </ul></details><details id="value$3250" title="Parameter" ><summary><span><a href="#value$3250">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p><span>P</span></p>        </ul></details>  <p><strong></strong><em>(err, value)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details> : <details id="__type$3251" title="Function" ><summary><span><a href="#__type$3251">#</a></span>  <em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3253" title="Parameter" ><summary><span><a href="#err$3253">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><a href="#NodeJS.ErrnoException$4245">NodeJS.ErrnoException</a> | <code>null</code></p>        </ul></details>  <p><strong></strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p>        </ul></details><details id="PipelineDestination$3243" title="TypeAlias" ><summary><span><a href="#PipelineDestination$3243">#</a></span>  <code><strong>PipelineDestination</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1021">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1021</a>  <ul><p><a href="#S$3244">S</a> extends <a href="#PipelineTransformSource$3230">PipelineTransformSource</a>&lt;inferred&gt; ? <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> | <a href="#PipelineDestinationIterableFunction$3232">PipelineDestinationIterableFunction</a>&lt;<span>ST</span>&gt; | <a href="#PipelineDestinationPromiseFunction$3237">PipelineDestinationPromiseFunction</a>&lt;<span>ST</span>, <a href="#P$3245">P</a>&gt; : never</p>        </ul></details><details id="PipelineDestinationIterableFunction$3232" title="TypeAlias" ><summary><span><a href="#PipelineDestinationIterableFunction$3232">#</a></span>  <code><strong>PipelineDestinationIterableFunction</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1019">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1019</a>  <ul><p><details id="__type$3233" title="Function" ><summary><span><a href="#__type$3233">#</a></span>  <em>(source)</em>    </summary>    <ul>    <p>    <details id="source$3235" title="Parameter" ><summary><span><a href="#source$3235">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><span>AsyncIterable</span>&lt;<a href="#T$3236">T</a>&gt;</p>        </ul></details>  <p><strong></strong><em>(source)</em>  &nbsp;=&gt;  <ul><span>AsyncIterable</span>&lt;any&gt;</ul></p></p>    </ul></details></p>        </ul></details><details id="PipelineDestinationPromiseFunction$3237" title="TypeAlias" ><summary><span><a href="#PipelineDestinationPromiseFunction$3237">#</a></span>  <code><strong>PipelineDestinationPromiseFunction</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1020">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1020</a>  <ul><p><details id="__type$3238" title="Function" ><summary><span><a href="#__type$3238">#</a></span>  <em>(source)</em>    </summary>    <ul>    <p>    <details id="source$3240" title="Parameter" ><summary><span><a href="#source$3240">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><span>AsyncIterable</span>&lt;<a href="#T$3241">T</a>&gt;</p>        </ul></details>  <p><strong></strong><em>(source)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<a href="#P$3242">P</a>&gt;</ul></p></p>    </ul></details></p>        </ul></details><details id="PipelinePromise$3255" title="TypeAlias" ><summary><span><a href="#PipelinePromise$3255">#</a></span>  <code><strong>PipelinePromise</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1027">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1027</a>  <ul><p><a href="#S$3256">S</a> extends <a href="#PipelineDestinationPromiseFunction$3237">PipelineDestinationPromiseFunction</a>&lt;any, inferred&gt; ? <span>Promise</span>&lt;<span>P</span>&gt; : <span>Promise</span>&lt;void&gt;</p>        </ul></details><details id="PipelineSource$3219" title="TypeAlias" ><summary><span><a href="#PipelineSource$3219">#</a></span>  <code><strong>PipelineSource</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1014">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1014</a>  <ul><p><span>Iterable</span>&lt;<a href="#T$3220">T</a>&gt; | <span>AsyncIterable</span>&lt;<a href="#T$3220">T</a>&gt; | <a href="#NodeJS.ReadableStream$3609">NodeJS.ReadableStream</a> | <a href="#PipelineSourceFunction$3215">PipelineSourceFunction</a>&lt;<a href="#T$3220">T</a>&gt;</p>        </ul></details><details id="PipelineSourceFunction$3215" title="TypeAlias" ><summary><span><a href="#PipelineSourceFunction$3215">#</a></span>  <code><strong>PipelineSourceFunction</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1013">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1013</a>  <ul><p><details id="__type$3216" title="Function" ><summary><span><a href="#__type$3216">#</a></span>  <em>()</em>    </summary>    <ul>    <p>      <p><strong></strong><em>()</em>  &nbsp;=&gt;  <ul><span>Iterable</span>&lt;<a href="#T$3218">T</a>&gt; | <span>AsyncIterable</span>&lt;<a href="#T$3218">T</a>&gt;</ul></p></p>    </ul></details></p>        </ul></details><details id="PipelineTransform$3221" title="TypeAlias" ><summary><span><a href="#PipelineTransform$3221">#</a></span>  <code><strong>PipelineTransform</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1015">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1015</a>  <ul><p><a href="#NodeJS.ReadWriteStream$3714">NodeJS.ReadWriteStream</a> | <details id="__type$3222" title="Function" ><summary><span><a href="#__type$3222">#</a></span>  <em>(source)</em>    </summary>    <ul>    <p>    <details id="source$3224" title="Parameter" ><summary><span><a href="#source$3224">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#S$3228">S</a> extends <details id="__type$3225" title="Function" ><summary><span><a href="#__type$3225">#</a></span>  <em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3227" title="Parameter" ><summary><span><a href="#args$3227">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong></strong><em>(args)</em>  &nbsp;=&gt;  <ul><span>Iterable</span>&lt;inferred&gt; | <span>AsyncIterable</span>&lt;inferred&gt;</ul></p></p>    </ul></details> ? <span>AsyncIterable</span>&lt;<span>ST</span>&gt; : <a href="#S$3228">S</a></p>        </ul></details>  <p><strong></strong><em>(source)</em>  &nbsp;=&gt;  <ul><span>AsyncIterable</span>&lt;<a href="#U$3229">U</a>&gt;</ul></p></p>    </ul></details></p>        </ul></details><details id="PipelineTransformSource$3230" title="TypeAlias" ><summary><span><a href="#PipelineTransformSource$3230">#</a></span>  <code><strong>PipelineTransformSource</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1018">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1018</a>  <ul><p><a href="#PipelineSource$3219">PipelineSource</a>&lt;<a href="#T$3231">T</a>&gt; | <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;any, <a href="#T$3231">T</a>&gt;</p>        </ul></details><details id="TransformCallback$2152" title="TypeAlias" ><summary><span><a href="#TransformCallback$2152">#</a></span>  <code><strong>TransformCallback</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L862">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L862</a>  <ul><p><details id="__type$2153" title="Function" ><summary><span><a href="#__type$2153">#</a></span>  <em>(error, data)</em>    </summary>    <ul>    <p>    <details id="error$2155" title="Parameter" ><summary><span><a href="#error$2155">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><span>Error</span> | <code>null</code></p>        </ul></details><details id="data$2156" title="Parameter" ><summary><span><a href="#data$2156">#</a></span>  <code><strong>data</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong></strong><em>(error, data)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p>        </ul></details><details id="consumers$3269" title="Variable" ><summary><span><a href="#consumers$3269">#</a></span>  <code><strong>consumers</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1242">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1242</a>  <ul><p>typeof   <a href="#streamConsumers$3913">streamConsumers</a></p>        </ul></details><details id="promises$3268" title="Variable" ><summary><span><a href="#promises$3268">#</a></span>  <code><strong>promises</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1241">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1241</a>  <ul><p>typeof   <a href="#streamPromises$3850">streamPromises</a></p>        </ul></details><details id="addAbortSignal$420" title="Function" ><summary><span><a href="#addAbortSignal$420">#</a></span>  <code><strong>addAbortSignal</strong></code><em>(signal, stream)</em>     &ndash; Attaches an AbortSignal to a readable or writeable stream. This lets code
control stream destruction using an <code>AbortController</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L946">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L946</a>  <ul>    <p>  <p>

Calling `abort` on the `AbortController` corresponding to the passed`AbortSignal` will behave the same way as calling `.destroy(new AbortError())`on the stream.

```js
const fs = require('fs')

const controller = new AbortController()
const read = addAbortSignal(
  controller.signal,
  fs.createReadStream('object.json')
)
// Later, abort the operation closing the stream
controller.abort()
```

Or using an `AbortSignal` with a readable stream as an async iterable:

```js
const controller = new AbortController()
setTimeout(() => controller.abort(), 10_000) // set a timeout
const stream = addAbortSignal(
  controller.signal,
  fs.createReadStream('object.json')
)
;(async () => {
  try {
    for await (const chunk of stream) {
      await process(chunk)
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      // The operation was cancelled
    } else {
      throw e
    }
  }
})()
```

</p>
  <details id="signal$423" title="Parameter" ><summary><span><a href="#signal$423">#</a></span>  <code><strong>signal</strong></code>     &ndash; A signal representing possible cancellation</summary>    <ul><p><span>AbortSignal</span></p>        </ul></details><details id="stream$424" title="Parameter" ><summary><span><a href="#stream$424">#</a></span>  <code><strong>stream</strong></code>     &ndash; a stream to attach a signal to
</summary>    <ul><p><a href="#T$422">T</a></p>        </ul></details>  <p><strong>addAbortSignal</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#Stream$119">Stream</a>&lt;<a href="#T$422">T</a>&gt;&gt;<em>(signal, stream)</em>  &nbsp;=&gt;  <ul><a href="#T$422">T</a></ul></p></p>    </ul></details><details id="finished$425" title="Function" ><summary><span><a href="#finished$425">#</a></span>  <code><strong>finished</strong></code><em>(stream, options, callback)</em>     &ndash; A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1008">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1008</a>  <ul>    <p>  <p>

```js
const { finished } = require('stream')

const rs = fs.createReadStream('archive.tar')

finished(rs, err => {
  if (err) {
    console.error('Stream failed.', err)
  } else {
    console.log('Stream is done reading.')
  }
})

rs.resume() // Drain the stream.
```

Especially useful in error handling scenarios where a stream is destroyed
prematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.

The `finished` API provides promise version:

```js
const { finished } = require('stream/promises')

const rs = fs.createReadStream('archive.tar')

async function run() {
  await finished(rs)
  console.log('Stream is done reading.')
}

run().catch(console.error)
rs.resume() // Drain the stream.
```

`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been
invoked. The reason for this is so that unexpected `'error'` events (due to
incorrect stream implementations) do not cause unexpected crashes.
If this is unwanted behavior then the returned cleanup function needs to be
invoked in the callback:

```js
const cleanup = finished(rs, err => {
  cleanup()
  // ...
})
```

</p>
  <details id="stream$427" title="Parameter" ><summary><span><a href="#stream$427">#</a></span>  <code><strong>stream</strong></code>     &ndash; A readable and/or writable stream.</summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="options$428" title="Parameter" ><summary><span><a href="#options$428">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#FinishedOptions$3210">FinishedOptions</a></p>        </ul></details><details id="callback$429" title="Function" ><summary><span><a href="#callback$429">#</a></span>  <code><strong>callback</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$432" title="Parameter" ><summary><span><a href="#err$432">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <a href="#ErrnoException$4245">ErrnoException</a></p>        </ul></details>  <p><strong>callback</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>finished</strong><em>(stream, options, callback)</em>  &nbsp;=&gt;  <ul><details id="__type$433" title="Function" ><summary><span><a href="#__type$433">#</a></span>  <em>()</em>     &ndash; A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.</summary>    <ul>    <p>  <p>

```js
const { finished } = require('stream')

const rs = fs.createReadStream('archive.tar')

finished(rs, err => {
  if (err) {
    console.error('Stream failed.', err)
  } else {
    console.log('Stream is done reading.')
  }
})

rs.resume() // Drain the stream.
```

Especially useful in error handling scenarios where a stream is destroyed
prematurely (like an aborted HTTP request), and will not emit `'end'`or `'finish'`.

The `finished` API provides promise version:

```js
const { finished } = require('stream/promises')

const rs = fs.createReadStream('archive.tar')

async function run() {
  await finished(rs)
  console.log('Stream is done reading.')
}

run().catch(console.error)
rs.resume() // Drain the stream.
```

`stream.finished()` leaves dangling event listeners (in particular`'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been
invoked. The reason for this is so that unexpected `'error'` events (due to
incorrect stream implementations) do not cause unexpected crashes.
If this is unwanted behavior then the returned cleanup function needs to be
invoked in the callback:

```js
const cleanup = finished(rs, err => {
  cleanup()
  // ...
})
```

</p>
    <p><strong></strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></ul></p>  <details id="stream$436" title="Parameter" ><summary><span><a href="#stream$436">#</a></span>  <code><strong>stream</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="callback$437" title="Function" ><summary><span><a href="#callback$437">#</a></span>  <code><strong>callback</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$440" title="Parameter" ><summary><span><a href="#err$440">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <a href="#ErrnoException$4245">ErrnoException</a></p>        </ul></details>  <p><strong>callback</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>finished</strong><em>(stream, callback)</em>  &nbsp;=&gt;  <ul><details id="__type$441" title="Function" ><summary><span><a href="#__type$441">#</a></span>  <em>()</em>    </summary>    <ul>    <p>      <p><strong></strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></ul></p></p>    </ul></details><details id="pipeline$448" title="Function" ><summary><span><a href="#pipeline$448">#</a></span>  <code><strong>pipeline</strong></code><em>(source, destination, callback)</em>     &ndash; A module method to pipe between streams and generators forwarding errors and
properly cleaning up and provide a callback when the pipeline is complete.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1156">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L1156</a>  <ul>    <p>  <p>

```js
const { pipeline } = require('stream')
const fs = require('fs')
const zlib = require('zlib')

// Use the pipeline API to easily pipe a series of streams
// together and get notified when the pipeline is fully done.

// A pipeline to gzip a potentially huge tar file efficiently:

pipeline(
  fs.createReadStream('archive.tar'),
  zlib.createGzip(),
  fs.createWriteStream('archive.tar.gz'),
  err => {
    if (err) {
      console.error('Pipeline failed.', err)
    } else {
      console.log('Pipeline succeeded.')
    }
  }
)
```

The `pipeline` API provides a promise version, which can also
receive an options argument as the last parameter with a`signal` `AbortSignal` property. When the signal is aborted,`destroy` will be called on the underlying pipeline, with
an`AbortError`.

```js
const { pipeline } = require('stream/promises')

async function run() {
  await pipeline(
    fs.createReadStream('archive.tar'),
    zlib.createGzip(),
    fs.createWriteStream('archive.tar.gz')
  )
  console.log('Pipeline succeeded.')
}

run().catch(console.error)
```

To use an `AbortSignal`, pass it inside an options object,
as the last argument:

```js
const { pipeline } = require('stream/promises')

async function run() {
  const ac = new AbortController()
  const signal = ac.signal

  setTimeout(() => ac.abort(), 1)
  await pipeline(
    fs.createReadStream('archive.tar'),
    zlib.createGzip(),
    fs.createWriteStream('archive.tar.gz'),
    { signal }
  )
}

run().catch(console.error) // AbortError
```

The `pipeline` API also supports async generators:

```js
const { pipeline } = require('stream/promises')
const fs = require('fs')

async function run() {
  await pipeline(
    fs.createReadStream('lowercase.txt'),
    async function*(source, signal) {
      source.setEncoding('utf8') // Work with strings rather than `Buffer`s.
      for await (const chunk of source) {
        yield await processChunk(chunk, { signal })
      }
    },
    fs.createWriteStream('uppercase.txt')
  )
  console.log('Pipeline succeeded.')
}

run().catch(console.error)
```

Remember to handle the `signal` argument passed into the async generator.
Especially in the case where the async generator is the source for the
pipeline (i.e. first argument) or the pipeline will never complete.

```js
const { pipeline } = require('stream/promises')
const fs = require('fs')

async function run() {
  await pipeline(
    async function*(signal) {
      await someLongRunningfn({ signal })
      yield 'asd'
    },
    fs.createWriteStream('uppercase.txt')
  )
  console.log('Pipeline succeeded.')
}

run().catch(console.error)
```

`stream.pipeline()` will call `stream.destroy(err)` on all streams except:

- `Readable` streams which have emitted `'end'` or `'close'`.
- `Writable` streams which have emitted `'finish'` or `'close'`.

`stream.pipeline()` leaves dangling event listeners on the streams
after the `callback` has been invoked. In the case of reuse of streams after
failure, this can cause event listener leaks and swallowed errors.

</p>
  <details id="source$452" title="Parameter" ><summary><span><a href="#source$452">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$450">A</a></p>        </ul></details><details id="destination$453" title="Parameter" ><summary><span><a href="#destination$453">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$451">B</a></p>        </ul></details><details id="callback$454" title="Parameter" ><summary><span><a href="#callback$454">#</a></span>  <code><strong>callback</strong></code>     &ndash; Called when the pipeline is fully done.
</summary>    <ul><p><a href="#PipelineCallback$3246">PipelineCallback</a>&lt;<a href="#B$451">B</a>&gt;</p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>B</span>&gt;<em>(source, destination, callback)</em>  &nbsp;=&gt;  <ul><a href="#B$451">B</a> extends <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> ? <a href="#B$451">B</a> : <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="source$459" title="Parameter" ><summary><span><a href="#source$459">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$456">A</a></p>        </ul></details><details id="transform1$460" title="Parameter" ><summary><span><a href="#transform1$460">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$457">T1</a></p>        </ul></details><details id="destination$461" title="Parameter" ><summary><span><a href="#destination$461">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$458">B</a></p>        </ul></details><details id="callback$462" title="Parameter" ><summary><span><a href="#callback$462">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#PipelineCallback$3246">PipelineCallback</a>&lt;<a href="#B$458">B</a>&gt;</p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$456">A</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, destination, callback)</em>  &nbsp;=&gt;  <ul><a href="#B$458">B</a> extends <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> ? <a href="#B$458">B</a> : <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="source$468" title="Parameter" ><summary><span><a href="#source$468">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$464">A</a></p>        </ul></details><details id="transform1$469" title="Parameter" ><summary><span><a href="#transform1$469">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$465">T1</a></p>        </ul></details><details id="transform2$470" title="Parameter" ><summary><span><a href="#transform2$470">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$466">T2</a></p>        </ul></details><details id="destination$471" title="Parameter" ><summary><span><a href="#destination$471">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$467">B</a></p>        </ul></details><details id="callback$472" title="Parameter" ><summary><span><a href="#callback$472">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#PipelineCallback$3246">PipelineCallback</a>&lt;<a href="#B$467">B</a>&gt;</p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$464">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$465">T1</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, destination, callback)</em>  &nbsp;=&gt;  <ul><a href="#B$467">B</a> extends <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> ? <a href="#B$467">B</a> : <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="source$479" title="Parameter" ><summary><span><a href="#source$479">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$474">A</a></p>        </ul></details><details id="transform1$480" title="Parameter" ><summary><span><a href="#transform1$480">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$475">T1</a></p>        </ul></details><details id="transform2$481" title="Parameter" ><summary><span><a href="#transform2$481">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$476">T2</a></p>        </ul></details><details id="transform3$482" title="Parameter" ><summary><span><a href="#transform3$482">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$477">T3</a></p>        </ul></details><details id="destination$483" title="Parameter" ><summary><span><a href="#destination$483">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$478">B</a></p>        </ul></details><details id="callback$484" title="Parameter" ><summary><span><a href="#callback$484">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#PipelineCallback$3246">PipelineCallback</a>&lt;<a href="#B$478">B</a>&gt;</p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$474">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$475">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$476">T2</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, destination, callback)</em>  &nbsp;=&gt;  <ul><a href="#B$478">B</a> extends <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> ? <a href="#B$478">B</a> : <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="source$492" title="Parameter" ><summary><span><a href="#source$492">#</a></span>  <code><strong>source</strong></code>    </summary>    <ul><p><a href="#A$486">A</a></p>        </ul></details><details id="transform1$493" title="Parameter" ><summary><span><a href="#transform1$493">#</a></span>  <code><strong>transform1</strong></code>    </summary>    <ul><p><a href="#T1$487">T1</a></p>        </ul></details><details id="transform2$494" title="Parameter" ><summary><span><a href="#transform2$494">#</a></span>  <code><strong>transform2</strong></code>    </summary>    <ul><p><a href="#T2$488">T2</a></p>        </ul></details><details id="transform3$495" title="Parameter" ><summary><span><a href="#transform3$495">#</a></span>  <code><strong>transform3</strong></code>    </summary>    <ul><p><a href="#T3$489">T3</a></p>        </ul></details><details id="transform4$496" title="Parameter" ><summary><span><a href="#transform4$496">#</a></span>  <code><strong>transform4</strong></code>    </summary>    <ul><p><a href="#T4$490">T4</a></p>        </ul></details><details id="destination$497" title="Parameter" ><summary><span><a href="#destination$497">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#B$491">B</a></p>        </ul></details><details id="callback$498" title="Parameter" ><summary><span><a href="#callback$498">#</a></span>  <code><strong>callback</strong></code>    </summary>    <ul><p><a href="#PipelineCallback$3246">PipelineCallback</a>&lt;<a href="#B$491">B</a>&gt;</p>        </ul></details>  <p><strong>pipeline</strong>&lt;<span>A</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineSource$3219">PipelineSource</a>&lt;any&gt;, <span>T1</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#A$486">A</a>, any&gt;, <span>T2</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T1$487">T1</a>, any&gt;, <span>T3</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T2$488">T2</a>, any&gt;, <span>T4</span><span>&nbsp;extends&nbsp;</span>     <a href="#PipelineTransform$3221">PipelineTransform</a>&lt;<a href="#T3$489">T3</a>, any&gt;, <span>B</span>&gt;<em>(source, transform1, transform2, transform3, transform4, destination, callback)</em>  &nbsp;=&gt;  <ul><a href="#B$491">B</a> extends <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a> ? <a href="#B$491">B</a> : <a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="streams$500" title="Parameter" ><summary><span><a href="#streams$500">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p>readonly     <a href="#ReadableStream$3609">ReadableStream</a> | <a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a>  []</p>        </ul></details><details id="callback$501" title="Function" ><summary><span><a href="#callback$501">#</a></span>  <code><strong>callback</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$504" title="Parameter" ><summary><span><a href="#err$504">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <a href="#ErrnoException$4245">ErrnoException</a></p>        </ul></details>  <p><strong>callback</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>pipeline</strong><em>(streams, callback)</em>  &nbsp;=&gt;  <ul><a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p>  <details id="stream1$506" title="Parameter" ><summary><span><a href="#stream1$506">#</a></span>  <code><strong>stream1</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details><details id="stream2$507" title="Parameter" ><summary><span><a href="#stream2$507">#</a></span>  <code><strong>stream2</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a></p>        </ul></details><details id="streams$508" title="Parameter" ><summary><span><a href="#streams$508">#</a></span>  <code><strong>streams</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a> | <a href="#ReadWriteStream$3714">ReadWriteStream</a> | <details id="__type$509" title="Function" ><summary><span><a href="#__type$509">#</a></span>  <em>(err)</em>    </summary>    <ul>    <p>    <details id="err$511" title="Parameter" ><summary><span><a href="#err$511">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <a href="#ErrnoException$4245">ErrnoException</a></p>        </ul></details>  <p><strong></strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  []</p>        </ul></details>  <p><strong>pipeline</strong><em>(stream1, stream2, streams)</em>  &nbsp;=&gt;  <ul><a href="#NodeJS.WritableStream$3390">NodeJS.WritableStream</a></ul></p></p>    </ul></details></p></ul></details>  <details id="Blob$283" title="Class" ><summary><span><a href="#Blob$283">#</a></span>  <code><strong>Blob</strong></code>     &ndash; A <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob"><code>Blob</code></a> encapsulates immutable, raw data that can be safely shared across
multiple worker threads.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L119">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L119</a>  <ul>        <p>  <details id="constructor$284" title="Constructor" ><summary><span><a href="#constructor$284">#</a></span>  <code><strong>constructor</strong></code><em>(sources, options)</em>     &ndash; Creates a new <code>Blob</code> object containing a concatenation of the given sources.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L138">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L138</a>  <ul>    <p>  <details id="new Blob$285" title="ConstructorSignature" ><summary><span><a href="#new Blob$285">#</a></span>  <code><strong>new Blob</strong></code><em>()</em>     &ndash; Creates a new <code>Blob</code> object containing a concatenation of the given sources.</summary>    <ul><p><a href="#Blob$283">Blob</a></p>  <p>

{ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into
the 'Blob' and can therefore be safely modified after the 'Blob' is created.

String sources are also copied into the `Blob`.

</p>
    <p>  <details id="sources$286" title="Parameter" ><summary><span><a href="#sources$286">#</a></span>  <code><strong>sources</strong></code>    </summary>    <ul><p><a href="#Blob$283">Blob</a> | <a href="#BinaryLike$3494">BinaryLike</a>  []</p>        </ul></details><details id="options$287" title="Parameter" ><summary><span><a href="#options$287">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#BlobOptions$3495">BlobOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="size$288" title="Property" ><summary><span><a href="#size$288">#</a></span>  <code><strong>size</strong></code>     &ndash; The total size of the <code>Blob</code> in bytes.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L124">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L124</a>  <ul><p>number</p>        </ul></details><details id="type$289" title="Property" ><summary><span><a href="#type$289">#</a></span>  <code><strong>type</strong></code>     &ndash; The content-type of the <code>Blob</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L129">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L129</a>  <ul><p>string</p>        </ul></details><details id="arrayBuffer$290" title="Method" ><summary><span><a href="#arrayBuffer$290">#</a></span>  <code><strong>arrayBuffer</strong></code><em>()</em>     &ndash; Returns a promise that fulfills with an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a> containing a copy of
the <code>Blob</code> data.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L144">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L144</a>  <ul>    <p>      <p><strong>arrayBuffer</strong><em>()</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<span>ArrayBuffer</span>&gt;</ul></p></p>    </ul></details><details id="slice$292" title="Method" ><summary><span><a href="#slice$292">#</a></span>  <code><strong>slice</strong></code><em>(start, end, type)</em>     &ndash; Creates and returns a new <code>Blob</code> containing a subset of this <code>Blob</code> objects
data. The original <code>Blob</code> is not altered.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L153">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L153</a>  <ul>    <p>    <details id="start$294" title="Parameter" ><summary><span><a href="#start$294">#</a></span>  <code><strong>start</strong></code>     &ndash; The starting index.</summary>    <ul><p>number</p>        </ul></details><details id="end$295" title="Parameter" ><summary><span><a href="#end$295">#</a></span>  <code><strong>end</strong></code>     &ndash; The ending index.</summary>    <ul><p>number</p>        </ul></details><details id="type$296" title="Parameter" ><summary><span><a href="#type$296">#</a></span>  <code><strong>type</strong></code>     &ndash; The content-type for the new <code>Blob</code>
</summary>    <ul><p>string</p>        </ul></details>  <p><strong>slice</strong><em>(start, end, type)</em>  &nbsp;=&gt;  <ul><a href="#Blob$283">Blob</a></ul></p></p>    </ul></details><details id="stream$299" title="Method" ><summary><span><a href="#stream$299">#</a></span>  <code><strong>stream</strong></code><em>()</em>     &ndash; Returns a new <code>ReadableStream</code> that allows the content of the <code>Blob</code> to be read.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L164">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L164</a>  <ul>    <p>      <p><strong>stream</strong><em>()</em>  &nbsp;=&gt;  <ul>unknown</ul></p></p>    </ul></details><details id="text$297" title="Method" ><summary><span><a href="#text$297">#</a></span>  <code><strong>text</strong></code><em>()</em>     &ndash; Returns a promise that fulfills with the contents of the <code>Blob</code> decoded as a
UTF-8 string.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L159">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L159</a>  <ul>    <p>      <p><strong>text</strong><em>()</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;string&gt;</ul></p></p>    </ul></details></p></ul></details>  <details id="EventEmitter$3498" title="Class" ><summary><span><a href="#EventEmitter$3498">#</a></span>  <code><strong>EventEmitter</strong></code>     &ndash; The <code>EventEmitter</code> class is defined and exposed by the <code>events</code> module:</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L73">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L73</a>  <ul>  <p>

```js
const EventEmitter = require('events')
```

All `EventEmitter`s emit the event `'newListener'` when new listeners are
added and `'removeListener'` when existing listeners are removed.

It supports the following option:

</p>
      <p>  <details id="constructor$3529" title="Constructor" ><summary><span><a href="#constructor$3529">#</a></span>  <code><strong>constructor</strong></code><em>(options)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L74">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L74</a>  <ul>    <p>  <details id="new EventEmitter$3530" title="ConstructorSignature" ><summary><span><a href="#new EventEmitter$3530">#</a></span>  <code><strong>new EventEmitter</strong></code><em>()</em>    </summary>    <ul><p><a href="#EventEmitter$3498">EventEmitter</a></p>      <p>  <details id="options$3531" title="Parameter" ><summary><span><a href="#options$3531">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#EventEmitterOptions$3930">EventEmitterOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="captureRejectionSymbol$3526" title="Property" ><summary><span><a href="#captureRejectionSymbol$3526">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$3527" title="Property" ><summary><span><a href="#captureRejections$3527">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$3528" title="Property" ><summary><span><a href="#defaultMaxListeners$3528">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$3525" title="Property" ><summary><span><a href="#errorMonitor$3525">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="addListener$3532" title="Method" ><summary><span><a href="#addListener$3532">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3534" title="Parameter" ><summary><span><a href="#eventName$3534">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3535" title="Function" ><summary><span><a href="#listener$3535">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3538" title="Parameter" ><summary><span><a href="#args$3538">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="emit$3581" title="Method" ><summary><span><a href="#emit$3581">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3583" title="Parameter" ><summary><span><a href="#eventName$3583">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3584" title="Parameter" ><summary><span><a href="#args$3584">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$3602" title="Method" ><summary><span><a href="#eventNames$3602">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3573" title="Method" ><summary><span><a href="#getMaxListeners$3573">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$3585" title="Method" ><summary><span><a href="#listenerCount$3585">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3587" title="Parameter" ><summary><span><a href="#eventName$3587">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3575" title="Method" ><summary><span><a href="#listeners$3575">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3577" title="Parameter" ><summary><span><a href="#eventName$3577">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3560" title="Method" ><summary><span><a href="#off$3560">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3562" title="Parameter" ><summary><span><a href="#eventName$3562">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3563" title="Function" ><summary><span><a href="#listener$3563">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3566" title="Parameter" ><summary><span><a href="#args$3566">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="on$3539" title="Method" ><summary><span><a href="#on$3539">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3541" title="Parameter" ><summary><span><a href="#eventName$3541">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3542" title="Function" ><summary><span><a href="#listener$3542">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3545" title="Parameter" ><summary><span><a href="#args$3545">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="once$3546" title="Method" ><summary><span><a href="#once$3546">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3548" title="Parameter" ><summary><span><a href="#eventName$3548">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3549" title="Function" ><summary><span><a href="#listener$3549">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3552" title="Parameter" ><summary><span><a href="#args$3552">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="prependListener$3588" title="Method" ><summary><span><a href="#prependListener$3588">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3590" title="Parameter" ><summary><span><a href="#eventName$3590">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3591" title="Function" ><summary><span><a href="#listener$3591">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3594" title="Parameter" ><summary><span><a href="#args$3594">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="prependOnceListener$3595" title="Method" ><summary><span><a href="#prependOnceListener$3595">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3597" title="Parameter" ><summary><span><a href="#eventName$3597">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3598" title="Function" ><summary><span><a href="#listener$3598">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3601" title="Parameter" ><summary><span><a href="#args$3601">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="rawListeners$3578" title="Method" ><summary><span><a href="#rawListeners$3578">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3580" title="Parameter" ><summary><span><a href="#eventName$3580">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$3567" title="Method" ><summary><span><a href="#removeAllListeners$3567">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3569" title="Parameter" ><summary><span><a href="#event$3569">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="removeListener$3553" title="Method" ><summary><span><a href="#removeListener$3553">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3555" title="Parameter" ><summary><span><a href="#eventName$3555">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3556" title="Function" ><summary><span><a href="#listener$3556">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3559" title="Parameter" ><summary><span><a href="#args$3559">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="setMaxListeners$3570" title="Method" ><summary><span><a href="#setMaxListeners$3570">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3572" title="Parameter" ><summary><span><a href="#n$3572">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3498">EventEmitter</a></ul></p></p>    </ul></details><details id="getEventListeners$3517" title="Method" ><summary><span><a href="#getEventListeners$3517">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$3519" title="Parameter" ><summary><span><a href="#emitter$3519">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$3520" title="Parameter" ><summary><span><a href="#name$3520">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$3513" title="Method" ><summary><span><a href="#listenerCount$3513">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$3515" title="Parameter" ><summary><span><a href="#emitter$3515">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$3516" title="Parameter" ><summary><span><a href="#eventName$3516">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$3508" title="Method" ><summary><span><a href="#on$3508">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$3510" title="Parameter" ><summary><span><a href="#emitter$3510">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$3511" title="Parameter" ><summary><span><a href="#eventName$3511">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$3512" title="Parameter" ><summary><span><a href="#options$3512">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$3499" title="Method" ><summary><span><a href="#once$3499">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$3501" title="Parameter" ><summary><span><a href="#emitter$3501">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$3502" title="Parameter" ><summary><span><a href="#eventName$3502">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$3503" title="Parameter" ><summary><span><a href="#options$3503">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$3505" title="Parameter" ><summary><span><a href="#emitter$3505">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$3506" title="Parameter" ><summary><span><a href="#eventName$3506">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$3507" title="Parameter" ><summary><span><a href="#options$3507">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$3521" title="Method" ><summary><span><a href="#setMaxListeners$3521">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$3523" title="Parameter" ><summary><span><a href="#n$3523">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$3524" title="Parameter" ><summary><span><a href="#eventTargets$3524">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details>  <details id="Stream$119" title="Class" ><summary><span><a href="#Stream$119">#</a></span>  <code><strong>Stream</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L32">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L32</a>  <ul>        <p>  <details id="constructor$150" title="Constructor" ><summary><span><a href="#constructor$150">#</a></span>  <code><strong>constructor</strong></code><em>(opts)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L33">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L33</a>  <ul>    <p>  <details id="new Stream$151" title="ConstructorSignature" ><summary><span><a href="#new Stream$151">#</a></span>  <code><strong>new Stream</strong></code><em>()</em>    </summary>    <ul><p><a href="#Stream$119">Stream</a></p>      <p>  <details id="opts$152" title="Parameter" ><summary><span><a href="#opts$152">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><a href="#ReadableOptions$706">ReadableOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="captureRejectionSymbol$147" title="Property" ><summary><span><a href="#captureRejectionSymbol$147">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$148" title="Property" ><summary><span><a href="#captureRejections$148">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$149" title="Property" ><summary><span><a href="#defaultMaxListeners$149">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$146" title="Property" ><summary><span><a href="#errorMonitor$146">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="addListener$160" title="Method" ><summary><span><a href="#addListener$160">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$162" title="Parameter" ><summary><span><a href="#eventName$162">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$163" title="Function" ><summary><span><a href="#listener$163">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$166" title="Parameter" ><summary><span><a href="#args$166">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="emit$209" title="Method" ><summary><span><a href="#emit$209">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$211" title="Parameter" ><summary><span><a href="#eventName$211">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$212" title="Parameter" ><summary><span><a href="#args$212">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$230" title="Method" ><summary><span><a href="#eventNames$230">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$201" title="Method" ><summary><span><a href="#getMaxListeners$201">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$213" title="Method" ><summary><span><a href="#listenerCount$213">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$215" title="Parameter" ><summary><span><a href="#eventName$215">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$203" title="Method" ><summary><span><a href="#listeners$203">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$205" title="Parameter" ><summary><span><a href="#eventName$205">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$188" title="Method" ><summary><span><a href="#off$188">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$190" title="Parameter" ><summary><span><a href="#eventName$190">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$191" title="Function" ><summary><span><a href="#listener$191">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$194" title="Parameter" ><summary><span><a href="#args$194">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="on$167" title="Method" ><summary><span><a href="#on$167">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$169" title="Parameter" ><summary><span><a href="#eventName$169">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$170" title="Function" ><summary><span><a href="#listener$170">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$173" title="Parameter" ><summary><span><a href="#args$173">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="once$174" title="Method" ><summary><span><a href="#once$174">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$176" title="Parameter" ><summary><span><a href="#eventName$176">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$177" title="Function" ><summary><span><a href="#listener$177">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$180" title="Parameter" ><summary><span><a href="#args$180">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="pipe$153" title="Method" ><summary><span><a href="#pipe$153">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$156" title="Parameter" ><summary><span><a href="#destination$156">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$157" title="Parameter" ><summary><span><a href="#options$157">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$159" title="Property" ><summary><span><a href="#end$159">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$216" title="Method" ><summary><span><a href="#prependListener$216">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$218" title="Parameter" ><summary><span><a href="#eventName$218">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$219" title="Function" ><summary><span><a href="#listener$219">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$222" title="Parameter" ><summary><span><a href="#args$222">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="prependOnceListener$223" title="Method" ><summary><span><a href="#prependOnceListener$223">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$225" title="Parameter" ><summary><span><a href="#eventName$225">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$226" title="Function" ><summary><span><a href="#listener$226">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$229" title="Parameter" ><summary><span><a href="#args$229">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="rawListeners$206" title="Method" ><summary><span><a href="#rawListeners$206">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$208" title="Parameter" ><summary><span><a href="#eventName$208">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$195" title="Method" ><summary><span><a href="#removeAllListeners$195">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$197" title="Parameter" ><summary><span><a href="#event$197">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="removeListener$181" title="Method" ><summary><span><a href="#removeListener$181">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$183" title="Parameter" ><summary><span><a href="#eventName$183">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$184" title="Function" ><summary><span><a href="#listener$184">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$187" title="Parameter" ><summary><span><a href="#args$187">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="setMaxListeners$198" title="Method" ><summary><span><a href="#setMaxListeners$198">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$200" title="Parameter" ><summary><span><a href="#n$200">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#Stream$119">Stream</a></ul></p></p>    </ul></details><details id="getEventListeners$138" title="Method" ><summary><span><a href="#getEventListeners$138">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$140" title="Parameter" ><summary><span><a href="#emitter$140">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$141" title="Parameter" ><summary><span><a href="#name$141">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$134" title="Method" ><summary><span><a href="#listenerCount$134">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$136" title="Parameter" ><summary><span><a href="#emitter$136">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$137" title="Parameter" ><summary><span><a href="#eventName$137">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$129" title="Method" ><summary><span><a href="#on$129">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$131" title="Parameter" ><summary><span><a href="#emitter$131">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$132" title="Parameter" ><summary><span><a href="#eventName$132">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$133" title="Parameter" ><summary><span><a href="#options$133">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$120" title="Method" ><summary><span><a href="#once$120">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$122" title="Parameter" ><summary><span><a href="#emitter$122">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$123" title="Parameter" ><summary><span><a href="#eventName$123">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$124" title="Parameter" ><summary><span><a href="#options$124">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$126" title="Parameter" ><summary><span><a href="#emitter$126">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$127" title="Parameter" ><summary><span><a href="#eventName$127">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$128" title="Parameter" ><summary><span><a href="#options$128">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$142" title="Method" ><summary><span><a href="#setMaxListeners$142">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$144" title="Parameter" ><summary><span><a href="#n$144">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$145" title="Parameter" ><summary><span><a href="#eventTargets$145">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details>  <details id="URL$73" title="Class" ><summary><span><a href="#URL$73">#</a></span>  <code><strong>URL</strong></code>     &ndash; Browser-compatible <code>URL</code> class, implemented by following the WHATWG URL
Standard. <a href="https://url.spec.whatwg.org/#example-url-parsing">Examples of parsed URLs</a> may be found in the Standard itself.
The <code>URL</code> class is also available on the global object.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L367">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L367</a>  <ul>  <p>

In accordance with browser conventions, all properties of `URL` objects
are implemented as getters and setters on the class prototype, rather than as
data properties on the object itself. Thus, unlike `legacy urlObject` s,
using the `delete` keyword on any properties of `URL` objects (e.g. `delete myURL.protocol`, `delete myURL.pathname`, etc) has no effect but will still
return `true`.

</p>
      <p>  <details id="constructor$80" title="Constructor" ><summary><span><a href="#constructor$80">#</a></span>  <code><strong>constructor</strong></code><em>(input, base)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L402">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L402</a>  <ul>    <p>  <details id="new URL$81" title="ConstructorSignature" ><summary><span><a href="#new URL$81">#</a></span>  <code><strong>new URL</strong></code><em>()</em>    </summary>    <ul><p><a href="#URL$73">URL</a></p>      <p>  <details id="input$82" title="Parameter" ><summary><span><a href="#input$82">#</a></span>  <code><strong>input</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="base$83" title="Parameter" ><summary><span><a href="#base$83">#</a></span>  <code><strong>base</strong></code>    </summary>    <ul><p>string | <a href="#URL$73">URL</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="hash$84" title="Property" ><summary><span><a href="#hash$84">#</a></span>  <code><strong>hash</strong></code>     &ndash; Gets and sets the fragment portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L420">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L420</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org/foo#bar')
console.log(myURL.hash)
// Prints #bar

myURL.hash = 'baz'
console.log(myURL.href)
// Prints https://example.org/foo#baz
```

Invalid URL characters included in the value assigned to the `hash` property
are `percent-encoded`. The selection of which characters to
percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.

</p>
      </ul></details><details id="host$85" title="Property" ><summary><span><a href="#host$85">#</a></span>  <code><strong>host</strong></code>     &ndash; Gets and sets the host portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L436">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L436</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org:81/foo')
console.log(myURL.host)
// Prints example.org:81

myURL.host = 'example.com:82'
console.log(myURL.href)
// Prints https://example.com:82/foo
```

Invalid host values assigned to the `host` property are ignored.

</p>
      </ul></details><details id="hostname$86" title="Property" ><summary><span><a href="#hostname$86">#</a></span>  <code><strong>hostname</strong></code>     &ndash; Gets and sets the host name portion of the URL. The key difference between<code>url.host</code> and <code>url.hostname</code> is that <code>url.hostname</code> does <em>not</em> include the
port.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L459">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L459</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org:81/foo')
console.log(myURL.hostname)
// Prints example.org

// Setting the hostname does not change the port
myURL.hostname = 'example.com:82'
console.log(myURL.href)
// Prints https://example.com:81/foo

// Use myURL.host to change the hostname and port
myURL.host = 'example.org:82'
console.log(myURL.href)
// Prints https://example.org:82/foo
```

Invalid host name values assigned to the `hostname` property are ignored.

</p>
      </ul></details><details id="href$87" title="Property" ><summary><span><a href="#href$87">#</a></span>  <code><strong>href</strong></code>     &ndash; Gets and sets the serialized URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L480">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L480</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org/foo')
console.log(myURL.href)
// Prints https://example.org/foo

myURL.href = 'https://example.com/bar'
console.log(myURL.href)
// Prints https://example.com/bar
```

Getting the value of the `href` property is equivalent to calling {@link toString}.

Setting the value of this property to a new value is equivalent to creating a
new `URL` object using `new URL(value)`. Each of the `URL`object's properties will be modified.

If the value assigned to the `href` property is not a valid URL, a `TypeError`will be thrown.

</p>
      </ul></details><details id="origin$88" title="Property" ><summary><span><a href="#origin$88">#</a></span>  <code><strong>origin</strong></code>     &ndash; Gets the read-only serialization of the URL's origin.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L499">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L499</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org/foo/bar?baz')
console.log(myURL.origin)
// Prints https://example.org
```

```js
const idnURL = new URL('https://測試')
console.log(idnURL.origin)
// Prints https://xn--g6w251d

console.log(idnURL.hostname)
// Prints xn--g6w251d
```

</p>
      </ul></details><details id="password$89" title="Property" ><summary><span><a href="#password$89">#</a></span>  <code><strong>password</strong></code>     &ndash; Gets and sets the password portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L517">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L517</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://abc:xyz@example.com')
console.log(myURL.password)
// Prints xyz

myURL.password = '123'
console.log(myURL.href)
// Prints https://abc:123@example.com
```

Invalid URL characters included in the value assigned to the `password` property
are `percent-encoded`. The selection of which characters to
percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.

</p>
      </ul></details><details id="pathname$90" title="Property" ><summary><span><a href="#pathname$90">#</a></span>  <code><strong>pathname</strong></code>     &ndash; Gets and sets the path portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L534">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L534</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org/abc/xyz?123')
console.log(myURL.pathname)
// Prints /abc/xyz

myURL.pathname = '/abcdef'
console.log(myURL.href)
// Prints https://example.org/abcdef?123
```

Invalid URL characters included in the value assigned to the `pathname`property are `percent-encoded`. The selection of which characters
to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.

</p>
      </ul></details><details id="port$91" title="Property" ><summary><span><a href="#port$91">#</a></span>  <code><strong>port</strong></code>     &ndash; Gets and sets the port portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L607">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L607</a>  <ul><p>string</p>  <p>

The port value may be a number or a string containing a number in the range`0` to `65535` (inclusive). Setting the value to the default port of the`URL` objects given `protocol` will
result in the `port` value becoming
the empty string (`''`).

The port value can be an empty string in which case the port depends on
the protocol/scheme:

<omitted>

Upon assigning a value to the port, the value will first be converted to a
string using `.toString()`.

If that string is invalid but it begins with a number, the leading number is
assigned to `port`.
If the number lies outside the range denoted above, it is ignored.

```js
const myURL = new URL('https://example.org:8888')
console.log(myURL.port)
// Prints 8888

// Default ports are automatically transformed to the empty string
// (HTTPS protocol's default port is 443)
myURL.port = '443'
console.log(myURL.port)
// Prints the empty string
console.log(myURL.href)
// Prints https://example.org/

myURL.port = 1234
console.log(myURL.port)
// Prints 1234
console.log(myURL.href)
// Prints https://example.org:1234/

// Completely invalid port strings are ignored
myURL.port = 'abcd'
console.log(myURL.port)
// Prints 1234

// Leading numbers are treated as a port number
myURL.port = '5678abcd'
console.log(myURL.port)
// Prints 5678

// Non-integers are truncated
myURL.port = 1234.5678
console.log(myURL.port)
// Prints 1234

// Out-of-range numbers which are not represented in scientific notation
// will be ignored.
myURL.port = 1e10 // 10000000000, will be range-checked as described below
console.log(myURL.port)
// Prints 1234
```

Numbers which contain a decimal point,
such as floating-point numbers or numbers in scientific notation,
are not an exception to this rule.
Leading numbers up to the decimal point will be set as the URL's port,
assuming they are valid:

```js
myURL.port = 4.567e21
console.log(myURL.port)
// Prints 4 (because it is the leading number in the string '4.567e21')
```

</p>
      </ul></details><details id="protocol$92" title="Property" ><summary><span><a href="#protocol$92">#</a></span>  <code><strong>protocol</strong></code>     &ndash; Gets and sets the protocol portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L623">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L623</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org')
console.log(myURL.protocol)
// Prints https:

myURL.protocol = 'ftp'
console.log(myURL.href)
// Prints ftp://example.org/
```

Invalid URL protocol values assigned to the `protocol` property are ignored.

</p>
      </ul></details><details id="search$93" title="Property" ><summary><span><a href="#search$93">#</a></span>  <code><strong>search</strong></code>     &ndash; Gets and sets the serialized query portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L640">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L640</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://example.org/abc?123')
console.log(myURL.search)
// Prints ?123

myURL.search = 'abc=xyz'
console.log(myURL.href)
// Prints https://example.org/abc?abc=xyz
```

Any invalid URL characters appearing in the value assigned the `search`property will be `percent-encoded`. The selection of which
characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.

</p>
      </ul></details><details id="searchParams$94" title="Property" ><summary><span><a href="#searchParams$94">#</a></span>  <code><strong>searchParams</strong></code>     &ndash; Gets the <code>URLSearchParams</code> object representing the query parameters of the
URL. This property is read-only but the <code>URLSearchParams</code> object it provides
can be used to mutate the URL instance; to replace the entirety of query
parameters of the URL, use the {@link search} setter. See <code>URLSearchParams</code> documentation for details.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L664">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L664</a>  <ul><p><a href="#URLSearchParams$236">URLSearchParams</a></p>  <p>

Use care when using `.searchParams` to modify the `URL` because,
per the WHATWG specification, the `URLSearchParams` object uses
different rules to determine which characters to percent-encode. For
instance, the `URL` object will not percent encode the ASCII tilde (`~`)
character, while `URLSearchParams` will always encode it:

```js
const myUrl = new URL('https://example.org/abc?foo=~bar')

console.log(myUrl.search) // prints ?foo=~bar

// Modify the URL via searchParams...
myUrl.searchParams.sort()

console.log(myUrl.search) // prints ?foo=%7Ebar
```

</p>
      </ul></details><details id="username$95" title="Property" ><summary><span><a href="#username$95">#</a></span>  <code><strong>username</strong></code>     &ndash; Gets and sets the username portion of the URL.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L681">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L681</a>  <ul><p>string</p>  <p>

```js
const myURL = new URL('https://abc:xyz@example.com')
console.log(myURL.username)
// Prints abc

myURL.username = '123'
console.log(myURL.href)
// Prints https://123:xyz@example.com/
```

Any invalid URL characters appearing in the value assigned the `username`property will be `percent-encoded`. The selection of which
characters to percent-encode may vary somewhat from what the {@link parse} and {@link format} methods would produce.

</p>
      </ul></details><details id="toJSON$98" title="Method" ><summary><span><a href="#toJSON$98">#</a></span>  <code><strong>toJSON</strong></code><em>()</em>     &ndash; The <code>toJSON()</code> method on the <code>URL</code> object returns the serialized URL. The
value returned is equivalent to that of {@link href} and {@link toString}.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L703">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L703</a>  <ul>    <p>  <p>

This method is automatically called when an `URL` object is serialized
with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

```js
const myURLs = [
  new URL('https://www.example.com'),
  new URL('https://test.example.org'),
]
console.log(JSON.stringify(myURLs))
// Prints ["https://www.example.com/","https://test.example.org/"]
```

</p>
    <p><strong>toJSON</strong><em>()</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="toString$96" title="Method" ><summary><span><a href="#toString$96">#</a></span>  <code><strong>toString</strong></code><em>()</em>     &ndash; The <code>toString()</code> method on the <code>URL</code> object returns the serialized URL. The
value returned is equivalent to that of {@link href} and {@link toJSON}.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L686">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L686</a>  <ul>    <p>      <p><strong>toString</strong><em>()</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="createObjectURL$74" title="Method" ><summary><span><a href="#createObjectURL$74">#</a></span>  <code><strong>createObjectURL</strong></code><em>(blob)</em>     &ndash; Creates a <code>'blob:nodedata:...'</code> URL string that represents the given <code>Blob</code> object and can be used to retrieve the <code>Blob</code> later.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L394">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L394</a>  <ul>    <p>  <p>

```js
const {
  Blob,
  resolveObjectURL,
} = require('buffer')

const blob = new Blob(['hello'])
const id = URL.createObjectURL(blob)

// later...

const otherBlob = resolveObjectURL(id)
console.log(otherBlob.size)
```

The data stored by the registered `Blob` will be retained in memory until`URL.revokeObjectURL()` is called to remove it.

`Blob` objects are registered within the current thread. If using Worker
Threads, `Blob` objects registered within one Worker will not be available
to other workers or the main thread.

</p>
  <details id="blob$76" title="Parameter" ><summary><span><a href="#blob$76">#</a></span>  <code><strong>blob</strong></code>    </summary>    <ul><p><a href="#Blob$283">Blob</a></p>        </ul></details>  <p><strong>createObjectURL</strong><em>(blob)</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="revokeObjectURL$77" title="Method" ><summary><span><a href="#revokeObjectURL$77">#</a></span>  <code><strong>revokeObjectURL</strong></code><em>(objectUrl)</em>     &ndash; Removes the stored <code>Blob</code> identified by the given ID.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L401">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L401</a>  <ul>    <p>    <details id="objectUrl$79" title="Parameter" ><summary><span><a href="#objectUrl$79">#</a></span>  <code><strong>objectUrl</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>revokeObjectURL</strong><em>(objectUrl)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details>  <details id="URLSearchParams$236" title="Class" ><summary><span><a href="#URLSearchParams$236">#</a></span>  <code><strong>URLSearchParams</strong></code>     &ndash; The <code>URLSearchParams</code> API provides read and write access to the query of a<code>URL</code>. The <code>URLSearchParams</code> class can also be used standalone with one of the
four following constructors.
The <code>URLSearchParams</code> class is also available on the global object.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L749">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L749</a>  <ul>  <p>

The WHATWG `URLSearchParams` interface and the `querystring` module have
similar purpose, but the purpose of the `querystring` module is more
general, as it allows the customization of delimiter characters (`&#x26;` and `=`).
On the other hand, this API is designed purely for URL query strings.

```js
const myURL = new URL('https://example.org/?abc=123')
console.log(myURL.searchParams.get('abc'))
// Prints 123

myURL.searchParams.append('abc', 'xyz')
console.log(myURL.href)
// Prints https://example.org/?abc=123&#x26;abc=xyz

myURL.searchParams.delete('abc')
myURL.searchParams.set('a', 'b')
console.log(myURL.href)
// Prints https://example.org/?a=b

const newSearchParams = new URLSearchParams(myURL.searchParams)
// The above is equivalent to
// const newSearchParams = new URLSearchParams(myURL.search);

newSearchParams.append('a', 'c')
console.log(myURL.href)
// Prints https://example.org/?a=b
console.log(newSearchParams.toString())
// Prints a=b&#x26;a=c

// newSearchParams.toString() is implicitly called
myURL.search = newSearchParams
console.log(myURL.href)
// Prints https://example.org/?a=b&#x26;a=c
newSearchParams.delete('a')
console.log(myURL.href)
// Prints https://example.org/?a=b&#x26;a=c
```

</p>
      <p>  <details id="constructor$237" title="Constructor" ><summary><span><a href="#constructor$237">#</a></span>  <code><strong>constructor</strong></code><em>(init)</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L750">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L750</a>  <ul>    <p>  <details id="new URLSearchParams$238" title="ConstructorSignature" ><summary><span><a href="#new URLSearchParams$238">#</a></span>  <code><strong>new URLSearchParams</strong></code><em>()</em>    </summary>    <ul><p><a href="#URLSearchParams$236">URLSearchParams</a></p>      <p>  <details id="init$239" title="Parameter" ><summary><span><a href="#init$239">#</a></span>  <code><strong>init</strong></code>    </summary>    <ul><p>string | <a href="#URLSearchParams$236">URLSearchParams</a> | <span>Record</span>&lt;string, string | readonly     string  []&gt; | <span>Iterable</span>&lt;[  string, string  ]&gt; | readonly     [  string, string  ]  []</p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="[iterator]$281" title="Method" ><summary><span><a href="#[iterator]$281">#</a></span>  <code><strong>[iterator]</strong></code><em>()</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L856">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L856</a>  <ul>    <p>      <p><strong>[iterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;[  string, string  ]&gt;</ul></p></p>    </ul></details><details id="append$240" title="Method" ><summary><span><a href="#append$240">#</a></span>  <code><strong>append</strong></code><em>(name, value)</em>     &ndash; Append a new name-value pair to the query string.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L754">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L754</a>  <ul>    <p>    <details id="name$242" title="Parameter" ><summary><span><a href="#name$242">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="value$243" title="Parameter" ><summary><span><a href="#value$243">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>append</strong><em>(name, value)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="delete$244" title="Method" ><summary><span><a href="#delete$244">#</a></span>  <code><strong>delete</strong></code><em>(name)</em>     &ndash; Remove all name-value pairs whose name is <code>name</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L758">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L758</a>  <ul>    <p>    <details id="name$246" title="Parameter" ><summary><span><a href="#name$246">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>delete</strong><em>(name)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="entries$247" title="Method" ><summary><span><a href="#entries$247">#</a></span>  <code><strong>entries</strong></code><em>()</em>     &ndash; Returns an ES6 <code>Iterator</code> over each of the name-value pairs in the query.
Each item of the iterator is a JavaScript <code>Array</code>. The first item of the <code>Array</code>is the <code>name</code>, the second item of the <code>Array</code> is the <code>value</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L765">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L765</a>  <ul>    <p>  <p>

Alias for `urlSearchParams[@@iterator]()`.

</p>
    <p><strong>entries</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;[  string, string  ]&gt;</ul></p></p>    </ul></details><details id="forEach$249" title="Method" ><summary><span><a href="#forEach$249">#</a></span>  <code><strong>forEach</strong></code><em>(callback, thisArg)</em>     &ndash; Iterates over each name-value pair in the query and invokes the given function.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L781">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L781</a>  <ul>    <p>  <p>

```js
const myURL = new URL('https://example.org/?a=b&#x26;c=d')
myURL.searchParams.forEach((value, name, searchParams) => {
  console.log(name, value, myURL.searchParams === searchParams)
})
// Prints:
//   a b true
//   c d true
```

</p>
  <details id="callback$252" title="Function" ><summary><span><a href="#callback$252">#</a></span>  <code><strong>callback</strong></code><em>(this, value, name, searchParams)</em>    </summary>    <ul>    <p>    <details id="this$255" title="Parameter" ><summary><span><a href="#this$255">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#TThis$251">TThis</a></p>        </ul></details><details id="value$256" title="Parameter" ><summary><span><a href="#value$256">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="name$257" title="Parameter" ><summary><span><a href="#name$257">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="searchParams$258" title="Parameter" ><summary><span><a href="#searchParams$258">#</a></span>  <code><strong>searchParams</strong></code>    </summary>    <ul><p><a href="#URLSearchParams$236">URLSearchParams</a></p>        </ul></details>  <p><strong>callback</strong><em>(this, value, name, searchParams)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="thisArg$259" title="Parameter" ><summary><span><a href="#thisArg$259">#</a></span>  <code><strong>thisArg</strong></code>     &ndash; To be used as <code>this</code> value for when <code>fn</code> is called
</summary>    <ul><p><a href="#TThis$251">TThis</a></p>        </ul></details>  <p><strong>forEach</strong>&lt;<span>TThis</span>&gt;<em>(callback, thisArg)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="get$260" title="Method" ><summary><span><a href="#get$260">#</a></span>  <code><strong>get</strong></code><em>(name)</em>     &ndash; Returns the value of the first name-value pair whose name is <code>name</code>. If there
are no such pairs, <code>null</code> is returned.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L787">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L787</a>  <ul>    <p>    <details id="name$262" title="Parameter" ><summary><span><a href="#name$262">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>get</strong><em>(name)</em>  &nbsp;=&gt;  <ul><code>null</code> | string</ul></p></p>    </ul></details><details id="getAll$263" title="Method" ><summary><span><a href="#getAll$263">#</a></span>  <code><strong>getAll</strong></code><em>(name)</em>     &ndash; Returns the values of all name-value pairs whose name is <code>name</code>. If there are
no such pairs, an empty array is returned.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L792">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L792</a>  <ul>    <p>    <details id="name$265" title="Parameter" ><summary><span><a href="#name$265">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>getAll</strong><em>(name)</em>  &nbsp;=&gt;  <ul>string  []</ul></p></p>    </ul></details><details id="has$266" title="Method" ><summary><span><a href="#has$266">#</a></span>  <code><strong>has</strong></code><em>(name)</em>     &ndash; Returns <code>true</code> if there is at least one name-value pair whose name is <code>name</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L796">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L796</a>  <ul>    <p>    <details id="name$268" title="Parameter" ><summary><span><a href="#name$268">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>has</strong><em>(name)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="keys$269" title="Method" ><summary><span><a href="#keys$269">#</a></span>  <code><strong>keys</strong></code><em>()</em>     &ndash; Returns an ES6 <code>Iterator</code> over the names of each name-value pair.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L810">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L810</a>  <ul>    <p>  <p>

```js
const params = new URLSearchParams('foo=bar&#x26;foo=baz')
for (const name of params.keys()) {
  console.log(name)
}
// Prints:
//   foo
//   foo
```

</p>
    <p><strong>keys</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;string&gt;</ul></p></p>    </ul></details><details id="set$271" title="Method" ><summary><span><a href="#set$271">#</a></span>  <code><strong>set</strong></code><em>(name, value)</em>     &ndash; Sets the value in the <code>URLSearchParams</code> object associated with <code>name</code> to<code>value</code>. If there are any pre-existing name-value pairs whose names are <code>name</code>,
set the first such pair's value to <code>value</code> and remove all others. If not,
append the name-value pair to the query string.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L830">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L830</a>  <ul>    <p>  <p>

```js
const params = new URLSearchParams()
params.append('foo', 'bar')
params.append('foo', 'baz')
params.append('abc', 'def')
console.log(params.toString())
// Prints foo=bar&#x26;foo=baz&#x26;abc=def

params.set('foo', 'def')
params.set('xyz', 'opq')
console.log(params.toString())
// Prints foo=def&#x26;abc=def&#x26;xyz=opq
```

</p>
  <details id="name$273" title="Parameter" ><summary><span><a href="#name$273">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="value$274" title="Parameter" ><summary><span><a href="#value$274">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>set</strong><em>(name, value)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="sort$275" title="Method" ><summary><span><a href="#sort$275">#</a></span>  <code><strong>sort</strong></code><em>()</em>     &ndash; Sort all existing name-value pairs in-place by their names. Sorting is done
with a <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable sorting algorithm</a>, so relative order between name-value pairs
with the same name is preserved.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L846">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L846</a>  <ul>    <p>  <p>

This method can be used, in particular, to increase cache hits.

```js
const params = new URLSearchParams(
  'query[]=abc&#x26;type=search&#x26;query[]=123'
)
params.sort()
console.log(params.toString())
// Prints query%5B%5D=abc&#x26;query%5B%5D=123&#x26;type=search
```

</p>
    <p><strong>sort</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="toString$277" title="Method" ><summary><span><a href="#toString$277">#</a></span>  <code><strong>toString</strong></code><em>()</em>     &ndash; Returns the search parameters serialized as a string, with characters
percent-encoded where necessary.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L851">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L851</a>  <ul>    <p>      <p><strong>toString</strong><em>()</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="values$279" title="Method" ><summary><span><a href="#values$279">#</a></span>  <code><strong>values</strong></code><em>()</em>     &ndash; Returns an ES6 <code>Iterator</code> over the values of each name-value pair.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/url.d.ts#L855">src/.fastpm/-/@types/node@17.0.45/url.d.ts#L855</a>  <ul>    <p>      <p><strong>values</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;string&gt;</ul></p></p>    </ul></details></p></ul></details>  <details id="internal$306" title="Class" ><summary><span><a href="#internal$306">#</a></span>  <code><strong>internal</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L23">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L23</a>  <ul>        <p>  <details id="constructor$337" title="Constructor" ><summary><span><a href="#constructor$337">#</a></span>  <code><strong>constructor</strong></code><em>(options)</em>    </summary>    <ul>    <p>  <details id="new internal$338" title="ConstructorSignature" ><summary><span><a href="#new internal$338">#</a></span>  <code><strong>new internal</strong></code><em>()</em>    </summary>    <ul><p><a href="#internal$306">internal</a></p>      <p>  <details id="options$339" title="Parameter" ><summary><span><a href="#options$339">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#EventEmitterOptions$3930">EventEmitterOptions</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="captureRejectionSymbol$334" title="Property" ><summary><span><a href="#captureRejectionSymbol$334">#</a></span>  <code><strong>captureRejectionSymbol</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L301</a>  <ul><p>typeof   <a href="#captureRejectionSymbol$147">captureRejectionSymbol</a></p>        </ul></details><details id="captureRejections$335" title="Property" ><summary><span><a href="#captureRejections$335">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Sets or gets the default captureRejection value for all emitters.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L306</a>  <ul><p>boolean</p>        </ul></details><details id="defaultMaxListeners$336" title="Property" ><summary><span><a href="#defaultMaxListeners$336">#</a></span>  <code><strong>defaultMaxListeners</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L307</a>  <ul><p>number</p>        </ul></details><details id="errorMonitor$333" title="Property" ><summary><span><a href="#errorMonitor$333">#</a></span>  <code><strong>errorMonitor</strong></code>     &ndash; This symbol shall be used to install a listener for only monitoring <code>'error'</code>
events. Listeners installed using this symbol are called before the regular
<code>'error'</code> listeners are called.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L300</a>  <ul><p>typeof   <a href="#errorMonitor$146">errorMonitor</a></p>  <p>

Installing a listener using this symbol does not change the behavior once an
`'error'` event is emitted, therefore the process will still crash if no
regular `'error'` listener is installed.

</p>
      </ul></details><details id="addListener$347" title="Method" ><summary><span><a href="#addListener$347">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$349" title="Parameter" ><summary><span><a href="#eventName$349">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$350" title="Function" ><summary><span><a href="#listener$350">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$353" title="Parameter" ><summary><span><a href="#args$353">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="emit$396" title="Method" ><summary><span><a href="#emit$396">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$398" title="Parameter" ><summary><span><a href="#eventName$398">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$399" title="Parameter" ><summary><span><a href="#args$399">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$417" title="Method" ><summary><span><a href="#eventNames$417">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$388" title="Method" ><summary><span><a href="#getMaxListeners$388">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$400" title="Method" ><summary><span><a href="#listenerCount$400">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$402" title="Parameter" ><summary><span><a href="#eventName$402">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$390" title="Method" ><summary><span><a href="#listeners$390">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$392" title="Parameter" ><summary><span><a href="#eventName$392">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$375" title="Method" ><summary><span><a href="#off$375">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$377" title="Parameter" ><summary><span><a href="#eventName$377">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$378" title="Function" ><summary><span><a href="#listener$378">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$381" title="Parameter" ><summary><span><a href="#args$381">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="on$354" title="Method" ><summary><span><a href="#on$354">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$356" title="Parameter" ><summary><span><a href="#eventName$356">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$357" title="Function" ><summary><span><a href="#listener$357">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$360" title="Parameter" ><summary><span><a href="#args$360">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="once$361" title="Method" ><summary><span><a href="#once$361">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$363" title="Parameter" ><summary><span><a href="#eventName$363">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$364" title="Function" ><summary><span><a href="#listener$364">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$367" title="Parameter" ><summary><span><a href="#args$367">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="pipe$340" title="Method" ><summary><span><a href="#pipe$340">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L24</a>  <ul>    <p>    <details id="destination$343" title="Parameter" ><summary><span><a href="#destination$343">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$155">T</a></p>        </ul></details><details id="options$344" title="Parameter" ><summary><span><a href="#options$344">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$346" title="Property" ><summary><span><a href="#end$346">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L27</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$155">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$155">T</a></ul></p></p>    </ul></details><details id="prependListener$403" title="Method" ><summary><span><a href="#prependListener$403">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$405" title="Parameter" ><summary><span><a href="#eventName$405">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$406" title="Function" ><summary><span><a href="#listener$406">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$409" title="Parameter" ><summary><span><a href="#args$409">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="prependOnceListener$410" title="Method" ><summary><span><a href="#prependOnceListener$410">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$412" title="Parameter" ><summary><span><a href="#eventName$412">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$413" title="Function" ><summary><span><a href="#listener$413">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$416" title="Parameter" ><summary><span><a href="#args$416">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="rawListeners$393" title="Method" ><summary><span><a href="#rawListeners$393">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$395" title="Parameter" ><summary><span><a href="#eventName$395">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$382" title="Method" ><summary><span><a href="#removeAllListeners$382">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$384" title="Parameter" ><summary><span><a href="#event$384">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="removeListener$368" title="Method" ><summary><span><a href="#removeListener$368">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$370" title="Parameter" ><summary><span><a href="#eventName$370">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$371" title="Function" ><summary><span><a href="#listener$371">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$374" title="Parameter" ><summary><span><a href="#args$374">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="setMaxListeners$385" title="Method" ><summary><span><a href="#setMaxListeners$385">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$387" title="Parameter" ><summary><span><a href="#n$387">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#internal$306">internal</a></ul></p></p>    </ul></details><details id="getEventListeners$325" title="Method" ><summary><span><a href="#getEventListeners$325">#</a></span>  <code><strong>getEventListeners</strong></code><em>(emitter, name)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L270</a>  <ul>    <p>  <p>

For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
the emitter.

For `EventTarget`s this is the only way to get the event listeners for the
event target. This is useful for debugging and diagnostic purposes.

```js
const { getEventListeners, EventEmitter } = require('events')

{
  const ee = new EventEmitter()
  const listener = () => console.log('Events are fun')
  ee.on('foo', listener)
  getEventListeners(ee, 'foo') // [listener]
}
{
  const et = new EventTarget()
  const listener = () => console.log('Events are fun')
  et.addEventListener('foo', listener)
  getEventListeners(et, 'foo') // [listener]
}
```

</p>
  <details id="emitter$327" title="Parameter" ><summary><span><a href="#emitter$327">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="name$328" title="Parameter" ><summary><span><a href="#name$328">#</a></span>  <code><strong>name</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>getEventListeners</strong><em>(emitter, name)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="listenerCount$321" title="Method" ><summary><span><a href="#listenerCount$321">#</a></span>  <code><strong>listenerCount</strong></code><em>(emitter, eventName)</em>     &ndash; A class method that returns the number of listeners for the given <code>eventName</code>registered on the given <code>emitter</code>.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L242</a>  <ul>    <p>  <p>

```js
const { EventEmitter, listenerCount } = require('events')
const myEmitter = new EventEmitter()
myEmitter.on('event', () => {})
myEmitter.on('event', () => {})
console.log(listenerCount(myEmitter, 'event'))
// Prints: 2
```

</p>
  <details id="emitter$323" title="Parameter" ><summary><span><a href="#emitter$323">#</a></span>  <code><strong>emitter</strong></code>     &ndash; The emitter to query</summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$324" title="Parameter" ><summary><span><a href="#eventName$324">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The event name
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(emitter, eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="on$316" title="Method" ><summary><span><a href="#on$316">#</a></span>  <code><strong>on</strong></code><em>(emitter, eventName, options)</em>     &ndash; ```js
const { on, EventEmitter } = require('events');</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L221</a>  <ul>    <p>  <p>

(async () => {
const ee = new EventEmitter();

// Emit later on
process.nextTick(() => {
ee.emit('foo', 'bar');
ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
// The execution of this inner block is synchronous and it
// processes one event at a time (even with await). Do not use
// if concurrent execution is required.
console.log(event); // prints ['bar'] [42]
}
// Unreachable here
})();

````
Returns an `AsyncIterator` that iterates `eventName` events. It will throw
if the `EventEmitter` emits `'error'`. It removes all listeners when
exiting the loop. The `value` returned by each iteration is an array
composed of the emitted event arguments.

An `AbortSignal` can be used to cancel waiting on events:

```js
const { on, EventEmitter } = require('events');
const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // Emit later on
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // The execution of this inner block is synchronous and it
    // processes one event at a time (even with await). Do not use
    // if concurrent execution is required.
    console.log(event); // prints ['bar'] [42]
  }
  // Unreachable here
})();

process.nextTick(() => ac.abort());
````

</p>
  <details id="emitter$318" title="Parameter" ><summary><span><a href="#emitter$318">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a></p>        </ul></details><details id="eventName$319" title="Parameter" ><summary><span><a href="#eventName$319">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for</summary>    <ul><p>string</p>        </ul></details><details id="options$320" title="Parameter" ><summary><span><a href="#options$320">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>on</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;any&gt;</ul></p></p>    </ul></details><details id="once$307" title="Method" ><summary><span><a href="#once$307">#</a></span>  <code><strong>once</strong></code><em>(emitter, eventName, options)</em>     &ndash; Creates a <code>Promise</code> that is fulfilled when the <code>EventEmitter</code> emits the given
event or that is rejected if the <code>EventEmitter</code> emits <code>'error'</code> while waiting.
The <code>Promise</code> will resolve with an array of all the arguments emitted to the
given event.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L157</a>  <ul>    <p>  <p>

This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
semantics and does not listen to the `'error'` event.

```js
const { once, EventEmitter } = require('events')

async function run() {
  const ee = new EventEmitter()

  process.nextTick(() => {
    ee.emit('myevent', 42)
  })

  const [value] = await once(ee, 'myevent')
  console.log(value)

  const err = new Error('kaboom')
  process.nextTick(() => {
    ee.emit('error', err)
  })

  try {
    await once(ee, 'myevent')
  } catch (err) {
    console.log('error happened', err)
  }
}

run()
```

The special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the
'`error'` event itself, then it is treated as any other kind of event without
special handling:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch(err => console.log('error', err.message))

ee.emit('error', new Error('boom'))

// Prints: ok boom
```

An `AbortSignal` can be used to cancel waiting for the event:

```js
const { EventEmitter, once } = require('events')

const ee = new EventEmitter()
const ac = new AbortController()

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal })
    console.log('event emitted!')
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!')
    } else {
      console.error('There was an error', error.message)
    }
  }
}

foo(ee, 'foo', ac.signal)
ac.abort() // Abort waiting for the event
ee.emit('foo') // Prints: Waiting for the event was canceled!
```

</p>
  <details id="emitter$309" title="Parameter" ><summary><span><a href="#emitter$309">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#NodeEventTarget$3270">NodeEventTarget</a></p>        </ul></details><details id="eventName$310" title="Parameter" ><summary><span><a href="#eventName$310">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="options$311" title="Parameter" ><summary><span><a href="#options$311">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p>  <details id="emitter$313" title="Parameter" ><summary><span><a href="#emitter$313">#</a></span>  <code><strong>emitter</strong></code>    </summary>    <ul><p><a href="#DOMEventTarget$3280">DOMEventTarget</a></p>        </ul></details><details id="eventName$314" title="Parameter" ><summary><span><a href="#eventName$314">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="options$315" title="Parameter" ><summary><span><a href="#options$315">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p><a href="#StaticEventEmitterOptions$3278">StaticEventEmitterOptions</a></p>        </ul></details>  <p><strong>once</strong><em>(emitter, eventName, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;any  []&gt;</ul></p></p>    </ul></details><details id="setMaxListeners$329" title="Method" ><summary><span><a href="#setMaxListeners$329">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n, eventTargets)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>EventEmitter.setMaxListeners()</code> method allows the default limit to be
modified (if eventTargets is empty) or modify the limit specified in every <code>EventTarget</code> | <code>EventEmitter</code> passed as arguments.
The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L290</a>  <ul>    <p>  <p>

```js
EventEmitter.setMaxListeners(20)
// Equivalent to
EventEmitter.defaultMaxListeners = 20

const eventTarget = new EventTarget()
// Only way to increase limit for `EventTarget` instances
// as these doesn't expose its own `setMaxListeners` method
EventEmitter.setMaxListeners(20, eventTarget)
```

</p>
  <details id="n$331" title="Parameter" ><summary><span><a href="#n$331">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="eventTargets$332" title="Parameter" ><summary><span><a href="#eventTargets$332">#</a></span>  <code><strong>eventTargets</strong></code>    </summary>    <ul><p><a href="#EventEmitter$3291">EventEmitter</a> | <a href="#DOMEventTarget$3280">DOMEventTarget</a>  []</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n, eventTargets)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details>  <details id="Abortable$116" title="Interface" ><summary><span><a href="#Abortable$116">#</a></span>  <code><strong>Abortable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L313">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L313</a>  <ul>        <p>  <details id="signal$117" title="Property" ><summary><span><a href="#signal$117">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details></p></ul></details>  <details id="BlobOptions$3495" title="Interface" ><summary><span><a href="#BlobOptions$3495">#</a></span>  <code><strong>BlobOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L101">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L101</a>  <ul>        <p>  <details id="encoding$3496" title="Property" ><summary><span><a href="#encoding$3496">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L105">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L105</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="type$3497" title="Property" ><summary><span><a href="#type$3497">#</a></span>  <code><strong>type</strong></code>     &ndash; The Blob content-type. The intent is for <code>type</code> to convey
the MIME media type of the data, however no validation of the type format
is performed.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L111">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L111</a>  <ul><p>string</p>        </ul></details></p></ul></details>  <details id="Buffer$3933" title="Interface" ><summary><span><a href="#Buffer$3933">#</a></span>  <code><strong>Buffer</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L531">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L531</a>  <ul>        <p>  <details id="compare$3960" title="Method" ><summary><span><a href="#compare$3960">#</a></span>  <code><strong>compare</strong></code><em>(target, targetStart, targetEnd, sourceStart, sourceEnd)</em>     &ndash; Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>comes before, after, or is the same as <code>target</code> in sort order.
Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</summary>    <ul>    <p>  <p>

- `0` is returned if `target` is the same as `buf`
- `1` is returned if `target` should come _before_ `buf` when sorted.
- `-1` is returned if `target` should come _after_ `buf` when sorted.

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from('ABC')
const buf2 = Buffer.from('BCD')
const buf3 = Buffer.from('ABCD')

console.log(buf1.compare(buf1))
// Prints: 0
console.log(buf1.compare(buf2))
// Prints: -1
console.log(buf1.compare(buf3))
// Prints: -1
console.log(buf2.compare(buf1))
// Prints: 1
console.log(buf2.compare(buf3))
// Prints: 1
console.log([buf1, buf2, buf3].sort(Buffer.compare))
// Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]
// (This result is equal to: [buf1, buf3, buf2].)
```

The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively.

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9])
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4])

console.log(buf1.compare(buf2, 5, 9, 0, 4))
// Prints: 0
console.log(buf1.compare(buf2, 0, 6, 4))
// Prints: -1
console.log(buf1.compare(buf2, 5, 6, 5))
// Prints: 1
```

`ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`,`targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.

</p>
  <details id="target$3962" title="Parameter" ><summary><span><a href="#target$3962">#</a></span>  <code><strong>target</strong></code>     &ndash; A <code>Buffer</code> or {@link Uint8Array} with which to compare <code>buf</code>.</summary>    <ul><p><span>Uint8Array</span></p>        </ul></details><details id="targetStart$3963" title="Parameter" ><summary><span><a href="#targetStart$3963">#</a></span>  <code><strong>targetStart</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="targetEnd$3964" title="Parameter" ><summary><span><a href="#targetEnd$3964">#</a></span>  <code><strong>targetEnd</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="sourceStart$3965" title="Parameter" ><summary><span><a href="#sourceStart$3965">#</a></span>  <code><strong>sourceStart</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="sourceEnd$3966" title="Parameter" ><summary><span><a href="#sourceEnd$3966">#</a></span>  <code><strong>sourceEnd</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>compare</strong><em>(target, targetStart, targetEnd, sourceStart, sourceEnd)</em>  &nbsp;=&gt;  <ul><code>0</code> | <code>1</code> | <code>-1</code></ul></p></p>    </ul></details><details id="copy$3967" title="Method" ><summary><span><a href="#copy$3967">#</a></span>  <code><strong>copy</strong></code><em>(target, targetStart, sourceStart, sourceEnd)</em>     &ndash; Copies data from a region of <code>buf</code> to a region in <code>target</code>, even if the <code>target</code>memory region overlaps with <code>buf</code>.</summary>    <ul>    <p>  <p>

[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available
for all TypedArrays, including Node.js `Buffer`s, although it takes
different function arguments.

```js
import { Buffer } from 'buffer'

// Create two `Buffer` instances.
const buf1 = Buffer.allocUnsafe(26)
const buf2 = Buffer.allocUnsafe(26).fill('!')

for (let i = 0; i < 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97
}

// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
buf1.copy(buf2, 8, 16, 20)
// This is equivalent to:
// buf2.set(buf1.subarray(16, 20), 8);

console.log(buf2.toString('ascii', 0, 25))
// Prints: !!!!!!!!qrst!!!!!!!!!!!!!
```

```js
import { Buffer } from 'buffer'

// Create a `Buffer` and copy data from one region to an overlapping region
// within the same `Buffer`.

const buf = Buffer.allocUnsafe(26)

for (let i = 0; i < 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf[i] = i + 97
}

buf.copy(buf, 0, 4, 10)

console.log(buf.toString())
// Prints: efghijghijklmnopqrstuvwxyz
```

</p>
  <details id="target$3969" title="Parameter" ><summary><span><a href="#target$3969">#</a></span>  <code><strong>target</strong></code>     &ndash; A <code>Buffer</code> or {@link Uint8Array} to copy into.</summary>    <ul><p><span>Uint8Array</span></p>        </ul></details><details id="targetStart$3970" title="Parameter" ><summary><span><a href="#targetStart$3970">#</a></span>  <code><strong>targetStart</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="sourceStart$3971" title="Parameter" ><summary><span><a href="#sourceStart$3971">#</a></span>  <code><strong>sourceStart</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="sourceEnd$3972" title="Parameter" ><summary><span><a href="#sourceEnd$3972">#</a></span>  <code><strong>sourceEnd</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>copy</strong><em>(target, targetStart, sourceStart, sourceEnd)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="entries$4234" title="Method" ><summary><span><a href="#entries$4234">#</a></span>  <code><strong>entries</strong></code><em>()</em>     &ndash; Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>[index, byte]</code> pairs from the contents
of <code>buf</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

// Log the entire contents of a `Buffer`.

const buf = Buffer.from('buffer')

for (const pair of buf.entries()) {
  console.log(pair)
}
// Prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
```

</p>
    <p><strong>entries</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;[  number, number  ]&gt;</ul></p></p>    </ul></details><details id="equals$3957" title="Method" ><summary><span><a href="#equals$3957">#</a></span>  <code><strong>equals</strong></code><em>(otherBuffer)</em>     &ndash; Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,<code>false</code> otherwise. Equivalent to <code>buf.compare(otherBuffer) === 0</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from('ABC')
const buf2 = Buffer.from('414243', 'hex')
const buf3 = Buffer.from('ABCD')

console.log(buf1.equals(buf2))
// Prints: true
console.log(buf1.equals(buf3))
// Prints: false
```

</p>
  <details id="otherBuffer$3959" title="Parameter" ><summary><span><a href="#otherBuffer$3959">#</a></span>  <code><strong>otherBuffer</strong></code>     &ndash; A <code>Buffer</code> or {@link Uint8Array} with which to compare <code>buf</code>.
</summary>    <ul><p><span>Uint8Array</span></p>        </ul></details>  <p><strong>equals</strong><em>(otherBuffer)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="fill$4218" title="Method" ><summary><span><a href="#fill$4218">#</a></span>  <code><strong>fill</strong></code><em>(value, offset, end, encoding)</em>     &ndash; Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled:</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

// Fill a `Buffer` with the ASCII character 'h'.

const b = Buffer.allocUnsafe(50).fill('h')

console.log(b.toString())
// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
```

`value` is coerced to a `uint32` value if it is not a string, `Buffer`, or
integer. If the resulting integer is greater than `255` (decimal), `buf` will be
filled with `value &#x26; 255`.

If the final write of a `fill()` operation falls on a multi-byte character,
then only the bytes of that character that fit into `buf` are written:

```js
import { Buffer } from 'buffer'

// Fill a `Buffer` with character that takes up two bytes in UTF-8.

console.log(Buffer.allocUnsafe(5).fill('\u0222'))
// Prints: <Buffer c8 a2 c8 a2 c8>
```

If `value` contains invalid characters, it is truncated; if no valid
fill data remains, an exception is thrown:

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(5)

console.log(buf.fill('a'))
// Prints: <Buffer 61 61 61 61 61>
console.log(buf.fill('aazz', 'hex'))
// Prints: <Buffer aa aa aa aa aa>
console.log(buf.fill('zz', 'hex'))
// Throws an exception.
```

</p>
  <details id="value$4220" title="Parameter" ><summary><span><a href="#value$4220">#</a></span>  <code><strong>value</strong></code>     &ndash; The value with which to fill <code>buf</code>.</summary>    <ul><p>string | number | <span>Uint8Array</span></p>        </ul></details><details id="offset$4221" title="Parameter" ><summary><span><a href="#offset$4221">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="end$4222" title="Parameter" ><summary><span><a href="#end$4222">#</a></span>  <code><strong>end</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$4223" title="Parameter" ><summary><span><a href="#encoding$4223">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>fill</strong><em>(value, offset, end, encoding)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="includes$4236" title="Method" ><summary><span><a href="#includes$4236">#</a></span>  <code><strong>includes</strong></code><em>(value, byteOffset, encoding)</em>     &ndash; Equivalent to <code>buf.indexOf() !== -1</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('this is a buffer')

console.log(buf.includes('this'))
// Prints: true
console.log(buf.includes('is'))
// Prints: true
console.log(buf.includes(Buffer.from('a buffer')))
// Prints: true
console.log(buf.includes(97))
// Prints: true (97 is the decimal ASCII value for 'a')
console.log(buf.includes(Buffer.from('a buffer example')))
// Prints: false
console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)))
// Prints: true
console.log(buf.includes('this', 4))
// Prints: false
```

</p>
  <details id="value$4238" title="Parameter" ><summary><span><a href="#value$4238">#</a></span>  <code><strong>value</strong></code>     &ndash; What to search for.</summary>    <ul><p>string | number | <a href="#Buffer$3932">Buffer</a></p>        </ul></details><details id="byteOffset$4239" title="Parameter" ><summary><span><a href="#byteOffset$4239">#</a></span>  <code><strong>byteOffset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$4240" title="Parameter" ><summary><span><a href="#encoding$4240">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>includes</strong><em>(value, byteOffset, encoding)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="indexOf$4224" title="Method" ><summary><span><a href="#indexOf$4224">#</a></span>  <code><strong>indexOf</strong></code><em>(value, byteOffset, encoding)</em>     &ndash; If <code>value</code> is:</summary>    <ul>    <p>  <p>

- a string, `value` is interpreted according to the character encoding in`encoding`.
- a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.
  To compare a partial `Buffer`, use `buf.slice()`.
- a number, `value` will be interpreted as an unsigned 8-bit integer
  value between `0` and `255`.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('this is a buffer')

console.log(buf.indexOf('this'))
// Prints: 0
console.log(buf.indexOf('is'))
// Prints: 2
console.log(buf.indexOf(Buffer.from('a buffer')))
// Prints: 8
console.log(buf.indexOf(97))
// Prints: 8 (97 is the decimal ASCII value for 'a')
console.log(buf.indexOf(Buffer.from('a buffer example')))
// Prints: -1
console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)))
// Prints: 8

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le')

console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le'))
// Prints: 4
console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le'))
// Prints: 6
```

If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.

If `byteOffset` is not a number, it will be coerced to a number. If the result
of coercion is `NaN` or `0`, then the entire buffer will be searched. This
behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).

```js
import { Buffer } from 'buffer'

const b = Buffer.from('abcdef')

// Passing a value that's a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or 'c'.
console.log(b.indexOf(99.9))
console.log(b.indexOf(256 + 99))

// Passing a byteOffset that coerces to NaN or 0.
// Prints: 1, searching the whole buffer.
console.log(b.indexOf('b', undefined))
console.log(b.indexOf('b', {}))
console.log(b.indexOf('b', null))
console.log(b.indexOf('b', []))
```

If `value` is an empty string or empty `Buffer` and `byteOffset` is less
than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.

</p>
  <details id="value$4226" title="Parameter" ><summary><span><a href="#value$4226">#</a></span>  <code><strong>value</strong></code>     &ndash; What to search for.</summary>    <ul><p>string | number | <span>Uint8Array</span></p>        </ul></details><details id="byteOffset$4227" title="Parameter" ><summary><span><a href="#byteOffset$4227">#</a></span>  <code><strong>byteOffset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$4228" title="Parameter" ><summary><span><a href="#encoding$4228">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>indexOf</strong><em>(value, byteOffset, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="keys$4241" title="Method" ><summary><span><a href="#keys$4241">#</a></span>  <code><strong>keys</strong></code><em>()</em>     &ndash; Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> of <code>buf</code> keys (indices).</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('buffer')

for (const key of buf.keys()) {
  console.log(key)
}
// Prints:
//   0
//   1
//   2
//   3
//   4
//   5
```

</p>
    <p><strong>keys</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;number&gt;</ul></p></p>    </ul></details><details id="lastIndexOf$4229" title="Method" ><summary><span><a href="#lastIndexOf$4229">#</a></span>  <code><strong>lastIndexOf</strong></code><em>(value, byteOffset, encoding)</em>     &ndash; Identical to <code>buf.indexOf()</code>, except the last occurrence of <code>value</code> is found
rather than the first occurrence.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('this buffer is a buffer')

console.log(buf.lastIndexOf('this'))
// Prints: 0
console.log(buf.lastIndexOf('buffer'))
// Prints: 17
console.log(buf.lastIndexOf(Buffer.from('buffer')))
// Prints: 17
console.log(buf.lastIndexOf(97))
// Prints: 15 (97 is the decimal ASCII value for 'a')
console.log(buf.lastIndexOf(Buffer.from('yolo')))
// Prints: -1
console.log(buf.lastIndexOf('buffer', 5))
// Prints: 5
console.log(buf.lastIndexOf('buffer', 4))
// Prints: -1

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le')

console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le'))
// Prints: 6
console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'))
// Prints: 4
```

If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,
an integer between 0 and 255.

If `byteOffset` is not a number, it will be coerced to a number. Any arguments
that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.
This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).

```js
import { Buffer } from 'buffer'

const b = Buffer.from('abcdef')

// Passing a value that's a number, but not a valid byte.
// Prints: 2, equivalent to searching for 99 or 'c'.
console.log(b.lastIndexOf(99.9))
console.log(b.lastIndexOf(256 + 99))

// Passing a byteOffset that coerces to NaN.
// Prints: 1, searching the whole buffer.
console.log(b.lastIndexOf('b', undefined))
console.log(b.lastIndexOf('b', {}))

// Passing a byteOffset that coerces to 0.
// Prints: -1, equivalent to passing 0.
console.log(b.lastIndexOf('b', null))
console.log(b.lastIndexOf('b', []))
```

If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.

</p>
  <details id="value$4231" title="Parameter" ><summary><span><a href="#value$4231">#</a></span>  <code><strong>value</strong></code>     &ndash; What to search for.</summary>    <ul><p>string | number | <span>Uint8Array</span></p>        </ul></details><details id="byteOffset$4232" title="Parameter" ><summary><span><a href="#byteOffset$4232">#</a></span>  <code><strong>byteOffset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$4233" title="Parameter" ><summary><span><a href="#encoding$4233">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>lastIndexOf</strong><em>(value, byteOffset, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readBigInt64BE$4047" title="Method" ><summary><span><a href="#readBigInt64BE$4047">#</a></span>  <code><strong>readBigInt64BE</strong></code><em>(offset)</em>     &ndash; Reads a signed, big-endian 64-bit integer from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed
values.

</p>
  <details id="offset$4049" title="Parameter" ><summary><span><a href="#offset$4049">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigInt64BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readBigInt64LE$4050" title="Method" ><summary><span><a href="#readBigInt64LE$4050">#</a></span>  <code><strong>readBigInt64LE</strong></code><em>(offset)</em>     &ndash; Reads a signed, little-endian 64-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed
values.

</p>
  <details id="offset$4052" title="Parameter" ><summary><span><a href="#offset$4052">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigInt64LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readBigUInt64BE$4035" title="Method" ><summary><span><a href="#readBigUInt64BE$4035">#</a></span>  <code><strong>readBigUInt64BE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, big-endian 64-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readBigUint64BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff])

console.log(buf.readBigUInt64BE(0))
// Prints: 4294967295n
```

</p>
  <details id="offset$4037" title="Parameter" ><summary><span><a href="#offset$4037">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigUInt64BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readBigUInt64LE$4041" title="Method" ><summary><span><a href="#readBigUInt64LE$4041">#</a></span>  <code><strong>readBigUInt64LE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, little-endian 64-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readBigUint64LE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff])

console.log(buf.readBigUInt64LE(0))
// Prints: 18446744069414584320n
```

</p>
  <details id="offset$4043" title="Parameter" ><summary><span><a href="#offset$4043">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigUInt64LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readBigUint64BE$4038" title="Method" ><summary><span><a href="#readBigUint64BE$4038">#</a></span>  <code><strong>readBigUint64BE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4040" title="Parameter" ><summary><span><a href="#offset$4040">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigUint64BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readBigUint64LE$4044" title="Method" ><summary><span><a href="#readBigUint64LE$4044">#</a></span>  <code><strong>readBigUint64LE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4046" title="Parameter" ><summary><span><a href="#offset$4046">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readBigUint64LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>bigint</ul></p></p>    </ul></details><details id="readDoubleBE$4131" title="Method" ><summary><span><a href="#readDoubleBE$4131">#</a></span>  <code><strong>readDoubleBE</strong></code><em>(offset)</em>     &ndash; Reads a 64-bit, big-endian double from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8])

console.log(buf.readDoubleBE(0))
// Prints: 8.20788039913184e-304
```

</p>
  <details id="offset$4133" title="Parameter" ><summary><span><a href="#offset$4133">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readDoubleBE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readDoubleLE$4128" title="Method" ><summary><span><a href="#readDoubleLE$4128">#</a></span>  <code><strong>readDoubleLE</strong></code><em>(offset)</em>     &ndash; Reads a 64-bit, little-endian double from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8])

console.log(buf.readDoubleLE(0))
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4130" title="Parameter" ><summary><span><a href="#offset$4130">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readDoubleLE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readFloatBE$4125" title="Method" ><summary><span><a href="#readFloatBE$4125">#</a></span>  <code><strong>readFloatBE</strong></code><em>(offset)</em>     &ndash; Reads a 32-bit, big-endian float from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([1, 2, 3, 4])

console.log(buf.readFloatBE(0))
// Prints: 2.387939260590663e-38
```

</p>
  <details id="offset$4127" title="Parameter" ><summary><span><a href="#offset$4127">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readFloatBE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readFloatLE$4122" title="Method" ><summary><span><a href="#readFloatLE$4122">#</a></span>  <code><strong>readFloatLE</strong></code><em>(offset)</em>     &ndash; Reads a 32-bit, little-endian float from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([1, 2, 3, 4])

console.log(buf.readFloatLE(0))
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4124" title="Parameter" ><summary><span><a href="#offset$4124">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readFloatLE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readInt16BE$4113" title="Method" ><summary><span><a href="#readInt16BE$4113">#</a></span>  <code><strong>readInt16BE</strong></code><em>(offset)</em>     &ndash; Reads a signed, big-endian 16-bit integer from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed values.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0, 5])

console.log(buf.readInt16BE(0))
// Prints: 5
```

</p>
  <details id="offset$4115" title="Parameter" ><summary><span><a href="#offset$4115">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readInt16BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readInt16LE$4110" title="Method" ><summary><span><a href="#readInt16LE$4110">#</a></span>  <code><strong>readInt16LE</strong></code><em>(offset)</em>     &ndash; Reads a signed, little-endian 16-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed values.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0, 5])

console.log(buf.readInt16LE(0))
// Prints: 1280
console.log(buf.readInt16LE(1))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4112" title="Parameter" ><summary><span><a href="#offset$4112">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readInt16LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readInt32BE$4119" title="Method" ><summary><span><a href="#readInt32BE$4119">#</a></span>  <code><strong>readInt32BE</strong></code><em>(offset)</em>     &ndash; Reads a signed, big-endian 32-bit integer from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed values.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0, 0, 0, 5])

console.log(buf.readInt32BE(0))
// Prints: 5
```

</p>
  <details id="offset$4121" title="Parameter" ><summary><span><a href="#offset$4121">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readInt32BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readInt32LE$4116" title="Method" ><summary><span><a href="#readInt32LE$4116">#</a></span>  <code><strong>readInt32LE</strong></code><em>(offset)</em>     &ndash; Reads a signed, little-endian 32-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed values.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0, 0, 0, 5])

console.log(buf.readInt32LE(0))
// Prints: 83886080
console.log(buf.readInt32LE(1))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4118" title="Parameter" ><summary><span><a href="#offset$4118">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readInt32LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readInt8$4107" title="Method" ><summary><span><a href="#readInt8$4107">#</a></span>  <code><strong>readInt8</strong></code><em>(offset)</em>     &ndash; Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

Integers read from a `Buffer` are interpreted as two's complement signed values.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([-1, 5])

console.log(buf.readInt8(0))
// Prints: -1
console.log(buf.readInt8(1))
// Prints: 5
console.log(buf.readInt8(2))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4109" title="Parameter" ><summary><span><a href="#offset$4109">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readInt8</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readIntBE$4073" title="Method" ><summary><span><a href="#readIntBE$4073">#</a></span>  <code><strong>readIntBE</strong></code><em>(offset, byteLength)</em>     &ndash; Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>and interprets the result as a big-endian, two's complement signed value
supporting up to 48 bits of accuracy.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab])

console.log(buf.readIntBE(0, 6).toString(16))
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16))
// Throws ERR_OUT_OF_RANGE.
console.log(buf.readIntBE(1, 0).toString(16))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4075" title="Parameter" ><summary><span><a href="#offset$4075">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4076" title="Parameter" ><summary><span><a href="#byteLength$4076">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>readIntBE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readIntLE$4069" title="Method" ><summary><span><a href="#readIntLE$4069">#</a></span>  <code><strong>readIntLE</strong></code><em>(offset, byteLength)</em>     &ndash; Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>and interprets the result as a little-endian, two's complement signed value
supporting up to 48 bits of accuracy.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab])

console.log(buf.readIntLE(0, 6).toString(16))
// Prints: -546f87a9cbee
```

</p>
  <details id="offset$4071" title="Parameter" ><summary><span><a href="#offset$4071">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4072" title="Parameter" ><summary><span><a href="#byteLength$4072">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>readIntLE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUInt16BE$4089" title="Method" ><summary><span><a href="#readUInt16BE$4089">#</a></span>  <code><strong>readUInt16BE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, big-endian 16-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readUint16BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56])

console.log(buf.readUInt16BE(0).toString(16))
// Prints: 1234
console.log(buf.readUInt16BE(1).toString(16))
// Prints: 3456
```

</p>
  <details id="offset$4091" title="Parameter" ><summary><span><a href="#offset$4091">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUInt16BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUInt16LE$4083" title="Method" ><summary><span><a href="#readUInt16LE$4083">#</a></span>  <code><strong>readUInt16LE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, little-endian 16-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readUint16LE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56])

console.log(buf.readUInt16LE(0).toString(16))
// Prints: 3412
console.log(buf.readUInt16LE(1).toString(16))
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4085" title="Parameter" ><summary><span><a href="#offset$4085">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUInt16LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUInt32BE$4101" title="Method" ><summary><span><a href="#readUInt32BE$4101">#</a></span>  <code><strong>readUInt32BE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, big-endian 32-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readUint32BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78])

console.log(buf.readUInt32BE(0).toString(16))
// Prints: 12345678
```

</p>
  <details id="offset$4103" title="Parameter" ><summary><span><a href="#offset$4103">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUInt32BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUInt32LE$4095" title="Method" ><summary><span><a href="#readUInt32LE$4095">#</a></span>  <code><strong>readUInt32LE</strong></code><em>(offset)</em>     &ndash; Reads an unsigned, little-endian 32-bit integer from <code>buf</code> at the specified<code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readUint32LE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78])

console.log(buf.readUInt32LE(0).toString(16))
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4097" title="Parameter" ><summary><span><a href="#offset$4097">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUInt32LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUInt8$4077" title="Method" ><summary><span><a href="#readUInt8$4077">#</a></span>  <code><strong>readUInt8</strong></code><em>(offset)</em>     &ndash; Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</summary>    <ul>    <p>  <p>

This function is also available under the `readUint8` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([1, -2])

console.log(buf.readUInt8(0))
// Prints: 1
console.log(buf.readUInt8(1))
// Prints: 254
console.log(buf.readUInt8(2))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4079" title="Parameter" ><summary><span><a href="#offset$4079">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUInt8</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUIntBE$4061" title="Method" ><summary><span><a href="#readUIntBE$4061">#</a></span>  <code><strong>readUIntBE</strong></code><em>(offset, byteLength)</em>     &ndash; Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>and interprets the result as an unsigned big-endian integer supporting
up to 48 bits of accuracy.</summary>    <ul>    <p>  <p>

This function is also available under the `readUintBE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab])

console.log(buf.readUIntBE(0, 6).toString(16))
// Prints: 1234567890ab
console.log(buf.readUIntBE(1, 6).toString(16))
// Throws ERR_OUT_OF_RANGE.
```

</p>
  <details id="offset$4063" title="Parameter" ><summary><span><a href="#offset$4063">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4064" title="Parameter" ><summary><span><a href="#byteLength$4064">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUIntBE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUIntLE$4053" title="Method" ><summary><span><a href="#readUIntLE$4053">#</a></span>  <code><strong>readUIntLE</strong></code><em>(offset, byteLength)</em>     &ndash; Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>and interprets the result as an unsigned, little-endian integer supporting
up to 48 bits of accuracy.</summary>    <ul>    <p>  <p>

This function is also available under the `readUintLE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab])

console.log(buf.readUIntLE(0, 6).toString(16))
// Prints: ab9078563412
```

</p>
  <details id="offset$4055" title="Parameter" ><summary><span><a href="#offset$4055">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4056" title="Parameter" ><summary><span><a href="#byteLength$4056">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUIntLE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUint16BE$4092" title="Method" ><summary><span><a href="#readUint16BE$4092">#</a></span>  <code><strong>readUint16BE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4094" title="Parameter" ><summary><span><a href="#offset$4094">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUint16BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUint16LE$4086" title="Method" ><summary><span><a href="#readUint16LE$4086">#</a></span>  <code><strong>readUint16LE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4088" title="Parameter" ><summary><span><a href="#offset$4088">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUint16LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUint32BE$4104" title="Method" ><summary><span><a href="#readUint32BE$4104">#</a></span>  <code><strong>readUint32BE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4106" title="Parameter" ><summary><span><a href="#offset$4106">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUint32BE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUint32LE$4098" title="Method" ><summary><span><a href="#readUint32LE$4098">#</a></span>  <code><strong>readUint32LE</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4100" title="Parameter" ><summary><span><a href="#offset$4100">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUint32LE</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUint8$4080" title="Method" ><summary><span><a href="#readUint8$4080">#</a></span>  <code><strong>readUint8</strong></code><em>(offset)</em>    </summary>    <ul>    <p>    <details id="offset$4082" title="Parameter" ><summary><span><a href="#offset$4082">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUint8</strong><em>(offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUintBE$4065" title="Method" ><summary><span><a href="#readUintBE$4065">#</a></span>  <code><strong>readUintBE</strong></code><em>(offset, byteLength)</em>    </summary>    <ul>    <p>    <details id="offset$4067" title="Parameter" ><summary><span><a href="#offset$4067">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4068" title="Parameter" ><summary><span><a href="#byteLength$4068">#</a></span>  <code><strong>byteLength</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUintBE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="readUintLE$4057" title="Method" ><summary><span><a href="#readUintLE$4057">#</a></span>  <code><strong>readUintLE</strong></code><em>(offset, byteLength)</em>    </summary>    <ul>    <p>    <details id="offset$4059" title="Parameter" ><summary><span><a href="#offset$4059">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4060" title="Parameter" ><summary><span><a href="#byteLength$4060">#</a></span>  <code><strong>byteLength</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>readUintLE</strong><em>(offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="reverse$4134" title="Method" ><summary><span><a href="#reverse$4134">#</a></span>  <code><strong>reverse</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>reverse</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="slice$3973" title="Method" ><summary><span><a href="#slice$3973">#</a></span>  <code><strong>slice</strong></code><em>(start, end)</em>     &ndash; Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</summary>    <ul>    <p>  <p>

This is the same behavior as `buf.subarray()`.

This method is not compatible with the `Uint8Array.prototype.slice()`,
which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('buffer')

const copiedBuf = Uint8Array.prototype.slice.call(buf)
copiedBuf[0]++
console.log(copiedBuf.toString())
// Prints: cuffer

console.log(buf.toString())
// Prints: buffer
```

</p>
  <details id="start$3975" title="Parameter" ><summary><span><a href="#start$3975">#</a></span>  <code><strong>start</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="end$3976" title="Parameter" ><summary><span><a href="#end$3976">#</a></span>  <code><strong>end</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>slice</strong><em>(start, end)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="subarray$3977" title="Method" ><summary><span><a href="#subarray$3977">#</a></span>  <code><strong>subarray</strong></code><em>(start, end)</em>     &ndash; Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</summary>    <ul>    <p>  <p>

Specifying `end` greater than `buf.length` will return the same result as
that of `end` equal to `buf.length`.

This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).

Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.

```js
import { Buffer } from 'buffer'

// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
// from the original `Buffer`.

const buf1 = Buffer.allocUnsafe(26)

for (let i = 0; i < 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97
}

const buf2 = buf1.subarray(0, 3)

console.log(buf2.toString('ascii', 0, buf2.length))
// Prints: abc

buf1[0] = 33

console.log(buf2.toString('ascii', 0, buf2.length))
// Prints: !bc
```

Specifying negative indexes causes the slice to be generated relative to the
end of `buf` rather than the beginning.

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('buffer')

console.log(buf.subarray(-6, -1).toString())
// Prints: buffe
// (Equivalent to buf.subarray(0, 5).)

console.log(buf.subarray(-6, -2).toString())
// Prints: buff
// (Equivalent to buf.subarray(0, 4).)

console.log(buf.subarray(-5, -2).toString())
// Prints: uff
// (Equivalent to buf.subarray(1, 4).)
```

</p>
  <details id="start$3979" title="Parameter" ><summary><span><a href="#start$3979">#</a></span>  <code><strong>start</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="end$3980" title="Parameter" ><summary><span><a href="#end$3980">#</a></span>  <code><strong>end</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>subarray</strong><em>(start, end)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="swap16$4136" title="Method" ><summary><span><a href="#swap16$4136">#</a></span>  <code><strong>swap16</strong></code><em>()</em>     &ndash; Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the
byte order <em>in-place</em>. Throws <code>ERR_INVALID_BUFFER_SIZE</code> if <code>buf.length</code> is not a multiple of 2.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8])

console.log(buf1)
// Prints: <Buffer 01 02 03 04 05 06 07 08>

buf1.swap16()

console.log(buf1)
// Prints: <Buffer 02 01 04 03 06 05 08 07>

const buf2 = Buffer.from([0x1, 0x2, 0x3])

buf2.swap16()
// Throws ERR_INVALID_BUFFER_SIZE.
```

One convenient use of `buf.swap16()` is to perform a fast in-place conversion
between UTF-16 little-endian and UTF-16 big-endian:

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('This is little-endian UTF-16', 'utf16le')
buf.swap16() // Convert to big-endian UTF-16 text.
```

</p>
    <p><strong>swap16</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="swap32$4138" title="Method" ><summary><span><a href="#swap32$4138">#</a></span>  <code><strong>swap32</strong></code><em>()</em>     &ndash; Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the
byte order <em>in-place</em>. Throws <code>ERR_INVALID_BUFFER_SIZE</code> if <code>buf.length</code> is not a multiple of 4.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8])

console.log(buf1)
// Prints: <Buffer 01 02 03 04 05 06 07 08>

buf1.swap32()

console.log(buf1)
// Prints: <Buffer 04 03 02 01 08 07 06 05>

const buf2 = Buffer.from([0x1, 0x2, 0x3])

buf2.swap32()
// Throws ERR_INVALID_BUFFER_SIZE.
```

</p>
    <p><strong>swap32</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="swap64$4140" title="Method" ><summary><span><a href="#swap64$4140">#</a></span>  <code><strong>swap64</strong></code><em>()</em>     &ndash; Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte order <em>in-place</em>.
Throws <code>ERR_INVALID_BUFFER_SIZE</code> if <code>buf.length</code> is not a multiple of 8.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8])

console.log(buf1)
// Prints: <Buffer 01 02 03 04 05 06 07 08>

buf1.swap64()

console.log(buf1)
// Prints: <Buffer 08 07 06 05 04 03 02 01>

const buf2 = Buffer.from([0x1, 0x2, 0x3])

buf2.swap64()
// Throws ERR_INVALID_BUFFER_SIZE.
```

</p>
    <p><strong>swap64</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="toJSON$3952" title="Method" ><summary><span><a href="#toJSON$3952">#</a></span>  <code><strong>toJSON</strong></code><em>()</em>     &ndash; Returns a JSON representation of <code>buf</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> implicitly calls
this function when stringifying a <code>Buffer</code> instance.</summary>    <ul>    <p>  <p>

`Buffer.from()` accepts objects in the format returned from this method.
In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.

```js
import { Buffer } from 'buffer';

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

console.log(json);
// Prints: {"type":"Buffer","data":[1,2,3,4,5]}

const copy = JSON.parse(json, (key, value) => {
  return value &#x26;&#x26; value.type === 'Buffer' ?
    Buffer.from(value) :
    value;
});

console.log(copy);
// Prints: <Buffer 01 02 03 04 05>
```

</p>
    <p><strong>toJSON</strong><em>()</em>  &nbsp;=&gt;  <ul>{<p>  <details id="data$3956" title="Property" ><summary><span><a href="#data$3956">#</a></span>  <code><strong>data</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L632">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L632</a>  <ul><p>number  []</p>        </ul></details><details id="type$3955" title="Property" ><summary><span><a href="#type$3955">#</a></span>  <code><strong>type</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L631">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L631</a>  <ul><p><code>"Buffer"</code></p>        </ul></details></p>}</ul></p></p>    </ul></details><details id="toString$3947" title="Method" ><summary><span><a href="#toString$3947">#</a></span>  <code><strong>toString</strong></code><em>(encoding, start, end)</em>     &ndash; Decodes <code>buf</code> to a string according to the specified character encoding in<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</summary>    <ul>    <p>  <p>

If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,
then each invalid byte is replaced with the replacement character `U+FFFD`.

The maximum length of a string instance (in UTF-16 code units) is available
as {@link constants.MAX_STRING_LENGTH}.

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.allocUnsafe(26)

for (let i = 0; i < 26; i++) {
  // 97 is the decimal ASCII value for 'a'.
  buf1[i] = i + 97
}

console.log(buf1.toString('utf8'))
// Prints: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('utf8', 0, 5))
// Prints: abcde

const buf2 = Buffer.from('tést')

console.log(buf2.toString('hex'))
// Prints: 74c3a97374
console.log(buf2.toString('utf8', 0, 3))
// Prints: té
console.log(buf2.toString(undefined, 0, 3))
// Prints: té
```

</p>
  <details id="encoding$3949" title="Parameter" ><summary><span><a href="#encoding$3949">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="start$3950" title="Parameter" ><summary><span><a href="#start$3950">#</a></span>  <code><strong>start</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="end$3951" title="Parameter" ><summary><span><a href="#end$3951">#</a></span>  <code><strong>end</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>toString</strong><em>(encoding, start, end)</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="values$4243" title="Method" ><summary><span><a href="#values$4243">#</a></span>  <code><strong>values</strong></code><em>()</em>     &ndash; Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterator</a> for <code>buf</code> values (bytes). This function is
called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.from('buffer')

for (const value of buf.values()) {
  console.log(value)
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (const value of buf) {
  console.log(value)
}
// Prints:
//   98
//   117
//   102
//   102
//   101
//   114
```

</p>
    <p><strong>values</strong><em>()</em>  &nbsp;=&gt;  <ul><span>IterableIterator</span>&lt;number&gt;</ul></p></p>    </ul></details><details id="write$3934" title="Method" ><summary><span><a href="#write$3934">#</a></span>  <code><strong>write</strong></code><em>(string, encoding)</em>     &ndash; Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in<code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did
not contain enough space to fit the entire string, only part of <code>string</code> will be
written. However, partially encoded characters will not be written.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.alloc(256)

const len = buf.write('\u00bd + \u00bc = \u00be', 0)

console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`)
// Prints: 12 bytes: ½ + ¼ = ¾

const buffer = Buffer.alloc(10)

const length = buffer.write('abcd', 8)

console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`)
// Prints: 2 bytes : ab
```

</p>
  <details id="string$3936" title="Parameter" ><summary><span><a href="#string$3936">#</a></span>  <code><strong>string</strong></code>     &ndash; String to write to <code>buf</code>.</summary>    <ul><p>string</p>        </ul></details><details id="encoding$3937" title="Parameter" ><summary><span><a href="#encoding$3937">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>write</strong><em>(string, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p>  <details id="string$3939" title="Parameter" ><summary><span><a href="#string$3939">#</a></span>  <code><strong>string</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="offset$3940" title="Parameter" ><summary><span><a href="#offset$3940">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$3941" title="Parameter" ><summary><span><a href="#encoding$3941">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>write</strong><em>(string, offset, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p>  <details id="string$3943" title="Parameter" ><summary><span><a href="#string$3943">#</a></span>  <code><strong>string</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="offset$3944" title="Parameter" ><summary><span><a href="#offset$3944">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="length$3945" title="Parameter" ><summary><span><a href="#length$3945">#</a></span>  <code><strong>length</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="encoding$3946" title="Parameter" ><summary><span><a href="#encoding$3946">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>write</strong><em>(string, offset, length, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigInt64BE$3981" title="Method" ><summary><span><a href="#writeBigInt64BE$3981">#</a></span>  <code><strong>writeBigInt64BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.</summary>    <ul>    <p>  <p>

`value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeBigInt64BE(0x0102030405060708n, 0)

console.log(buf)
// Prints: <Buffer 01 02 03 04 05 06 07 08>
```

</p>
  <details id="value$3983" title="Parameter" ><summary><span><a href="#value$3983">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>bigint</p>        </ul></details><details id="offset$3984" title="Parameter" ><summary><span><a href="#offset$3984">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigInt64BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigInt64LE$3985" title="Method" ><summary><span><a href="#writeBigInt64LE$3985">#</a></span>  <code><strong>writeBigInt64LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian.</summary>    <ul>    <p>  <p>

`value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeBigInt64LE(0x0102030405060708n, 0)

console.log(buf)
// Prints: <Buffer 08 07 06 05 04 03 02 01>
```

</p>
  <details id="value$3987" title="Parameter" ><summary><span><a href="#value$3987">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>bigint</p>        </ul></details><details id="offset$3988" title="Parameter" ><summary><span><a href="#offset$3988">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigInt64LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigUInt64BE$3989" title="Method" ><summary><span><a href="#writeBigUInt64BE$3989">#</a></span>  <code><strong>writeBigUInt64BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.</summary>    <ul>    <p>  <p>

This function is also available under the `writeBigUint64BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeBigUInt64BE(0xdecafafecacefaden, 0)

console.log(buf)
// Prints: <Buffer de ca fa fe ca ce fa de>
```

</p>
  <details id="value$3991" title="Parameter" ><summary><span><a href="#value$3991">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>bigint</p>        </ul></details><details id="offset$3992" title="Parameter" ><summary><span><a href="#offset$3992">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigUInt64BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigUInt64LE$3997" title="Method" ><summary><span><a href="#writeBigUInt64LE$3997">#</a></span>  <code><strong>writeBigUInt64LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeBigUInt64LE(0xdecafafecacefaden, 0)

console.log(buf)
// Prints: <Buffer de fa ce ca fe fa ca de>
```

This function is also available under the `writeBigUint64LE` alias.

</p>
  <details id="value$3999" title="Parameter" ><summary><span><a href="#value$3999">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>bigint</p>        </ul></details><details id="offset$4000" title="Parameter" ><summary><span><a href="#offset$4000">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigUInt64LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigUint64BE$3993" title="Method" ><summary><span><a href="#writeBigUint64BE$3993">#</a></span>  <code><strong>writeBigUint64BE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$3995" title="Parameter" ><summary><span><a href="#value$3995">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>bigint</p>        </ul></details><details id="offset$3996" title="Parameter" ><summary><span><a href="#offset$3996">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigUint64BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeBigUint64LE$4001" title="Method" ><summary><span><a href="#writeBigUint64LE$4001">#</a></span>  <code><strong>writeBigUint64LE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4003" title="Parameter" ><summary><span><a href="#value$4003">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>bigint</p>        </ul></details><details id="offset$4004" title="Parameter" ><summary><span><a href="#offset$4004">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeBigUint64LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeDoubleBE$4214" title="Method" ><summary><span><a href="#writeDoubleBE$4214">#</a></span>  <code><strong>writeDoubleBE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>must be a JavaScript number. Behavior is undefined when <code>value</code> is anything
other than a JavaScript number.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeDoubleBE(123.456, 0)

console.log(buf)
// Prints: <Buffer 40 5e dd 2f 1a 9f be 77>
```

</p>
  <details id="value$4216" title="Parameter" ><summary><span><a href="#value$4216">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4217" title="Parameter" ><summary><span><a href="#offset$4217">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeDoubleBE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeDoubleLE$4210" title="Method" ><summary><span><a href="#writeDoubleLE$4210">#</a></span>  <code><strong>writeDoubleLE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>must be a JavaScript number. Behavior is undefined when <code>value</code> is anything
other than a JavaScript number.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(8)

buf.writeDoubleLE(123.456, 0)

console.log(buf)
// Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>
```

</p>
  <details id="value$4212" title="Parameter" ><summary><span><a href="#value$4212">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4213" title="Parameter" ><summary><span><a href="#offset$4213">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeDoubleLE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeFloatBE$4206" title="Method" ><summary><span><a href="#writeFloatBE$4206">#</a></span>  <code><strong>writeFloatBE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. Behavior is
undefined when <code>value</code> is anything other than a JavaScript number.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeFloatBE(0xcafebabe, 0)

console.log(buf)
// Prints: <Buffer 4f 4a fe bb>
```

</p>
  <details id="value$4208" title="Parameter" ><summary><span><a href="#value$4208">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4209" title="Parameter" ><summary><span><a href="#offset$4209">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeFloatBE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeFloatLE$4202" title="Method" ><summary><span><a href="#writeFloatLE$4202">#</a></span>  <code><strong>writeFloatLE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. Behavior is
undefined when <code>value</code> is anything other than a JavaScript number.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeFloatLE(0xcafebabe, 0)

console.log(buf)
// Prints: <Buffer bb fe 4a 4f>
```

</p>
  <details id="value$4204" title="Parameter" ><summary><span><a href="#value$4204">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4205" title="Parameter" ><summary><span><a href="#offset$4205">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeFloatLE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeInt16BE$4190" title="Method" ><summary><span><a href="#writeInt16BE$4190">#</a></span>  <code><strong>writeInt16BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian.  The <code>value</code>must be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is
anything other than a signed 16-bit integer.</summary>    <ul>    <p>  <p>

The `value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(2)

buf.writeInt16BE(0x0102, 0)

console.log(buf)
// Prints: <Buffer 01 02>
```

</p>
  <details id="value$4192" title="Parameter" ><summary><span><a href="#value$4192">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4193" title="Parameter" ><summary><span><a href="#offset$4193">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeInt16BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeInt16LE$4186" title="Method" ><summary><span><a href="#writeInt16LE$4186">#</a></span>  <code><strong>writeInt16LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian.  The <code>value</code>must be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is
anything other than a signed 16-bit integer.</summary>    <ul>    <p>  <p>

The `value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(2)

buf.writeInt16LE(0x0304, 0)

console.log(buf)
// Prints: <Buffer 04 03>
```

</p>
  <details id="value$4188" title="Parameter" ><summary><span><a href="#value$4188">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4189" title="Parameter" ><summary><span><a href="#offset$4189">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeInt16LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeInt32BE$4198" title="Method" ><summary><span><a href="#writeInt32BE$4198">#</a></span>  <code><strong>writeInt32BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>must be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is
anything other than a signed 32-bit integer.</summary>    <ul>    <p>  <p>

The `value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeInt32BE(0x01020304, 0)

console.log(buf)
// Prints: <Buffer 01 02 03 04>
```

</p>
  <details id="value$4200" title="Parameter" ><summary><span><a href="#value$4200">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4201" title="Parameter" ><summary><span><a href="#offset$4201">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeInt32BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeInt32LE$4194" title="Method" ><summary><span><a href="#writeInt32LE$4194">#</a></span>  <code><strong>writeInt32LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>must be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is
anything other than a signed 32-bit integer.</summary>    <ul>    <p>  <p>

The `value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeInt32LE(0x05060708, 0)

console.log(buf)
// Prints: <Buffer 08 07 06 05>
```

</p>
  <details id="value$4196" title="Parameter" ><summary><span><a href="#value$4196">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4197" title="Parameter" ><summary><span><a href="#offset$4197">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeInt32LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeInt8$4182" title="Method" ><summary><span><a href="#writeInt8$4182">#</a></span>  <code><strong>writeInt8</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</summary>    <ul>    <p>  <p>

`value` is interpreted and written as a two's complement signed integer.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(2)

buf.writeInt8(2, 0)
buf.writeInt8(-2, 1)

console.log(buf)
// Prints: <Buffer 02 fe>
```

</p>
  <details id="value$4184" title="Parameter" ><summary><span><a href="#value$4184">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4185" title="Parameter" ><summary><span><a href="#offset$4185">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeInt8</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeIntBE$4030" title="Method" ><summary><span><a href="#writeIntBE$4030">#</a></span>  <code><strong>writeIntBE</strong></code><em>(value, offset, byteLength)</em>     &ndash; Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when<code>value</code> is anything other than a
signed integer.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(6)

buf.writeIntBE(0x1234567890ab, 0, 6)

console.log(buf)
// Prints: <Buffer 12 34 56 78 90 ab>
```

</p>
  <details id="value$4032" title="Parameter" ><summary><span><a href="#value$4032">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4033" title="Parameter" ><summary><span><a href="#offset$4033">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4034" title="Parameter" ><summary><span><a href="#byteLength$4034">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeIntBE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeIntLE$4025" title="Method" ><summary><span><a href="#writeIntLE$4025">#</a></span>  <code><strong>writeIntLE</strong></code><em>(value, offset, byteLength)</em>     &ndash; Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
when <code>value</code> is anything other than a signed integer.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(6)

buf.writeIntLE(0x1234567890ab, 0, 6)

console.log(buf)
// Prints: <Buffer ab 90 78 56 34 12>
```

</p>
  <details id="value$4027" title="Parameter" ><summary><span><a href="#value$4027">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4028" title="Parameter" ><summary><span><a href="#offset$4028">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4029" title="Parameter" ><summary><span><a href="#byteLength$4029">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeIntLE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUInt16BE$4158" title="Method" ><summary><span><a href="#writeUInt16BE$4158">#</a></span>  <code><strong>writeUInt16BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>must be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code>is anything other than an
unsigned 16-bit integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUint16BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeUInt16BE(0xdead, 0)
buf.writeUInt16BE(0xbeef, 2)

console.log(buf)
// Prints: <Buffer de ad be ef>
```

</p>
  <details id="value$4160" title="Parameter" ><summary><span><a href="#value$4160">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4161" title="Parameter" ><summary><span><a href="#offset$4161">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUInt16BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUInt16LE$4150" title="Method" ><summary><span><a href="#writeUInt16LE$4150">#</a></span>  <code><strong>writeUInt16LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>must be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code> is
anything other than an unsigned 16-bit integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUint16LE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeUInt16LE(0xdead, 0)
buf.writeUInt16LE(0xbeef, 2)

console.log(buf)
// Prints: <Buffer ad de ef be>
```

</p>
  <details id="value$4152" title="Parameter" ><summary><span><a href="#value$4152">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4153" title="Parameter" ><summary><span><a href="#offset$4153">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUInt16LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUInt32BE$4174" title="Method" ><summary><span><a href="#writeUInt32BE$4174">#</a></span>  <code><strong>writeUInt32BE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code>must be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code>is anything other than an
unsigned 32-bit integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUint32BE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeUInt32BE(0xfeedface, 0)

console.log(buf)
// Prints: <Buffer fe ed fa ce>
```

</p>
  <details id="value$4176" title="Parameter" ><summary><span><a href="#value$4176">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4177" title="Parameter" ><summary><span><a href="#offset$4177">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUInt32BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUInt32LE$4166" title="Method" ><summary><span><a href="#writeUInt32LE$4166">#</a></span>  <code><strong>writeUInt32LE</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code>must be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code> is
anything other than an unsigned 32-bit integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUint32LE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeUInt32LE(0xfeedface, 0)

console.log(buf)
// Prints: <Buffer ce fa ed fe>
```

</p>
  <details id="value$4168" title="Parameter" ><summary><span><a href="#value$4168">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4169" title="Parameter" ><summary><span><a href="#offset$4169">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUInt32LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUInt8$4142" title="Method" ><summary><span><a href="#writeUInt8$4142">#</a></span>  <code><strong>writeUInt8</strong></code><em>(value, offset)</em>     &ndash; Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUint8` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(4)

buf.writeUInt8(0x3, 0)
buf.writeUInt8(0x4, 1)
buf.writeUInt8(0x23, 2)
buf.writeUInt8(0x42, 3)

console.log(buf)
// Prints: <Buffer 03 04 23 42>
```

</p>
  <details id="value$4144" title="Parameter" ><summary><span><a href="#value$4144">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4145" title="Parameter" ><summary><span><a href="#offset$4145">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUInt8</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUIntBE$4015" title="Method" ><summary><span><a href="#writeUIntBE$4015">#</a></span>  <code><strong>writeUIntBE</strong></code><em>(value, offset, byteLength)</em>     &ndash; Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined
when <code>value</code> is anything other than an unsigned integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUintBE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(6)

buf.writeUIntBE(0x1234567890ab, 0, 6)

console.log(buf)
// Prints: <Buffer 12 34 56 78 90 ab>
```

</p>
  <details id="value$4017" title="Parameter" ><summary><span><a href="#value$4017">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4018" title="Parameter" ><summary><span><a href="#offset$4018">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4019" title="Parameter" ><summary><span><a href="#byteLength$4019">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUIntBE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUIntLE$4005" title="Method" ><summary><span><a href="#writeUIntLE$4005">#</a></span>  <code><strong>writeUIntLE</strong></code><em>(value, offset, byteLength)</em>     &ndash; Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
when <code>value</code> is anything other than an unsigned integer.</summary>    <ul>    <p>  <p>

This function is also available under the `writeUintLE` alias.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(6)

buf.writeUIntLE(0x1234567890ab, 0, 6)

console.log(buf)
// Prints: <Buffer ab 90 78 56 34 12>
```

</p>
  <details id="value$4007" title="Parameter" ><summary><span><a href="#value$4007">#</a></span>  <code><strong>value</strong></code>     &ndash; Number to be written to <code>buf</code>.</summary>    <ul><p>number</p>        </ul></details><details id="offset$4008" title="Parameter" ><summary><span><a href="#offset$4008">#</a></span>  <code><strong>offset</strong></code>     &ndash; Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4009" title="Parameter" ><summary><span><a href="#byteLength$4009">#</a></span>  <code><strong>byteLength</strong></code>     &ndash; Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUIntLE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUint16BE$4162" title="Method" ><summary><span><a href="#writeUint16BE$4162">#</a></span>  <code><strong>writeUint16BE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4164" title="Parameter" ><summary><span><a href="#value$4164">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4165" title="Parameter" ><summary><span><a href="#offset$4165">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUint16BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUint16LE$4154" title="Method" ><summary><span><a href="#writeUint16LE$4154">#</a></span>  <code><strong>writeUint16LE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4156" title="Parameter" ><summary><span><a href="#value$4156">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4157" title="Parameter" ><summary><span><a href="#offset$4157">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUint16LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUint32BE$4178" title="Method" ><summary><span><a href="#writeUint32BE$4178">#</a></span>  <code><strong>writeUint32BE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4180" title="Parameter" ><summary><span><a href="#value$4180">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4181" title="Parameter" ><summary><span><a href="#offset$4181">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUint32BE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUint32LE$4170" title="Method" ><summary><span><a href="#writeUint32LE$4170">#</a></span>  <code><strong>writeUint32LE</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4172" title="Parameter" ><summary><span><a href="#value$4172">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4173" title="Parameter" ><summary><span><a href="#offset$4173">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUint32LE</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUint8$4146" title="Method" ><summary><span><a href="#writeUint8$4146">#</a></span>  <code><strong>writeUint8</strong></code><em>(value, offset)</em>    </summary>    <ul>    <p>    <details id="value$4148" title="Parameter" ><summary><span><a href="#value$4148">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4149" title="Parameter" ><summary><span><a href="#offset$4149">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUint8</strong><em>(value, offset)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUintBE$4020" title="Method" ><summary><span><a href="#writeUintBE$4020">#</a></span>  <code><strong>writeUintBE</strong></code><em>(value, offset, byteLength)</em>    </summary>    <ul>    <p>    <details id="value$4022" title="Parameter" ><summary><span><a href="#value$4022">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4023" title="Parameter" ><summary><span><a href="#offset$4023">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4024" title="Parameter" ><summary><span><a href="#byteLength$4024">#</a></span>  <code><strong>byteLength</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUintBE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="writeUintLE$4010" title="Method" ><summary><span><a href="#writeUintLE$4010">#</a></span>  <code><strong>writeUintLE</strong></code><em>(value, offset, byteLength)</em>    </summary>    <ul>    <p>    <details id="value$4012" title="Parameter" ><summary><span><a href="#value$4012">#</a></span>  <code><strong>value</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="offset$4013" title="Parameter" ><summary><span><a href="#offset$4013">#</a></span>  <code><strong>offset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="byteLength$4014" title="Parameter" ><summary><span><a href="#byteLength$4014">#</a></span>  <code><strong>byteLength</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>writeUintLE</strong><em>(value, offset, byteLength)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details></p></ul></details>  <details id="BufferConstructor$4251" title="Interface" ><summary><span><a href="#BufferConstructor$4251">#</a></span>  <code><strong>BufferConstructor</strong></code>     &ndash; Raw data is stored in instances of the Buffer class.
A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L181">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L181</a>  <ul>        <p>  <details id="constructor$4301" title="Constructor" ><summary><span><a href="#constructor$4301">#</a></span>  <code><strong>constructor</strong></code><em>(str, encoding)</em>     &ndash; Allocates a new buffer containing the given {str}.</summary>    <ul>    <p>  <details id="new BufferConstructor$4302" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4302">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Allocates a new buffer containing the given {str}.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="str$4303" title="Parameter" ><summary><span><a href="#str$4303">#</a></span>  <code><strong>str</strong></code>     &ndash; String to store in buffer.</summary>    <ul><p>string</p>        </ul></details><details id="encoding$4304" title="Parameter" ><summary><span><a href="#encoding$4304">#</a></span>  <code><strong>encoding</strong></code>     &ndash; encoding to use, optional.  Default is 'utf8'</summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details></p>  </ul></details><details id="new BufferConstructor$4305" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4305">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Allocates a new buffer of {size} octets.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="size$4306" title="Parameter" ><summary><span><a href="#size$4306">#</a></span>  <code><strong>size</strong></code>     &ndash; count of octets to allocate.</summary>    <ul><p>number</p>        </ul></details></p>  </ul></details><details id="new BufferConstructor$4307" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4307">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Allocates a new buffer containing the given {array} of octets.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="array$4308" title="Parameter" ><summary><span><a href="#array$4308">#</a></span>  <code><strong>array</strong></code>     &ndash; The octets to store.</summary>    <ul><p><span>Uint8Array</span></p>        </ul></details></p>  </ul></details><details id="new BufferConstructor$4309" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4309">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Produces a Buffer backed by the same allocated memory as
the given {ArrayBuffer}/{SharedArrayBuffer}.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="arrayBuffer$4310" title="Parameter" ><summary><span><a href="#arrayBuffer$4310">#</a></span>  <code><strong>arrayBuffer</strong></code>     &ndash; The ArrayBuffer with which to share memory.</summary>    <ul><p><span>ArrayBuffer</span> | <span>SharedArrayBuffer</span></p>        </ul></details></p>  </ul></details><details id="new BufferConstructor$4311" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4311">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Allocates a new buffer containing the given {array} of octets.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="array$4312" title="Parameter" ><summary><span><a href="#array$4312">#</a></span>  <code><strong>array</strong></code>     &ndash; The octets to store.</summary>    <ul><p>readonly     any  []</p>        </ul></details></p>  </ul></details><details id="new BufferConstructor$4313" title="ConstructorSignature" ><summary><span><a href="#new BufferConstructor$4313">#</a></span>  <code><strong>new BufferConstructor</strong></code><em>()</em>     &ndash; Copies the passed {buffer} data onto a new {Buffer} instance.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>      <p>  <details id="buffer$4314" title="Parameter" ><summary><span><a href="#buffer$4314">#</a></span>  <code><strong>buffer</strong></code>     &ndash; The buffer to copy.</summary>    <ul><p><a href="#Buffer$3932">Buffer</a></p>        </ul></details></p>  </ul></details></p>    </ul></details><details id="poolSize$4300" title="Property" ><summary><span><a href="#poolSize$4300">#</a></span>  <code><strong>poolSize</strong></code>     &ndash; This is the size (in bytes) of pre-allocated internal <code>Buffer</code> instances used
for pooling. This value may be modified.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L529">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L529</a>  <ul><p>number</p>        </ul></details><details id="alloc$4289" title="Method" ><summary><span><a href="#alloc$4289">#</a></span>  <code><strong>alloc</strong></code><em>(size, fill, encoding)</em>     &ndash; Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the<code>Buffer</code> will be zero-filled.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf = Buffer.alloc(5)

console.log(buf)
// Prints: <Buffer 00 00 00 00 00>
```

If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_INVALID_ARG_VALUE` is thrown.

If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.

```js
import { Buffer } from 'buffer'

const buf = Buffer.alloc(5, 'a')

console.log(buf)
// Prints: <Buffer 61 61 61 61 61>
```

If both `fill` and `encoding` are specified, the allocated `Buffer` will be
initialized by calling `buf.fill(fill, encoding)`.

```js
import { Buffer } from 'buffer'

const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64')

console.log(buf)
// Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
contents will never contain sensitive data from previous allocations, including
data that might not have been allocated for `Buffer`s.

A `TypeError` will be thrown if `size` is not a number.

</p>
  <details id="size$4291" title="Parameter" ><summary><span><a href="#size$4291">#</a></span>  <code><strong>size</strong></code>     &ndash; The desired length of the new <code>Buffer</code>.</summary>    <ul><p>number</p>        </ul></details><details id="fill$4292" title="Parameter" ><summary><span><a href="#fill$4292">#</a></span>  <code><strong>fill</strong></code>    </summary>    <ul><p>string | number | <a href="#Buffer$3932">Buffer</a></p>        </ul></details><details id="encoding$4293" title="Parameter" ><summary><span><a href="#encoding$4293">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>alloc</strong><em>(size, fill, encoding)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="allocUnsafe$4294" title="Method" ><summary><span><a href="#allocUnsafe$4294">#</a></span>  <code><strong>allocUnsafe</strong></code><em>(size)</em>     &ndash; Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than {@link constants.MAX_LENGTH} or smaller than 0, <code>ERR_INVALID_ARG_VALUE</code> is thrown.</summary>    <ul>    <p>  <p>

The underlying memory for `Buffer` instances created in this way is _not_
_initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.

```js
import { Buffer } from 'buffer'

const buf = Buffer.allocUnsafe(10)

console.log(buf)
// Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>

buf.fill(0)

console.log(buf)
// Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>
```

A `TypeError` will be thrown if `size` is not a number.

The `Buffer` module pre-allocates an internal `Buffer` instance of
size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`,`Buffer.from(array)`, `Buffer.concat()`, and the
deprecated`new Buffer(size)` constructor only when `size` is less than or equal
to `Buffer.poolSize >> 1` (floor of `Buffer.poolSize` divided by two).

Use of this pre-allocated internal memory pool is a key difference between
calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)` _will_ use the internal`Buffer` pool if `size` is less
than or equal to half `Buffer.poolSize`. The
difference is subtle but can be important when an application requires the
additional performance that `Buffer.allocUnsafe()` provides.

</p>
  <details id="size$4296" title="Parameter" ><summary><span><a href="#size$4296">#</a></span>  <code><strong>size</strong></code>     &ndash; The desired length of the new <code>Buffer</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>allocUnsafe</strong><em>(size)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="allocUnsafeSlow$4297" title="Method" ><summary><span><a href="#allocUnsafeSlow$4297">#</a></span>  <code><strong>allocUnsafeSlow</strong></code><em>(size)</em>     &ndash; Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than {@link constants.MAX_LENGTH} or smaller than 0, <code>ERR_INVALID_ARG_VALUE</code> is thrown. A zero-length <code>Buffer</code> is created
if <code>size</code> is 0.</summary>    <ul>    <p>  <p>

The underlying memory for `Buffer` instances created in this way is _not_
_initialized_. The contents of the newly created `Buffer` are unknown and_may contain sensitive data_. Use `buf.fill(0)` to initialize
such `Buffer` instances with zeroes.

When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
allocations under 4 KB are sliced from a single pre-allocated `Buffer`. This
allows applications to avoid the garbage collection overhead of creating many
individually allocated `Buffer` instances. This approach improves both
performance and memory usage by eliminating the need to track and clean up as
many individual `ArrayBuffer` objects.

However, in the case where a developer may need to retain a small chunk of
memory from a pool for an indeterminate amount of time, it may be appropriate
to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
then copying out the relevant bits.

```js
import { Buffer } from 'buffer'

// Need to keep around a few small chunks of memory.
const store = []

socket.on('readable', () => {
  let data
  while (null !== (data = readable.read())) {
    // Allocate for retained data.
    const sb = Buffer.allocUnsafeSlow(10)

    // Copy the data into the new allocation.
    data.copy(sb, 0, 0, 10)

    store.push(sb)
  }
})
```

A `TypeError` will be thrown if `size` is not a number.

</p>
  <details id="size$4299" title="Parameter" ><summary><span><a href="#size$4299">#</a></span>  <code><strong>size</strong></code>     &ndash; The desired length of the new <code>Buffer</code>.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>allocUnsafeSlow</strong><em>(size)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="byteLength$4277" title="Method" ><summary><span><a href="#byteLength$4277">#</a></span>  <code><strong>byteLength</strong></code><em>(string, encoding)</em>     &ndash; Returns the byte length of a string when encoded using <code>encoding</code>.
This is not the same as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length"><code>String.prototype.length</code></a>, which does not account
for the encoding that is used to convert the string into bytes.</summary>    <ul>    <p>  <p>

For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.
For strings that contain non-base64/hex-encoded data (e.g. whitespace), the
return value might be greater than the length of a `Buffer` created from the
string.

```js
import { Buffer } from 'buffer'

const str = '\u00bd + \u00bc = \u00be'

console.log(
  `${str}: ${str.length} characters, `
    + `${Buffer.byteLength(str, 'utf8')} bytes`
)
// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
```

When `string` is a
`Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-
Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-
er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.

</p>
  <details id="string$4279" title="Parameter" ><summary><span><a href="#string$4279">#</a></span>  <code><strong>string</strong></code>     &ndash; A value to calculate the length of.</summary>    <ul><p>string | <a href="#ArrayBufferView$3608">ArrayBufferView</a> | <span>ArrayBuffer</span> | <span>SharedArrayBuffer</span></p>        </ul></details><details id="encoding$4280" title="Parameter" ><summary><span><a href="#encoding$4280">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>byteLength</strong><em>(string, encoding)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="compare$4285" title="Method" ><summary><span><a href="#compare$4285">#</a></span>  <code><strong>compare</strong></code><em>(buf1, buf2)</em>     &ndash; Compares <code>buf1</code> to <code>buf2</code>, typically for the purpose of sorting arrays of<code>Buffer</code> instances. This is equivalent to calling <code>buf1.compare(buf2)</code>.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

const buf1 = Buffer.from('1234')
const buf2 = Buffer.from('0123')
const arr = [buf1, buf2]

console.log(arr.sort(Buffer.compare))
// Prints: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]
// (This result is equal to: [buf2, buf1].)
```

</p>
  <details id="buf1$4287" title="Parameter" ><summary><span><a href="#buf1$4287">#</a></span>  <code><strong>buf1</strong></code>    </summary>    <ul><p><span>Uint8Array</span></p>        </ul></details><details id="buf2$4288" title="Parameter" ><summary><span><a href="#buf2$4288">#</a></span>  <code><strong>buf2</strong></code>    </summary>    <ul><p><span>Uint8Array</span></p>        </ul></details>  <p><strong>compare</strong><em>(buf1, buf2)</em>  &nbsp;=&gt;  <ul><code>0</code> | <code>1</code> | <code>-1</code></ul></p></p>    </ul></details><details id="concat$4281" title="Method" ><summary><span><a href="#concat$4281">#</a></span>  <code><strong>concat</strong></code><em>(list, totalLength)</em>     &ndash; Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>instances in the <code>list</code> together.</summary>    <ul>    <p>  <p>

If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned.

If `totalLength` is not provided, it is calculated from the `Buffer` instances
in `list` by adding their lengths.

If `totalLength` is provided, it is coerced to an unsigned integer. If the
combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
truncated to `totalLength`.

```js
import { Buffer } from 'buffer'

// Create a single `Buffer` from a list of three `Buffer` instances.

const buf1 = Buffer.alloc(10)
const buf2 = Buffer.alloc(14)
const buf3 = Buffer.alloc(18)
const totalLength = buf1.length + buf2.length + buf3.length

console.log(totalLength)
// Prints: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength)

console.log(bufA)
// Prints: <Buffer 00 00 00 00 ...>
console.log(bufA.length)
// Prints: 42
```

`Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.

</p>
  <details id="list$4283" title="Parameter" ><summary><span><a href="#list$4283">#</a></span>  <code><strong>list</strong></code>     &ndash; List of <code>Buffer</code> or {@link Uint8Array} instances to concatenate.</summary>    <ul><p>readonly     <span>Uint8Array</span>  []</p>        </ul></details><details id="totalLength$4284" title="Parameter" ><summary><span><a href="#totalLength$4284">#</a></span>  <code><strong>totalLength</strong></code>     &ndash; Total length of the <code>Buffer</code> instances in <code>list</code> when concatenated.
</summary>    <ul><p>number</p>        </ul></details>  <p><strong>concat</strong><em>(list, totalLength)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="from$4252" title="Method" ><summary><span><a href="#from$4252">#</a></span>  <code><strong>from</strong></code><em>(arrayBuffer, byteOffset, length)</em>     &ndash; Allocates a new <code>Buffer</code> using an <code>array</code> of bytes in the range <code>0</code> – <code>255</code>.
Array entries outside that range will be truncated to fit into it.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

// Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72])
```

A `TypeError` will be thrown if `array` is not an `Array` or another type
appropriate for `Buffer.from()` variants.

`Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does.

</p>
  <details id="arrayBuffer$4254" title="Parameter" ><summary><span><a href="#arrayBuffer$4254">#</a></span>  <code><strong>arrayBuffer</strong></code>    </summary>    <ul><p><a href="#WithImplicitCoercion$4315">WithImplicitCoercion</a>&lt;<span>ArrayBuffer</span> | <span>SharedArrayBuffer</span>&gt;</p>        </ul></details><details id="byteOffset$4255" title="Parameter" ><summary><span><a href="#byteOffset$4255">#</a></span>  <code><strong>byteOffset</strong></code>    </summary>    <ul><p>number</p>        </ul></details><details id="length$4256" title="Parameter" ><summary><span><a href="#length$4256">#</a></span>  <code><strong>length</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>from</strong><em>(arrayBuffer, byteOffset, length)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p>  <details id="data$4258" title="Parameter" ><summary><span><a href="#data$4258">#</a></span>  <code><strong>data</strong></code>     &ndash; data to create a new Buffer
</summary>    <ul><p><span>Uint8Array</span> | readonly     number  []</p>        </ul></details>  <p><strong>from</strong><em>(data)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p>  <details id="data$4260" title="Parameter" ><summary><span><a href="#data$4260">#</a></span>  <code><strong>data</strong></code>    </summary>    <ul><p><a href="#WithImplicitCoercion$4315">WithImplicitCoercion</a>&lt;string | <span>Uint8Array</span> | readonly     number  []&gt;</p>        </ul></details>  <p><strong>from</strong><em>(data)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p>  <details id="str$4262" title="Parameter" ><summary><span><a href="#str$4262">#</a></span>  <code><strong>str</strong></code>    </summary>    <ul><p><a href="#WithImplicitCoercion$4315">WithImplicitCoercion</a>&lt;string&gt; | {<p>  <details id="[toPrimitive]$4264" title="Method" ><summary><span><a href="#[toPrimitive]$4264">#</a></span>  <code><strong>[toPrimitive]</strong></code><em>(hint)</em>    </summary>    <ul>    <p>    <details id="hint$4266" title="Parameter" ><summary><span><a href="#hint$4266">#</a></span>  <code><strong>hint</strong></code>    </summary>    <ul><p><code>"string"</code></p>        </ul></details>  <p><strong>[toPrimitive]</strong><em>(hint)</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details></p>}</p>        </ul></details><details id="encoding$4267" title="Parameter" ><summary><span><a href="#encoding$4267">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>from</strong><em>(str, encoding)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="isBuffer$4271" title="Method" ><summary><span><a href="#isBuffer$4271">#</a></span>  <code><strong>isBuffer</strong></code><em>(obj)</em>     &ndash; Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

Buffer.isBuffer(Buffer.alloc(10)) // true
Buffer.isBuffer(Buffer.from('foo')) // true
Buffer.isBuffer('a string') // false
Buffer.isBuffer([]) // false
Buffer.isBuffer(new Uint8Array(1024)) // false
```

</p>
  <details id="obj$4273" title="Parameter" ><summary><span><a href="#obj$4273">#</a></span>  <code><strong>obj</strong></code>    </summary>    <ul><p>any</p>        </ul></details>  <p><strong>isBuffer</strong><em>(obj)</em>  &nbsp;=&gt;  <ul>predicate</ul></p></p>    </ul></details><details id="isEncoding$4274" title="Method" ><summary><span><a href="#isEncoding$4274">#</a></span>  <code><strong>isEncoding</strong></code><em>(encoding)</em>     &ndash; Returns <code>true</code> if <code>encoding</code> is the name of a supported character encoding,
or <code>false</code> otherwise.</summary>    <ul>    <p>  <p>

```js
import { Buffer } from 'buffer'

console.log(Buffer.isEncoding('utf8'))
// Prints: true

console.log(Buffer.isEncoding('hex'))
// Prints: true

console.log(Buffer.isEncoding('utf/8'))
// Prints: false

console.log(Buffer.isEncoding(''))
// Prints: false
```

</p>
  <details id="encoding$4276" title="Parameter" ><summary><span><a href="#encoding$4276">#</a></span>  <code><strong>encoding</strong></code>     &ndash; A character encoding name to check.
</summary>    <ul><p>string</p>        </ul></details>  <p><strong>isEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul>predicate</ul></p></p>    </ul></details><details id="of$4268" title="Method" ><summary><span><a href="#of$4268">#</a></span>  <code><strong>of</strong></code><em>(items)</em>     &ndash; Creates a new Buffer using the passed {data}</summary>    <ul>    <p>    <details id="items$4270" title="Parameter" ><summary><span><a href="#items$4270">#</a></span>  <code><strong>items</strong></code>    </summary>    <ul><p>number  []</p>        </ul></details>  <p><strong>of</strong><em>(items)</em>  &nbsp;=&gt;  <ul><a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details></p></ul></details>  <details id="CommonOptions$104" title="Interface" ><summary><span><a href="#CommonOptions$104">#</a></span>  <code><strong>CommonOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L622">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L622</a>  <ul>        <p>  <details id="cwd$109" title="Property" ><summary><span><a href="#cwd$109">#</a></span>  <code><strong>cwd</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619</a>  <ul><p>string | <a href="#URL$73">URL</a></p>        </ul></details><details id="env$110" title="Property" ><summary><span><a href="#env$110">#</a></span>  <code><strong>env</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620</a>  <ul><p><a href="#ProcessEnv$100">ProcessEnv</a></p>        </ul></details><details id="gid$108" title="Property" ><summary><span><a href="#gid$108">#</a></span>  <code><strong>gid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618</a>  <ul><p>number</p>        </ul></details><details id="timeout$106" title="Property" ><summary><span><a href="#timeout$106">#</a></span>  <code><strong>timeout</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630</a>  <ul><p>number</p>        </ul></details><details id="uid$107" title="Property" ><summary><span><a href="#uid$107">#</a></span>  <code><strong>uid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617</a>  <ul><p>number</p>        </ul></details><details id="windowsHide$105" title="Property" ><summary><span><a href="#windowsHide$105">#</a></span>  <code><strong>windowsHide</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626</a>  <ul><p>boolean</p>        </ul></details></p></ul></details>  <details id="CommonSpawnOptions$58" title="Interface" ><summary><span><a href="#CommonSpawnOptions$58">#</a></span>  <code><strong>CommonSpawnOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L632">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L632</a>  <ul>        <p>  <details id="argv0$59" title="Property" ><summary><span><a href="#argv0$59">#</a></span>  <code><strong>argv0</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L633">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L633</a>  <ul><p>string</p>        </ul></details><details id="cwd$67" title="Property" ><summary><span><a href="#cwd$67">#</a></span>  <code><strong>cwd</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619</a>  <ul><p>string | <a href="#URL$73">URL</a></p>        </ul></details><details id="env$68" title="Property" ><summary><span><a href="#env$68">#</a></span>  <code><strong>env</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620</a>  <ul><p><a href="#ProcessEnv$100">ProcessEnv</a></p>        </ul></details><details id="gid$66" title="Property" ><summary><span><a href="#gid$66">#</a></span>  <code><strong>gid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618</a>  <ul><p>number</p>        </ul></details><details id="killSignal$70" title="Property" ><summary><span><a href="#killSignal$70">#</a></span>  <code><strong>killSignal</strong></code>     &ndash; The signal value to be used when the spawned process will be killed by the abort signal.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610</a>  <ul><p>number | <a href="#Signals$103">Signals</a></p>        </ul></details><details id="serialization$69" title="Property" ><summary><span><a href="#serialization$69">#</a></span>  <code><strong>serialization</strong></code>     &ndash; Specify the kind of serialization used for sending messages between processes.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605</a>  <ul><p><a href="#SerializationType$102">SerializationType</a></p>        </ul></details><details id="shell$61" title="Property" ><summary><span><a href="#shell$61">#</a></span>  <code><strong>shell</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L635">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L635</a>  <ul><p>string | boolean</p>        </ul></details><details id="signal$71" title="Property" ><summary><span><a href="#signal$71">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="stdio$60" title="Property" ><summary><span><a href="#stdio$60">#</a></span>  <code><strong>stdio</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L634">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L634</a>  <ul><p><a href="#StdioOptions$72">StdioOptions</a></p>        </ul></details><details id="timeout$64" title="Property" ><summary><span><a href="#timeout$64">#</a></span>  <code><strong>timeout</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630</a>  <ul><p>number</p>        </ul></details><details id="uid$65" title="Property" ><summary><span><a href="#uid$65">#</a></span>  <code><strong>uid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617</a>  <ul><p>number</p>        </ul></details><details id="windowsHide$63" title="Property" ><summary><span><a href="#windowsHide$63">#</a></span>  <code><strong>windowsHide</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626</a>  <ul><p>boolean</p>        </ul></details><details id="windowsVerbatimArguments$62" title="Property" ><summary><span><a href="#windowsVerbatimArguments$62">#</a></span>  <code><strong>windowsVerbatimArguments</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L636">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L636</a>  <ul><p>boolean</p>        </ul></details></p></ul></details>  <details id="DOMEventTarget$3280" title="Interface" ><summary><span><a href="#DOMEventTarget$3280">#</a></span>  <code><strong>DOMEventTarget</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L47">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L47</a>  <ul>        <p>  <details id="addEventListener$3281" title="Method" ><summary><span><a href="#addEventListener$3281">#</a></span>  <code><strong>addEventListener</strong></code><em>(eventName, listener, { once })</em>    </summary>    <ul>    <p>    <details id="eventName$3283" title="Parameter" ><summary><span><a href="#eventName$3283">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="listener$3284" title="Function" ><summary><span><a href="#listener$3284">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3287" title="Parameter" ><summary><span><a href="#args$3287">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="opts$3288" title="Parameter" ><summary><span><a href="#opts$3288">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p>{<p>  <details id="once$3290" title="Property" ><summary><span><a href="#once$3290">#</a></span>  <code><strong>once</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L52">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L52</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>addEventListener</strong><em>(eventName, listener, { once })</em>  &nbsp;=&gt;  <ul>any</ul></p></p>    </ul></details></p></ul></details>  <details id="Dict$232" title="Interface" ><summary><span><a href="#Dict$232">#</a></span>  <code><strong>Dict</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L287">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L287</a>  <ul>        </ul></details>  <details id="ErrnoException$4245" title="Interface" ><summary><span><a href="#ErrnoException$4245">#</a></span>  <code><strong>ErrnoException</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L193">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L193</a>  <ul>        <p>  <details id="code$4247" title="Property" ><summary><span><a href="#code$4247">#</a></span>  <code><strong>code</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L195">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L195</a>  <ul><p>string</p>        </ul></details><details id="errno$4246" title="Property" ><summary><span><a href="#errno$4246">#</a></span>  <code><strong>errno</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L194">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L194</a>  <ul><p>number</p>        </ul></details><details id="path$4248" title="Property" ><summary><span><a href="#path$4248">#</a></span>  <code><strong>path</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L196">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L196</a>  <ul><p>string</p>        </ul></details><details id="syscall$4249" title="Property" ><summary><span><a href="#syscall$4249">#</a></span>  <code><strong>syscall</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L197">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L197</a>  <ul><p>string</p>        </ul></details></p></ul></details>  <details id="EventEmitter$3291" title="Interface" ><summary><span><a href="#EventEmitter$3291">#</a></span>  <code><strong>EventEmitter</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L322">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L322</a>  <ul>        <p>  <details id="addListener$3292" title="Method" ><summary><span><a href="#addListener$3292">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3294" title="Parameter" ><summary><span><a href="#eventName$3294">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3295" title="Function" ><summary><span><a href="#listener$3295">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3298" title="Parameter" ><summary><span><a href="#args$3298">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="emit$3341" title="Method" ><summary><span><a href="#emit$3341">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3343" title="Parameter" ><summary><span><a href="#eventName$3343">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3344" title="Parameter" ><summary><span><a href="#args$3344">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$3362" title="Method" ><summary><span><a href="#eventNames$3362">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3333" title="Method" ><summary><span><a href="#getMaxListeners$3333">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$3345" title="Method" ><summary><span><a href="#listenerCount$3345">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3347" title="Parameter" ><summary><span><a href="#eventName$3347">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3335" title="Method" ><summary><span><a href="#listeners$3335">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3337" title="Parameter" ><summary><span><a href="#eventName$3337">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3320" title="Method" ><summary><span><a href="#off$3320">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3322" title="Parameter" ><summary><span><a href="#eventName$3322">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3323" title="Function" ><summary><span><a href="#listener$3323">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3326" title="Parameter" ><summary><span><a href="#args$3326">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="on$3299" title="Method" ><summary><span><a href="#on$3299">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3301" title="Parameter" ><summary><span><a href="#eventName$3301">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3302" title="Function" ><summary><span><a href="#listener$3302">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3305" title="Parameter" ><summary><span><a href="#args$3305">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="once$3306" title="Method" ><summary><span><a href="#once$3306">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3308" title="Parameter" ><summary><span><a href="#eventName$3308">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3309" title="Function" ><summary><span><a href="#listener$3309">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3312" title="Parameter" ><summary><span><a href="#args$3312">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="prependListener$3348" title="Method" ><summary><span><a href="#prependListener$3348">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3350" title="Parameter" ><summary><span><a href="#eventName$3350">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3351" title="Function" ><summary><span><a href="#listener$3351">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3354" title="Parameter" ><summary><span><a href="#args$3354">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="prependOnceListener$3355" title="Method" ><summary><span><a href="#prependOnceListener$3355">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3357" title="Parameter" ><summary><span><a href="#eventName$3357">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3358" title="Function" ><summary><span><a href="#listener$3358">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3361" title="Parameter" ><summary><span><a href="#args$3361">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="rawListeners$3338" title="Method" ><summary><span><a href="#rawListeners$3338">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3340" title="Parameter" ><summary><span><a href="#eventName$3340">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$3327" title="Method" ><summary><span><a href="#removeAllListeners$3327">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3329" title="Parameter" ><summary><span><a href="#event$3329">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="removeListener$3313" title="Method" ><summary><span><a href="#removeListener$3313">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3315" title="Parameter" ><summary><span><a href="#eventName$3315">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3316" title="Function" ><summary><span><a href="#listener$3316">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3319" title="Parameter" ><summary><span><a href="#args$3319">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details><details id="setMaxListeners$3330" title="Method" ><summary><span><a href="#setMaxListeners$3330">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3332" title="Parameter" ><summary><span><a href="#n$3332">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#EventEmitter$3291">EventEmitter</a></ul></p></p>    </ul></details></p></ul></details>  <details id="EventEmitterOptions$3930" title="Interface" ><summary><span><a href="#EventEmitterOptions$3930">#</a></span>  <code><strong>EventEmitterOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L38</a>  <ul>        <p>  <details id="captureRejections$3931" title="Property" ><summary><span><a href="#captureRejections$3931">#</a></span>  <code><strong>captureRejections</strong></code>     &ndash; Enables automatic capturing of promise rejection.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L42">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L42</a>  <ul><p>boolean</p>        </ul></details></p></ul></details>  <details id="Key$52" title="Interface" ><summary><span><a href="#Key$52">#</a></span>  <code><strong>Key</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L37</a>  <ul>        <p>  <details id="ctrl$55" title="Property" ><summary><span><a href="#ctrl$55">#</a></span>  <code><strong>ctrl</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L40">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L40</a>  <ul><p>boolean</p>        </ul></details><details id="meta$56" title="Property" ><summary><span><a href="#meta$56">#</a></span>  <code><strong>meta</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="name$54" title="Property" ><summary><span><a href="#name$54">#</a></span>  <code><strong>name</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L39">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L39</a>  <ul><p>string</p>        </ul></details><details id="sequence$53" title="Property" ><summary><span><a href="#sequence$53">#</a></span>  <code><strong>sequence</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L38</a>  <ul><p>string</p>        </ul></details><details id="shift$57" title="Property" ><summary><span><a href="#shift$57">#</a></span>  <code><strong>shift</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L42">src/.fastpm/-/@types/node@17.0.45/readline.d.ts#L42</a>  <ul><p>boolean</p>        </ul></details></p></ul></details>  <details id="MessagingOptions$111" title="Interface" ><summary><span><a href="#MessagingOptions$111">#</a></span>  <code><strong>MessagingOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L600">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L600</a>  <ul>        <p>  <details id="killSignal$113" title="Property" ><summary><span><a href="#killSignal$113">#</a></span>  <code><strong>killSignal</strong></code>     &ndash; The signal value to be used when the spawned process will be killed by the abort signal.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610</a>  <ul><p>number | <a href="#Signals$103">Signals</a></p>        </ul></details><details id="serialization$112" title="Property" ><summary><span><a href="#serialization$112">#</a></span>  <code><strong>serialization</strong></code>     &ndash; Specify the kind of serialization used for sending messages between processes.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605</a>  <ul><p><a href="#SerializationType$102">SerializationType</a></p>        </ul></details><details id="signal$115" title="Property" ><summary><span><a href="#signal$115">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="timeout$114" title="Property" ><summary><span><a href="#timeout$114">#</a></span>  <code><strong>timeout</strong></code>     &ndash; In milliseconds the maximum amount of time the process is allowed to run.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L614">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L614</a>  <ul><p>number</p>        </ul></details></p></ul></details>  <details id="NodeEventTarget$3270" title="Interface" ><summary><span><a href="#NodeEventTarget$3270">#</a></span>  <code><strong>NodeEventTarget</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L44">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L44</a>  <ul>        <p>  <details id="once$3271" title="Method" ><summary><span><a href="#once$3271">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>    </summary>    <ul>    <p>    <details id="eventName$3273" title="Parameter" ><summary><span><a href="#eventName$3273">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3274" title="Function" ><summary><span><a href="#listener$3274">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3277" title="Parameter" ><summary><span><a href="#args$3277">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#NodeEventTarget$3270">NodeEventTarget</a></ul></p></p>    </ul></details></p></ul></details>  <details id="ProcessEnv$100" title="Interface" ><summary><span><a href="#ProcessEnv$100">#</a></span>  <code><strong>ProcessEnv</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/process.d.ts#L111">src/.fastpm/-/@types/node@17.0.45/process.d.ts#L111</a>  <ul>        <p>  <details id="TZ$101" title="Property" ><summary><span><a href="#TZ$101">#</a></span>  <code><strong>TZ</strong></code>     &ndash; Can be used to change the default timezone at runtime</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/process.d.ts#L115">src/.fastpm/-/@types/node@17.0.45/process.d.ts#L115</a>  <ul><p>string</p>        </ul></details></p></ul></details>  <details id="ProcessEnvOptions$301" title="Interface" ><summary><span><a href="#ProcessEnvOptions$301">#</a></span>  <code><strong>ProcessEnvOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L616">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L616</a>  <ul>        <p>  <details id="cwd$304" title="Property" ><summary><span><a href="#cwd$304">#</a></span>  <code><strong>cwd</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619</a>  <ul><p>string | <a href="#URL$73">URL</a></p>        </ul></details><details id="env$305" title="Property" ><summary><span><a href="#env$305">#</a></span>  <code><strong>env</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620</a>  <ul><p><a href="#ProcessEnv$100">ProcessEnv</a></p>        </ul></details><details id="gid$303" title="Property" ><summary><span><a href="#gid$303">#</a></span>  <code><strong>gid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618</a>  <ul><p>number</p>        </ul></details><details id="uid$302" title="Property" ><summary><span><a href="#uid$302">#</a></span>  <code><strong>uid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617</a>  <ul><p>number</p>        </ul></details></p></ul></details>  <details id="ReadWriteStream$3714" title="Interface" ><summary><span><a href="#ReadWriteStream$3714">#</a></span>  <code><strong>ReadWriteStream</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L223">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L223</a>  <ul>        <p>  <details id="readable$3715" title="Property" ><summary><span><a href="#readable$3715">#</a></span>  <code><strong>readable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L201">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L201</a>  <ul><p>boolean</p>        </ul></details><details id="writable$3819" title="Property" ><summary><span><a href="#writable$3819">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L215">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L215</a>  <ul><p>boolean</p>        </ul></details><details id="[asyncIterator]$3745" title="Method" ><summary><span><a href="#[asyncIterator]$3745">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;string | <a href="#Buffer$3932">Buffer</a>&gt;</ul></p></p>    </ul></details><details id="addListener$3747" title="Method" ><summary><span><a href="#addListener$3747">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3749" title="Parameter" ><summary><span><a href="#eventName$3749">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3750" title="Function" ><summary><span><a href="#listener$3750">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3753" title="Parameter" ><summary><span><a href="#args$3753">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="emit$3796" title="Method" ><summary><span><a href="#emit$3796">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3798" title="Parameter" ><summary><span><a href="#eventName$3798">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3799" title="Parameter" ><summary><span><a href="#args$3799">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$3834" title="Method" ><summary><span><a href="#end$3834">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>    </summary>    <ul>    <p>    <details id="cb$3836" title="Function" ><summary><span><a href="#cb$3836">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p>  <details id="data$3840" title="Parameter" ><summary><span><a href="#data$3840">#</a></span>  <code><strong>data</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="cb$3841" title="Function" ><summary><span><a href="#cb$3841">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(data, cb)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p>  <details id="str$3845" title="Parameter" ><summary><span><a href="#str$3845">#</a></span>  <code><strong>str</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="encoding$3846" title="Parameter" ><summary><span><a href="#encoding$3846">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$3847" title="Function" ><summary><span><a href="#cb$3847">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(str, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="eventNames$3817" title="Method" ><summary><span><a href="#eventNames$3817">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3788" title="Method" ><summary><span><a href="#getMaxListeners$3788">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$3726" title="Method" ><summary><span><a href="#isPaused$3726">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$3800" title="Method" ><summary><span><a href="#listenerCount$3800">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3802" title="Parameter" ><summary><span><a href="#eventName$3802">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3790" title="Method" ><summary><span><a href="#listeners$3790">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3792" title="Parameter" ><summary><span><a href="#eventName$3792">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3775" title="Method" ><summary><span><a href="#off$3775">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3777" title="Parameter" ><summary><span><a href="#eventName$3777">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3778" title="Function" ><summary><span><a href="#listener$3778">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3781" title="Parameter" ><summary><span><a href="#args$3781">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="on$3754" title="Method" ><summary><span><a href="#on$3754">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3756" title="Parameter" ><summary><span><a href="#eventName$3756">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3757" title="Function" ><summary><span><a href="#listener$3757">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3760" title="Parameter" ><summary><span><a href="#args$3760">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="once$3761" title="Method" ><summary><span><a href="#once$3761">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3763" title="Parameter" ><summary><span><a href="#eventName$3763">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3764" title="Function" ><summary><span><a href="#listener$3764">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3767" title="Parameter" ><summary><span><a href="#args$3767">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="pause$3722" title="Method" ><summary><span><a href="#pause$3722">#</a></span>  <code><strong>pause</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="pipe$3728" title="Method" ><summary><span><a href="#pipe$3728">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>    <ul>    <p>    <details id="destination$3731" title="Parameter" ><summary><span><a href="#destination$3731">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$3625">T</a></p>        </ul></details><details id="options$3732" title="Parameter" ><summary><span><a href="#options$3732">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$3734" title="Property" ><summary><span><a href="#end$3734">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L207">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L207</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$3625">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$3625">T</a></ul></p></p>    </ul></details><details id="prependListener$3803" title="Method" ><summary><span><a href="#prependListener$3803">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3805" title="Parameter" ><summary><span><a href="#eventName$3805">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3806" title="Function" ><summary><span><a href="#listener$3806">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3809" title="Parameter" ><summary><span><a href="#args$3809">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="prependOnceListener$3810" title="Method" ><summary><span><a href="#prependOnceListener$3810">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3812" title="Parameter" ><summary><span><a href="#eventName$3812">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3813" title="Function" ><summary><span><a href="#listener$3813">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3816" title="Parameter" ><summary><span><a href="#args$3816">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="rawListeners$3793" title="Method" ><summary><span><a href="#rawListeners$3793">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3795" title="Parameter" ><summary><span><a href="#eventName$3795">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$3716" title="Method" ><summary><span><a href="#read$3716">#</a></span>  <code><strong>read</strong></code><em>(size)</em>    </summary>    <ul>    <p>    <details id="size$3718" title="Parameter" ><summary><span><a href="#size$3718">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>string | <a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="removeAllListeners$3782" title="Method" ><summary><span><a href="#removeAllListeners$3782">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3784" title="Parameter" ><summary><span><a href="#event$3784">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="removeListener$3768" title="Method" ><summary><span><a href="#removeListener$3768">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3770" title="Parameter" ><summary><span><a href="#eventName$3770">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3771" title="Function" ><summary><span><a href="#listener$3771">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3774" title="Parameter" ><summary><span><a href="#args$3774">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="resume$3724" title="Method" ><summary><span><a href="#resume$3724">#</a></span>  <code><strong>resume</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="setEncoding$3719" title="Method" ><summary><span><a href="#setEncoding$3719">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>    </summary>    <ul>    <p>    <details id="encoding$3721" title="Parameter" ><summary><span><a href="#encoding$3721">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="setMaxListeners$3785" title="Method" ><summary><span><a href="#setMaxListeners$3785">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3787" title="Parameter" ><summary><span><a href="#n$3787">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="unpipe$3735" title="Method" ><summary><span><a href="#unpipe$3735">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>    </summary>    <ul>    <p>    <details id="destination$3737" title="Parameter" ><summary><span><a href="#destination$3737">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="unshift$3738" title="Method" ><summary><span><a href="#unshift$3738">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>    </summary>    <ul>    <p>    <details id="chunk$3740" title="Parameter" ><summary><span><a href="#chunk$3740">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="encoding$3741" title="Parameter" ><summary><span><a href="#encoding$3741">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$3742" title="Method" ><summary><span><a href="#wrap$3742">#</a></span>  <code><strong>wrap</strong></code><em>(oldStream)</em>    </summary>    <ul>    <p>    <details id="oldStream$3744" title="Parameter" ><summary><span><a href="#oldStream$3744">#</a></span>  <code><strong>oldStream</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(oldStream)</em>  &nbsp;=&gt;  <ul><a href="#ReadWriteStream$3714">ReadWriteStream</a></ul></p></p>    </ul></details><details id="write$3820" title="Method" ><summary><span><a href="#write$3820">#</a></span>  <code><strong>write</strong></code><em>(buffer, cb)</em>    </summary>    <ul>    <p>    <details id="buffer$3822" title="Parameter" ><summary><span><a href="#buffer$3822">#</a></span>  <code><strong>buffer</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="cb$3823" title="Function" ><summary><span><a href="#cb$3823">#</a></span>  <code><strong>cb</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3826" title="Parameter" ><summary><span><a href="#err$3826">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(buffer, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="str$3828" title="Parameter" ><summary><span><a href="#str$3828">#</a></span>  <code><strong>str</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="encoding$3829" title="Parameter" ><summary><span><a href="#encoding$3829">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$3830" title="Function" ><summary><span><a href="#cb$3830">#</a></span>  <code><strong>cb</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3833" title="Parameter" ><summary><span><a href="#err$3833">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(str, encoding, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details></p></ul></details>  <details id="ReadableOptions$3364" title="Interface" ><summary><span><a href="#ReadableOptions$3364">#</a></span>  <code><strong>ReadableOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L43">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L43</a>  <ul>        <p>  <details id="autoDestroy$3388" title="Property" ><summary><span><a href="#autoDestroy$3388">#</a></span>  <code><strong>autoDestroy</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L41</a>  <ul><p>boolean</p>        </ul></details><details id="emitClose$3370" title="Property" ><summary><span><a href="#emitClose$3370">#</a></span>  <code><strong>emitClose</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L36</a>  <ul><p>boolean</p>        </ul></details><details id="encoding$3365" title="Property" ><summary><span><a href="#encoding$3365">#</a></span>  <code><strong>encoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L44</a>  <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="highWaterMark$3371" title="Property" ><summary><span><a href="#highWaterMark$3371">#</a></span>  <code><strong>highWaterMark</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L37</a>  <ul><p>number</p>        </ul></details><details id="objectMode$3372" title="Property" ><summary><span><a href="#objectMode$3372">#</a></span>  <code><strong>objectMode</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38">src/.fastpm/-/@types/node@17.0.45/stream.d.ts#L38</a>  <ul><p>boolean</p>        </ul></details><details id="signal$3389" title="Property" ><summary><span><a href="#signal$3389">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="construct$3373" title="Method" ><summary><span><a href="#construct$3373">#</a></span>  <code><strong>construct</strong></code><em>(this, callback)</em>    </summary>    <ul>    <p>    <details id="this$3375" title="Parameter" ><summary><span><a href="#this$3375">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="callback$3376" title="Function" ><summary><span><a href="#callback$3376">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$3379" title="Parameter" ><summary><span><a href="#error$3379">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>construct</strong><em>(this, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="destroy$3380" title="Method" ><summary><span><a href="#destroy$3380">#</a></span>  <code><strong>destroy</strong></code><em>(this, error, callback)</em>    </summary>    <ul>    <p>    <details id="this$3382" title="Parameter" ><summary><span><a href="#this$3382">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="error$3383" title="Parameter" ><summary><span><a href="#error$3383">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details><details id="callback$3384" title="Function" ><summary><span><a href="#callback$3384">#</a></span>  <code><strong>callback</strong></code><em>(error)</em>    </summary>    <ul>    <p>    <details id="error$3387" title="Parameter" ><summary><span><a href="#error$3387">#</a></span>  <code><strong>error</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>callback</strong><em>(error)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>destroy</strong><em>(this, error, callback)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="read$3366" title="Method" ><summary><span><a href="#read$3366">#</a></span>  <code><strong>read</strong></code><em>(this, size)</em>    </summary>    <ul>    <p>    <details id="this$3368" title="Parameter" ><summary><span><a href="#this$3368">#</a></span>  <code><strong>this</strong></code>    </summary>    <ul><p><a href="#Readable$732">Readable</a></p>        </ul></details><details id="size$3369" title="Parameter" ><summary><span><a href="#size$3369">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(this, size)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details></p></ul></details>  <details id="ReadableStream$3609" title="Interface" ><summary><span><a href="#ReadableStream$3609">#</a></span>  <code><strong>ReadableStream</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L200">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L200</a>  <ul>        <p>  <details id="readable$3610" title="Property" ><summary><span><a href="#readable$3610">#</a></span>  <code><strong>readable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L201">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L201</a>  <ul><p>boolean</p>        </ul></details><details id="[asyncIterator]$3640" title="Method" ><summary><span><a href="#[asyncIterator]$3640">#</a></span>  <code><strong>[asyncIterator]</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>[asyncIterator]</strong><em>()</em>  &nbsp;=&gt;  <ul><span>AsyncIterableIterator</span>&lt;string | <a href="#Buffer$3932">Buffer</a>&gt;</ul></p></p>    </ul></details><details id="addListener$3642" title="Method" ><summary><span><a href="#addListener$3642">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3644" title="Parameter" ><summary><span><a href="#eventName$3644">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3645" title="Function" ><summary><span><a href="#listener$3645">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3648" title="Parameter" ><summary><span><a href="#args$3648">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="emit$3691" title="Method" ><summary><span><a href="#emit$3691">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3693" title="Parameter" ><summary><span><a href="#eventName$3693">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3694" title="Parameter" ><summary><span><a href="#args$3694">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="eventNames$3712" title="Method" ><summary><span><a href="#eventNames$3712">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3683" title="Method" ><summary><span><a href="#getMaxListeners$3683">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="isPaused$3621" title="Method" ><summary><span><a href="#isPaused$3621">#</a></span>  <code><strong>isPaused</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>isPaused</strong><em>()</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="listenerCount$3695" title="Method" ><summary><span><a href="#listenerCount$3695">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3697" title="Parameter" ><summary><span><a href="#eventName$3697">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3685" title="Method" ><summary><span><a href="#listeners$3685">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3687" title="Parameter" ><summary><span><a href="#eventName$3687">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3670" title="Method" ><summary><span><a href="#off$3670">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3672" title="Parameter" ><summary><span><a href="#eventName$3672">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3673" title="Function" ><summary><span><a href="#listener$3673">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3676" title="Parameter" ><summary><span><a href="#args$3676">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="on$3649" title="Method" ><summary><span><a href="#on$3649">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3651" title="Parameter" ><summary><span><a href="#eventName$3651">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3652" title="Function" ><summary><span><a href="#listener$3652">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3655" title="Parameter" ><summary><span><a href="#args$3655">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="once$3656" title="Method" ><summary><span><a href="#once$3656">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3658" title="Parameter" ><summary><span><a href="#eventName$3658">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3659" title="Function" ><summary><span><a href="#listener$3659">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3662" title="Parameter" ><summary><span><a href="#args$3662">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="pause$3617" title="Method" ><summary><span><a href="#pause$3617">#</a></span>  <code><strong>pause</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>pause</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="pipe$3623" title="Method" ><summary><span><a href="#pipe$3623">#</a></span>  <code><strong>pipe</strong></code><em>(destination, { end })</em>    </summary>    <ul>    <p>    <details id="destination$3626" title="Parameter" ><summary><span><a href="#destination$3626">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#T$3625">T</a></p>        </ul></details><details id="options$3627" title="Parameter" ><summary><span><a href="#options$3627">#</a></span>  <code><strong>options</strong></code>    </summary>    <ul><p>{<p>  <details id="end$3629" title="Property" ><summary><span><a href="#end$3629">#</a></span>  <code><strong>end</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L207">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L207</a>  <ul><p>boolean</p>        </ul></details></p>}</p>        </ul></details>  <p><strong>pipe</strong>&lt;<span>T</span><span>&nbsp;extends&nbsp;</span>     <a href="#WritableStream$3390">WritableStream</a>&lt;<a href="#T$3625">T</a>&gt;&gt;<em>(destination, { end })</em>  &nbsp;=&gt;  <ul><a href="#T$3625">T</a></ul></p></p>    </ul></details><details id="prependListener$3698" title="Method" ><summary><span><a href="#prependListener$3698">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3700" title="Parameter" ><summary><span><a href="#eventName$3700">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3701" title="Function" ><summary><span><a href="#listener$3701">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3704" title="Parameter" ><summary><span><a href="#args$3704">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="prependOnceListener$3705" title="Method" ><summary><span><a href="#prependOnceListener$3705">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3707" title="Parameter" ><summary><span><a href="#eventName$3707">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3708" title="Function" ><summary><span><a href="#listener$3708">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3711" title="Parameter" ><summary><span><a href="#args$3711">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="rawListeners$3688" title="Method" ><summary><span><a href="#rawListeners$3688">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3690" title="Parameter" ><summary><span><a href="#eventName$3690">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="read$3611" title="Method" ><summary><span><a href="#read$3611">#</a></span>  <code><strong>read</strong></code><em>(size)</em>    </summary>    <ul>    <p>    <details id="size$3613" title="Parameter" ><summary><span><a href="#size$3613">#</a></span>  <code><strong>size</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>read</strong><em>(size)</em>  &nbsp;=&gt;  <ul>string | <a href="#Buffer$3932">Buffer</a></ul></p></p>    </ul></details><details id="removeAllListeners$3677" title="Method" ><summary><span><a href="#removeAllListeners$3677">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3679" title="Parameter" ><summary><span><a href="#event$3679">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="removeListener$3663" title="Method" ><summary><span><a href="#removeListener$3663">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3665" title="Parameter" ><summary><span><a href="#eventName$3665">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3666" title="Function" ><summary><span><a href="#listener$3666">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3669" title="Parameter" ><summary><span><a href="#args$3669">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="resume$3619" title="Method" ><summary><span><a href="#resume$3619">#</a></span>  <code><strong>resume</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>resume</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="setEncoding$3614" title="Method" ><summary><span><a href="#setEncoding$3614">#</a></span>  <code><strong>setEncoding</strong></code><em>(encoding)</em>    </summary>    <ul>    <p>    <details id="encoding$3616" title="Parameter" ><summary><span><a href="#encoding$3616">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>setEncoding</strong><em>(encoding)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="setMaxListeners$3680" title="Method" ><summary><span><a href="#setMaxListeners$3680">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3682" title="Parameter" ><summary><span><a href="#n$3682">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="unpipe$3630" title="Method" ><summary><span><a href="#unpipe$3630">#</a></span>  <code><strong>unpipe</strong></code><em>(destination)</em>    </summary>    <ul>    <p>    <details id="destination$3632" title="Parameter" ><summary><span><a href="#destination$3632">#</a></span>  <code><strong>destination</strong></code>    </summary>    <ul><p><a href="#WritableStream$3390">WritableStream</a></p>        </ul></details>  <p><strong>unpipe</strong><em>(destination)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details><details id="unshift$3633" title="Method" ><summary><span><a href="#unshift$3633">#</a></span>  <code><strong>unshift</strong></code><em>(chunk, encoding)</em>    </summary>    <ul>    <p>    <details id="chunk$3635" title="Parameter" ><summary><span><a href="#chunk$3635">#</a></span>  <code><strong>chunk</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="encoding$3636" title="Parameter" ><summary><span><a href="#encoding$3636">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details>  <p><strong>unshift</strong><em>(chunk, encoding)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details><details id="wrap$3637" title="Method" ><summary><span><a href="#wrap$3637">#</a></span>  <code><strong>wrap</strong></code><em>(oldStream)</em>    </summary>    <ul>    <p>    <details id="oldStream$3639" title="Parameter" ><summary><span><a href="#oldStream$3639">#</a></span>  <code><strong>oldStream</strong></code>    </summary>    <ul><p><a href="#ReadableStream$3609">ReadableStream</a></p>        </ul></details>  <p><strong>wrap</strong><em>(oldStream)</em>  &nbsp;=&gt;  <ul><a href="#ReadableStream$3609">ReadableStream</a></ul></p></p>    </ul></details></p></ul></details>  <details id="SpawnOptions$37" title="Interface" ><summary><span><a href="#SpawnOptions$37">#</a></span>  <code><strong>SpawnOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L638">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L638</a>  <ul>        <p>  <details id="argv0$39" title="Property" ><summary><span><a href="#argv0$39">#</a></span>  <code><strong>argv0</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L633">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L633</a>  <ul><p>string</p>        </ul></details><details id="cwd$47" title="Property" ><summary><span><a href="#cwd$47">#</a></span>  <code><strong>cwd</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L619</a>  <ul><p>string | <a href="#URL$73">URL</a></p>        </ul></details><details id="detached$38" title="Property" ><summary><span><a href="#detached$38">#</a></span>  <code><strong>detached</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L639">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L639</a>  <ul><p>boolean</p>        </ul></details><details id="env$48" title="Property" ><summary><span><a href="#env$48">#</a></span>  <code><strong>env</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L620</a>  <ul><p><a href="#ProcessEnv$100">ProcessEnv</a></p>        </ul></details><details id="gid$46" title="Property" ><summary><span><a href="#gid$46">#</a></span>  <code><strong>gid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L618</a>  <ul><p>number</p>        </ul></details><details id="killSignal$50" title="Property" ><summary><span><a href="#killSignal$50">#</a></span>  <code><strong>killSignal</strong></code>     &ndash; The signal value to be used when the spawned process will be killed by the abort signal.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L610</a>  <ul><p>number | <a href="#Signals$103">Signals</a></p>        </ul></details><details id="serialization$49" title="Property" ><summary><span><a href="#serialization$49">#</a></span>  <code><strong>serialization</strong></code>     &ndash; Specify the kind of serialization used for sending messages between processes.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L605</a>  <ul><p><a href="#SerializationType$102">SerializationType</a></p>        </ul></details><details id="shell$41" title="Property" ><summary><span><a href="#shell$41">#</a></span>  <code><strong>shell</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L635">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L635</a>  <ul><p>string | boolean</p>        </ul></details><details id="signal$51" title="Property" ><summary><span><a href="#signal$51">#</a></span>  <code><strong>signal</strong></code>     &ndash; When provided the corresponding <code>AbortController</code> can be used to cancel an asynchronous action.</summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L317</a>  <ul><p><span>AbortSignal</span></p>        </ul></details><details id="stdio$40" title="Property" ><summary><span><a href="#stdio$40">#</a></span>  <code><strong>stdio</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L634">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L634</a>  <ul><p><a href="#StdioOptions$72">StdioOptions</a></p>        </ul></details><details id="timeout$44" title="Property" ><summary><span><a href="#timeout$44">#</a></span>  <code><strong>timeout</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L630</a>  <ul><p>number</p>        </ul></details><details id="uid$45" title="Property" ><summary><span><a href="#uid$45">#</a></span>  <code><strong>uid</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L617</a>  <ul><p>number</p>        </ul></details><details id="windowsHide$43" title="Property" ><summary><span><a href="#windowsHide$43">#</a></span>  <code><strong>windowsHide</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L626</a>  <ul><p>boolean</p>        </ul></details><details id="windowsVerbatimArguments$42" title="Property" ><summary><span><a href="#windowsVerbatimArguments$42">#</a></span>  <code><strong>windowsVerbatimArguments</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L636">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L636</a>  <ul><p>boolean</p>        </ul></details></p></ul></details>  <details id="StaticEventEmitterOptions$3278" title="Interface" ><summary><span><a href="#StaticEventEmitterOptions$3278">#</a></span>  <code><strong>StaticEventEmitterOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L56">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L56</a>  <ul>        <p>  <details id="signal$3279" title="Property" ><summary><span><a href="#signal$3279">#</a></span>  <code><strong>signal</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/events.d.ts#L57">src/.fastpm/-/@types/node@17.0.45/events.d.ts#L57</a>  <ul><p><span>AbortSignal</span></p>        </ul></details></p></ul></details>  <details id="WritableStream$3390" title="Interface" ><summary><span><a href="#WritableStream$3390">#</a></span>  <code><strong>WritableStream</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L214">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L214</a>  <ul>        <p>  <details id="writable$3391" title="Property" ><summary><span><a href="#writable$3391">#</a></span>  <code><strong>writable</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L215">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L215</a>  <ul><p>boolean</p>        </ul></details><details id="addListener$3422" title="Method" ><summary><span><a href="#addListener$3422">#</a></span>  <code><strong>addListener</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.on(eventName, listener)</code>.</summary>    <ul>    <p>    <details id="eventName$3424" title="Parameter" ><summary><span><a href="#eventName$3424">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3425" title="Function" ><summary><span><a href="#listener$3425">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3428" title="Parameter" ><summary><span><a href="#args$3428">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>addListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="emit$3471" title="Method" ><summary><span><a href="#emit$3471">#</a></span>  <code><strong>emit</strong></code><em>(eventName, args)</em>     &ndash; Synchronously calls each of the listeners registered for the event named<code>eventName</code>, in the order they were registered, passing the supplied arguments
to each.</summary>    <ul>    <p>  <p>

Returns `true` if the event had listeners, `false` otherwise.

```js
const EventEmitter = require('events')
const myEmitter = new EventEmitter()

// First listener
myEmitter.on('event', function firstListener() {
  console.log('Helloooo! first listener')
})
// Second listener
myEmitter.on('event', function secondListener(arg1, arg2) {
  console.log(`event with parameters ${arg1}, ${arg2} in second listener`)
})
// Third listener
myEmitter.on('event', function thirdListener(...args) {
  const parameters = args.join(', ')
  console.log(`event with parameters ${parameters} in third listener`)
})

console.log(myEmitter.listeners('event'))

myEmitter.emit('event', 1, 2, 3, 4, 5)

// Prints:
// [
//   [Function: firstListener],
//   [Function: secondListener],
//   [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```

</p>
  <details id="eventName$3473" title="Parameter" ><summary><span><a href="#eventName$3473">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="args$3474" title="Parameter" ><summary><span><a href="#args$3474">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>emit</strong><em>(eventName, args)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details><details id="end$3406" title="Method" ><summary><span><a href="#end$3406">#</a></span>  <code><strong>end</strong></code><em>(cb)</em>    </summary>    <ul>    <p>    <details id="cb$3408" title="Function" ><summary><span><a href="#cb$3408">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(cb)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p>  <details id="data$3412" title="Parameter" ><summary><span><a href="#data$3412">#</a></span>  <code><strong>data</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="cb$3413" title="Function" ><summary><span><a href="#cb$3413">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(data, cb)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p>  <details id="str$3417" title="Parameter" ><summary><span><a href="#str$3417">#</a></span>  <code><strong>str</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="encoding$3418" title="Parameter" ><summary><span><a href="#encoding$3418">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$3419" title="Function" ><summary><span><a href="#cb$3419">#</a></span>  <code><strong>cb</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>cb</strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>end</strong><em>(str, encoding, cb)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="eventNames$3492" title="Method" ><summary><span><a href="#eventNames$3492">#</a></span>  <code><strong>eventNames</strong></code><em>()</em>     &ndash; Returns an array listing the events for which the emitter has registered
listeners. The values in the array are strings or <code>Symbol</code>s.</summary>    <ul>    <p>  <p>

```js
const EventEmitter = require('events')
const myEE = new EventEmitter()
myEE.on('foo', () => {})
myEE.on('bar', () => {})

const sym = Symbol('symbol')
myEE.on(sym, () => {})

console.log(myEE.eventNames())
// Prints: [ 'foo', 'bar', Symbol(symbol) ]
```

</p>
    <p><strong>eventNames</strong><em>()</em>  &nbsp;=&gt;  <ul>string | symbol  []</ul></p></p>    </ul></details><details id="getMaxListeners$3463" title="Method" ><summary><span><a href="#getMaxListeners$3463">#</a></span>  <code><strong>getMaxListeners</strong></code><em>()</em>     &ndash; Returns the current max listener value for the <code>EventEmitter</code> which is either
set by <code>emitter.setMaxListeners(n)</code> or defaults to {@link defaultMaxListeners}.</summary>    <ul>    <p>      <p><strong>getMaxListeners</strong><em>()</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listenerCount$3475" title="Method" ><summary><span><a href="#listenerCount$3475">#</a></span>  <code><strong>listenerCount</strong></code><em>(eventName)</em>     &ndash; Returns the number of listeners listening to the event named <code>eventName</code>.</summary>    <ul>    <p>    <details id="eventName$3477" title="Parameter" ><summary><span><a href="#eventName$3477">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event being listened for
</summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listenerCount</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul>number</ul></p></p>    </ul></details><details id="listeners$3465" title="Method" ><summary><span><a href="#listeners$3465">#</a></span>  <code><strong>listeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
console.log(util.inspect(server.listeners('connection')))
// Prints: [ [Function] ]
```

</p>
  <details id="eventName$3467" title="Parameter" ><summary><span><a href="#eventName$3467">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>listeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="off$3450" title="Method" ><summary><span><a href="#off$3450">#</a></span>  <code><strong>off</strong></code><em>(eventName, listener)</em>     &ndash; Alias for <code>emitter.removeListener()</code>.</summary>    <ul>    <p>    <details id="eventName$3452" title="Parameter" ><summary><span><a href="#eventName$3452">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3453" title="Function" ><summary><span><a href="#listener$3453">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3456" title="Parameter" ><summary><span><a href="#args$3456">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>off</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="on$3429" title="Method" ><summary><span><a href="#on$3429">#</a></span>  <code><strong>on</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the end of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.on('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.on('foo', () => console.log('a'))
myEE.prependListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3431" title="Parameter" ><summary><span><a href="#eventName$3431">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3432" title="Function" ><summary><span><a href="#listener$3432">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3435" title="Parameter" ><summary><span><a href="#args$3435">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>on</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="once$3436" title="Method" ><summary><span><a href="#once$3436">#</a></span>  <code><strong>once</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code>. The
next time <code>eventName</code> is triggered, this listener is removed and then invoked.</summary>    <ul>    <p>  <p>

```js
server.once('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

By default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the
event listener to the beginning of the listeners array.

```js
const myEE = new EventEmitter()
myEE.once('foo', () => console.log('a'))
myEE.prependOnceListener('foo', () => console.log('b'))
myEE.emit('foo')
// Prints:
//   b
//   a
```

</p>
  <details id="eventName$3438" title="Parameter" ><summary><span><a href="#eventName$3438">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3439" title="Function" ><summary><span><a href="#listener$3439">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3442" title="Parameter" ><summary><span><a href="#args$3442">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>once</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="prependListener$3478" title="Method" ><summary><span><a href="#prependListener$3478">#</a></span>  <code><strong>prependListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds the <code>listener</code> function to the <em>beginning</em> of the listeners array for the
event named <code>eventName</code>. No checks are made to see if the <code>listener</code> has
already been added. Multiple calls passing the same combination of <code>eventName</code>and <code>listener</code> will result in the <code>listener</code> being added, and called, multiple
times.</summary>    <ul>    <p>  <p>

```js
server.prependListener('connection', stream => {
  console.log('someone connected!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3480" title="Parameter" ><summary><span><a href="#eventName$3480">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3481" title="Function" ><summary><span><a href="#listener$3481">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3484" title="Parameter" ><summary><span><a href="#args$3484">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="prependOnceListener$3485" title="Method" ><summary><span><a href="#prependOnceListener$3485">#</a></span>  <code><strong>prependOnceListener</strong></code><em>(eventName, listener)</em>     &ndash; Adds a <strong>one-time</strong><code>listener</code> function for the event named <code>eventName</code> to the_beginning_ of the listeners array. The next time <code>eventName</code> is triggered, this
listener is removed, and then invoked.</summary>    <ul>    <p>  <p>

```js
server.prependOnceListener('connection', stream => {
  console.log('Ah, we have our first user!')
})
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3487" title="Parameter" ><summary><span><a href="#eventName$3487">#</a></span>  <code><strong>eventName</strong></code>     &ndash; The name of the event.</summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3488" title="Function" ><summary><span><a href="#listener$3488">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3491" title="Parameter" ><summary><span><a href="#args$3491">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>prependOnceListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="rawListeners$3468" title="Method" ><summary><span><a href="#rawListeners$3468">#</a></span>  <code><strong>rawListeners</strong></code><em>(eventName)</em>     &ndash; Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</summary>    <ul>    <p>  <p>

```js
const emitter = new EventEmitter()
emitter.once('log', () => console.log('log once'))

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners('log')
const logFnWrapper = listeners[0]

// Logs "log once" to the console and does not unbind the `once` event
logFnWrapper.listener()

// Logs "log once" to the console and removes the listener
logFnWrapper()

emitter.on('log', () => console.log('log persistently'))
// Will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners('log')

// Logs "log persistently" twice
newListeners[0]()
emitter.emit('log')
```

</p>
  <details id="eventName$3470" title="Parameter" ><summary><span><a href="#eventName$3470">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>rawListeners</strong><em>(eventName)</em>  &nbsp;=&gt;  <ul><span>Function</span>  []</ul></p></p>    </ul></details><details id="removeAllListeners$3457" title="Method" ><summary><span><a href="#removeAllListeners$3457">#</a></span>  <code><strong>removeAllListeners</strong></code><em>(event)</em>     &ndash; Removes all listeners, or those of the specified <code>eventName</code>.</summary>    <ul>    <p>  <p>

It is bad practice to remove listeners added elsewhere in the code,
particularly when the `EventEmitter` instance was created by some other
component or module (e.g. sockets or file streams).

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="event$3459" title="Parameter" ><summary><span><a href="#event$3459">#</a></span>  <code><strong>event</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details>  <p><strong>removeAllListeners</strong><em>(event)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="removeListener$3443" title="Method" ><summary><span><a href="#removeListener$3443">#</a></span>  <code><strong>removeListener</strong></code><em>(eventName, listener)</em>     &ndash; Removes the specified <code>listener</code> from the listener array for the event named<code>eventName</code>.</summary>    <ul>    <p>  <p>

```js
const callback = stream => {
  console.log('someone connected!')
}
server.on('connection', callback)
// ...
server.removeListener('connection', callback)
```

`removeListener()` will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified `eventName`, then `removeListener()` must be
called multiple times to remove each instance.

Once an event is emitted, all listeners attached to it at the
time of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will
not remove them from`emit()` in progress. Subsequent events behave as expected.

```js
const myEmitter = new MyEmitter()

const callbackA = () => {
  console.log('A')
  myEmitter.removeListener('event', callbackB)
}

const callbackB = () => {
  console.log('B')
}

myEmitter.on('event', callbackA)

myEmitter.on('event', callbackB)

// callbackA removes listener callbackB but it will still be called.
// Internal listener array at time of emit [callbackA, callbackB]
myEmitter.emit('event')
// Prints:
//   A
//   B

// callbackB is now removed.
// Internal listener array [callbackA]
myEmitter.emit('event')
// Prints:
//   A
```

Because listeners are managed using an internal array, calling this will
change the position indices of any listener registered _after_ the listener
being removed. This will not impact the order in which listeners are called,
but it means that any copies of the listener array as returned by
the `emitter.listeners()` method will need to be recreated.

When a single function has been added as a handler multiple times for a single
event (as in the example below), `removeListener()` will remove the most
recently added instance. In the example the `once('ping')`listener is removed:

```js
const ee = new EventEmitter()

function pong() {
  console.log('pong')
}

ee.on('ping', pong)
ee.once('ping', pong)
ee.removeListener('ping', pong)

ee.emit('ping')
ee.emit('ping')
```

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="eventName$3445" title="Parameter" ><summary><span><a href="#eventName$3445">#</a></span>  <code><strong>eventName</strong></code>    </summary>    <ul><p>string | symbol</p>        </ul></details><details id="listener$3446" title="Function" ><summary><span><a href="#listener$3446">#</a></span>  <code><strong>listener</strong></code><em>(args)</em>    </summary>    <ul>    <p>    <details id="args$3449" title="Parameter" ><summary><span><a href="#args$3449">#</a></span>  <code><strong>args</strong></code>    </summary>    <ul><p>any  []</p>        </ul></details>  <p><strong>listener</strong><em>(args)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>removeListener</strong><em>(eventName, listener)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="setMaxListeners$3460" title="Method" ><summary><span><a href="#setMaxListeners$3460">#</a></span>  <code><strong>setMaxListeners</strong></code><em>(n)</em>     &ndash; By default <code>EventEmitter</code>s will print a warning if more than <code>10</code> listeners are
added for a particular event. This is a useful default that helps finding
memory leaks. The <code>emitter.setMaxListeners()</code> method allows the limit to be
modified for this specific <code>EventEmitter</code> instance. The value can be set to<code>Infinity</code> (or <code>0</code>) to indicate an unlimited number of listeners.</summary>    <ul>    <p>  <p>

Returns a reference to the `EventEmitter`, so that calls can be chained.

</p>
  <details id="n$3462" title="Parameter" ><summary><span><a href="#n$3462">#</a></span>  <code><strong>n</strong></code>    </summary>    <ul><p>number</p>        </ul></details>  <p><strong>setMaxListeners</strong><em>(n)</em>  &nbsp;=&gt;  <ul><a href="#WritableStream$3390">WritableStream</a></ul></p></p>    </ul></details><details id="write$3392" title="Method" ><summary><span><a href="#write$3392">#</a></span>  <code><strong>write</strong></code><em>(buffer, cb)</em>    </summary>    <ul>    <p>    <details id="buffer$3394" title="Parameter" ><summary><span><a href="#buffer$3394">#</a></span>  <code><strong>buffer</strong></code>    </summary>    <ul><p>string | <span>Uint8Array</span></p>        </ul></details><details id="cb$3395" title="Function" ><summary><span><a href="#cb$3395">#</a></span>  <code><strong>cb</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3398" title="Parameter" ><summary><span><a href="#err$3398">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(buffer, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p>  <details id="str$3400" title="Parameter" ><summary><span><a href="#str$3400">#</a></span>  <code><strong>str</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="encoding$3401" title="Parameter" ><summary><span><a href="#encoding$3401">#</a></span>  <code><strong>encoding</strong></code>    </summary>    <ul><p><a href="#BufferEncoding$3929">BufferEncoding</a></p>        </ul></details><details id="cb$3402" title="Function" ><summary><span><a href="#cb$3402">#</a></span>  <code><strong>cb</strong></code><em>(err)</em>    </summary>    <ul>    <p>    <details id="err$3405" title="Parameter" ><summary><span><a href="#err$3405">#</a></span>  <code><strong>err</strong></code>    </summary>    <ul><p><code>null</code> | <span>Error</span></p>        </ul></details>  <p><strong>cb</strong><em>(err)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>write</strong><em>(str, encoding, cb)</em>  &nbsp;=&gt;  <ul>boolean</ul></p></p>    </ul></details></p></ul></details>  <details id="ArrayBufferView$3608" title="TypeAlias" ><summary><span><a href="#ArrayBufferView$3608">#</a></span>  <code><strong>ArrayBufferView</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L242">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L242</a>  <ul><p><a href="#TypedArray$4250">TypedArray</a> | <span>DataView</span></p>        </ul></details>  <details id="BinaryLike$3494" title="TypeAlias" ><summary><span><a href="#BinaryLike$3494">#</a></span>  <code><strong>BinaryLike</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/crypto.d.ts#L650">src/.fastpm/-/@types/node@17.0.45/crypto.d.ts#L650</a>  <ul><p>string | <a href="#NodeJS.ArrayBufferView$3608">NodeJS.ArrayBufferView</a></p>        </ul></details>  <details id="BufferEncoding$3929" title="TypeAlias" ><summary><span><a href="#BufferEncoding$3929">#</a></span>  <code><strong>BufferEncoding</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L170">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L170</a>  <ul><p><code>"ascii"</code> | <code>"utf8"</code> | <code>"utf-8"</code> | <code>"utf16le"</code> | <code>"ucs2"</code> | <code>"ucs-2"</code> | <code>"base64"</code> | <code>"base64url"</code> | <code>"latin1"</code> | <code>"binary"</code> | <code>"hex"</code></p>        </ul></details>  <details id="IOType$118" title="TypeAlias" ><summary><span><a href="#IOType$118">#</a></span>  <code><strong>IOType</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L597">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L597</a>  <ul><p><code>"overlapped"</code> | <code>"pipe"</code> | <code>"ignore"</code> | <code>"inherit"</code></p>        </ul></details>  <details id="SerializationType$102" title="TypeAlias" ><summary><span><a href="#SerializationType$102">#</a></span>  <code><strong>SerializationType</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L599">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L599</a>  <ul><p><code>"json"</code> | <code>"advanced"</code></p>        </ul></details>  <details id="Signals$103" title="TypeAlias" ><summary><span><a href="#Signals$103">#</a></span>  <code><strong>Signals</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/process.d.ts#L52">src/.fastpm/-/@types/node@17.0.45/process.d.ts#L52</a>  <ul><p><code>"SIGABRT"</code> | <code>"SIGALRM"</code> | <code>"SIGBUS"</code> | <code>"SIGCHLD"</code> | <code>"SIGCONT"</code> | <code>"SIGFPE"</code> | <code>"SIGHUP"</code> | <code>"SIGILL"</code> | <code>"SIGINT"</code> | <code>"SIGIO"</code> | <code>"SIGIOT"</code> | <code>"SIGKILL"</code> | <code>"SIGPIPE"</code> | <code>"SIGPOLL"</code> | <code>"SIGPROF"</code> | <code>"SIGPWR"</code> | <code>"SIGQUIT"</code> | <code>"SIGSEGV"</code> | <code>"SIGSTKFLT"</code> | <code>"SIGSTOP"</code> | <code>"SIGSYS"</code> | <code>"SIGTERM"</code> | <code>"SIGTRAP"</code> | <code>"SIGTSTP"</code> | <code>"SIGTTIN"</code> | <code>"SIGTTOU"</code> | <code>"SIGUNUSED"</code> | <code>"SIGURG"</code> | <code>"SIGUSR1"</code> | <code>"SIGUSR2"</code> | <code>"SIGVTALRM"</code> | <code>"SIGWINCH"</code> | <code>"SIGXCPU"</code> | <code>"SIGXFSZ"</code> | <code>"SIGBREAK"</code> | <code>"SIGLOST"</code> | <code>"SIGINFO"</code></p>        </ul></details>  <details id="StdioOptions$72" title="TypeAlias" ><summary><span><a href="#StdioOptions$72">#</a></span>  <code><strong>StdioOptions</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L598">src/.fastpm/-/@types/node@17.0.45/child_process.d.ts#L598</a>  <ul><p><a href="#IOType$118">IOType</a> | <a href="#IOType$118">IOType</a> | <code>"ipc"</code> | <a href="#Stream$119">Stream</a> | number | <code>null</code> | undefined  []</p>        </ul></details>  <details id="TypedArray$4250" title="TypeAlias" ><summary><span><a href="#TypedArray$4250">#</a></span>  <code><strong>TypedArray</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L230">src/.fastpm/-/@types/node@17.0.45/globals.d.ts#L230</a>  <ul><p><span>Uint8Array</span> | <span>Uint8ClampedArray</span> | <span>Uint16Array</span> | <span>Uint32Array</span> | <span>Int8Array</span> | <span>Int16Array</span> | <span>Int32Array</span> | <span>BigUint64Array</span> | <span>BigInt64Array</span> | <span>Float32Array</span> | <span>Float64Array</span></p>        </ul></details>  <details id="WithImplicitCoercion$4315" title="TypeAlias" ><summary><span><a href="#WithImplicitCoercion$4315">#</a></span>  <code><strong>WithImplicitCoercion</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L171">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L171</a>  <ul><p><a href="#T$4319">T</a> | {<p>  <details id="valueOf$4317" title="Method" ><summary><span><a href="#valueOf$4317">#</a></span>  <code><strong>valueOf</strong></code><em>()</em>    </summary>    <ul>    <p>      <p><strong>valueOf</strong><em>()</em>  &nbsp;=&gt;  <ul><a href="#T$4319">T</a></ul></p></p>    </ul></details></p>}</p>        </ul></details>  <details id="Buffer$3932" title="Variable" ><summary><span><a href="#Buffer$3932">#</a></span>  <code><strong>Buffer</strong></code>    </summary>  <a href="src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L2195">src/.fastpm/-/@types/node@17.0.45/buffer.d.ts#L2195</a>  <ul><p><a href="#BufferConstructor$4251">BufferConstructor</a></p>        </ul></details><details id="exec$31" title="Function" ><summary><span><a href="#exec$31">#</a></span>  <code><strong>exec</strong></code><em>(cmd, args, options)</em>    </summary>  <a href="src/everyday-node.ts#L79">src/everyday-node.ts#L79</a>  <ul>    <p>    <details id="cmd$33" title="Parameter" ><summary><span><a href="#cmd$33">#</a></span>  <code><strong>cmd</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="args$34" title="Parameter" ><summary><span><a href="#args$34">#</a></span>  <code><strong>args</strong></code>  <span><span>&nbsp;=&nbsp;</span>  <code>[]</code></span>  </summary>    <ul><p>string  []</p>        </ul></details><details id="options$35" title="Parameter" ><summary><span><a href="#options$35">#</a></span>  <code><strong>options</strong></code>  <span><span>&nbsp;=&nbsp;</span>  <code>{}</code></span>  </summary>    <ul><p><a href="#SpawnOptions$37">SpawnOptions</a></p>        </ul></details>  <p><strong>exec</strong><em>(cmd, args, options)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;unknown&gt;</ul></p></p>    </ul></details><details id="execCapture$1" title="Function" ><summary><span><a href="#execCapture$1">#</a></span>  <code><strong>execCapture</strong></code><em>(cmd, opts)</em>    </summary>  <a href="src/everyday-node.ts#L7">src/everyday-node.ts#L7</a>  <ul>    <p>    <details id="cmd$3" title="Parameter" ><summary><span><a href="#cmd$3">#</a></span>  <code><strong>cmd</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="opts$4" title="Parameter" ><summary><span><a href="#opts$4">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><span>Options</span></p>        </ul></details>  <p><strong>execCapture</strong><em>(cmd, opts)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<span>ReturnType</span>&gt;</ul></p></p>    </ul></details><details id="execCaptureSync$5" title="Function" ><summary><span><a href="#execCaptureSync$5">#</a></span>  <code><strong>execCaptureSync</strong></code><em>(cmd, opts)</em>    </summary>  <a href="src/everyday-node.ts#L9">src/everyday-node.ts#L9</a>  <ul>    <p>    <details id="cmd$7" title="Parameter" ><summary><span><a href="#cmd$7">#</a></span>  <code><strong>cmd</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="opts$8" title="Parameter" ><summary><span><a href="#opts$8">#</a></span>  <code><strong>opts</strong></code>    </summary>    <ul><p><span>Options</span></p>        </ul></details>  <p><strong>execCaptureSync</strong><em>(cmd, opts)</em>  &nbsp;=&gt;  <ul><span>ReturnType</span></ul></p></p>    </ul></details><details id="exists$9" title="Function" ><summary><span><a href="#exists$9">#</a></span>  <code><strong>exists</strong></code><em>(pathname)</em>    </summary>  <a href="src/everyday-node.ts#L12">src/everyday-node.ts#L12</a>  <ul>    <p>    <details id="pathname$11" title="Parameter" ><summary><span><a href="#pathname$11">#</a></span>  <code><strong>pathname</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>exists</strong><em>(pathname)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;boolean&gt;</ul></p></p>    </ul></details><details id="keypress$15" title="Function" ><summary><span><a href="#keypress$15">#</a></span>  <code><strong>keypress</strong></code><em>(msg, cb)</em>    </summary>  <a href="src/everyday-node.ts#L48">src/everyday-node.ts#L48</a>  <ul>    <p>    <details id="msg$17" title="Parameter" ><summary><span><a href="#msg$17">#</a></span>  <code><strong>msg</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="cb$18" title="Function" ><summary><span><a href="#cb$18">#</a></span>  <code><strong>cb</strong></code><em>(char, key)</em>    </summary>    <ul>    <p>    <details id="char$21" title="Parameter" ><summary><span><a href="#char$21">#</a></span>  <code><strong>char</strong></code>    </summary>    <ul><p>string</p>        </ul></details><details id="key$22" title="Parameter" ><summary><span><a href="#key$22">#</a></span>  <code><strong>key</strong></code>    </summary>    <ul><p><a href="#Key$52">Key</a></p>        </ul></details>  <p><strong>cb</strong><em>(char, key)</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>  <p><strong>keypress</strong><em>(msg, cb)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;<details id="__type$23" title="Function" ><summary><span><a href="#__type$23">#</a></span>  <em>()</em>    </summary>    <ul>    <p>      <p><strong></strong><em>()</em>  &nbsp;=&gt;  <ul>void</ul></p></p>    </ul></details>&gt;</ul></p></p>    </ul></details><details id="keypressSync$12" title="Function" ><summary><span><a href="#keypressSync$12">#</a></span>  <code><strong>keypressSync</strong></code><em>(msg)</em>    </summary>  <a href="src/everyday-node.ts#L22">src/everyday-node.ts#L22</a>  <ul>    <p>    <details id="msg$14" title="Parameter" ><summary><span><a href="#msg$14">#</a></span>  <code><strong>msg</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>keypressSync</strong><em>(msg)</em>  &nbsp;=&gt;  <ul>string</ul></p></p>    </ul></details><details id="singleKeypress$25" title="Function" ><summary><span><a href="#singleKeypress$25">#</a></span>  <code><strong>singleKeypress</strong></code><em>(msg)</em>    </summary>  <a href="src/everyday-node.ts#L62">src/everyday-node.ts#L62</a>  <ul>    <p>    <details id="msg$27" title="Parameter" ><summary><span><a href="#msg$27">#</a></span>  <code><strong>msg</strong></code>    </summary>    <ul><p>string</p>        </ul></details>  <p><strong>singleKeypress</strong><em>(msg)</em>  &nbsp;=&gt;  <ul><span>Promise</span>&lt;{<p>  <details id="char$29" title="Property" ><summary><span><a href="#char$29">#</a></span>  <code><strong>char</strong></code>    </summary>  <a href="src/everyday-node.ts#L70">src/everyday-node.ts#L70</a>  <ul><p>string</p>        </ul></details><details id="key$30" title="Property" ><summary><span><a href="#key$30">#</a></span>  <code><strong>key</strong></code>    </summary>  <a href="src/everyday-node.ts#L70">src/everyday-node.ts#L70</a>  <ul><p><a href="#Key$52">Key</a></p>        </ul></details></p>}&gt;</ul></p></p>    </ul></details></p>

## Credits

- [get-pty-output](https://npmjs.org/package/get-pty-output) by [CyriacBr](https://github.com/CyriacBr) &ndash; Execute an external command with a PTY, from Node

## Contributing

[Fork](https://github.com/stagas/everyday-node/fork) or [edit](https://github.dev/stagas/everyday-node) and submit a PR.

All contributions are welcome!

## License

<a href="LICENSE">MIT</a> &copy; 2022 [stagas](https://github.com/stagas)
